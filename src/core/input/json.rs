// src/core/input/json.rs

//! JSON format parser for tree files.
//!
//! Parses JSON tree files generated by RusTree and reconstructs the NodeInfo structure.

use crate::core::error::RustreeError;
use crate::core::input::TreeParser;
use crate::core::tree::node::{NodeInfo, NodeType};
use std::path::PathBuf;

pub struct JsonTreeParser;

impl TreeParser for JsonTreeParser {
    fn parse(&self, content: &str) -> Result<Vec<NodeInfo>, RustreeError> {
        let json_data: serde_json::Value = serde_json::from_str(content)
            .map_err(|e| RustreeError::ParseError(format!("Invalid JSON: {}", e)))?;

        if !json_data.is_array() {
            return Err(RustreeError::ParseError(
                "Expected JSON array as root element".to_string(),
            ));
        }

        let array = json_data.as_array().unwrap();

        // Filter out the report object (type: "report") and process only tree nodes
        let tree_nodes: Vec<&serde_json::Value> = array
            .iter()
            .filter(|item| {
                item.get("type")
                    .and_then(|t| t.as_str())
                    .map(|t| t != "report")
                    .unwrap_or(false)
            })
            .collect();

        if tree_nodes.is_empty() {
            return Err(RustreeError::ParseError(
                "No tree nodes found in JSON".to_string(),
            ));
        }

        let mut result = Vec::new();

        // Process each root node
        for root_node in tree_nodes {
            Self::parse_node(root_node, PathBuf::new(), 0, &mut result)?;
        }

        Ok(result)
    }
}

impl JsonTreeParser {
    /// Recursively parse a JSON node and its children
    fn parse_node(
        node: &serde_json::Value,
        parent_path: PathBuf,
        depth: usize,
        result: &mut Vec<NodeInfo>,
    ) -> Result<(), RustreeError> {
        let node_type_str = node
            .get("type")
            .and_then(|t| t.as_str())
            .ok_or_else(|| RustreeError::ParseError("Missing 'type' field".to_string()))?;

        let node_type = match node_type_str {
            "directory" => NodeType::Directory,
            "file" => NodeType::File,
            "symlink" => NodeType::Symlink,
            _ => {
                return Err(RustreeError::ParseError(format!(
                    "Unknown node type: {}",
                    node_type_str
                )));
            }
        };

        let name = node
            .get("name")
            .and_then(|n| n.as_str())
            .ok_or_else(|| RustreeError::ParseError("Missing 'name' field".to_string()))?
            .to_string();

        // Check if this is the synthetic root directory that wraps the actual content
        let is_synthetic_root = depth == 0 && name == "." && node_type == NodeType::Directory;

        if is_synthetic_root {
            // This is RusTree's synthetic root wrapper - process children directly without adding this node
            if let Some(contents) = node.get("contents") {
                if let Some(children_array) = contents.as_array() {
                    for child in children_array {
                        // Children of synthetic root should start at depth 1 to match filesystem scanner
                        Self::parse_node(child, PathBuf::new(), 1, result)?;
                    }
                }
            }
            return Ok(());
        }

        let current_path = if parent_path.as_os_str().is_empty() {
            PathBuf::from(&name)
        } else {
            parent_path.join(&name)
        };

        // Parse custom function output if present
        let custom_function_output = node
            .get("apply_command_output")
            .and_then(|output| output.as_str().map(|output_str| Ok(output_str.to_string())));

        // Create NodeInfo
        let node_info = NodeInfo {
            path: current_path.clone(),
            name,
            node_type: node_type.clone(),
            depth,
            size: None, // JSON format doesn't typically include metadata
            permissions: None,
            mtime: None,
            change_time: None,
            create_time: None,
            line_count: None,
            word_count: None,
            custom_function_output,
        };

        result.push(node_info);

        // Process children if this is a directory
        if node_type == NodeType::Directory {
            if let Some(contents) = node.get("contents") {
                if let Some(children_array) = contents.as_array() {
                    for child in children_array {
                        Self::parse_node(child, current_path.clone(), depth + 1, result)?;
                    }
                }
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_json_tree() {
        let json_content = r#"
[
  {
    "type": "directory",
    "name": ".",
    "contents": [
      {
        "type": "directory",
        "name": "src",
        "contents": [
          {
            "type": "file",
            "name": "main.rs"
          }
        ]
      },
      {
        "type": "file",
        "name": "Cargo.toml"
      }
    ]
  },
  {
    "type": "report",
    "directories": 2,
    "files": 2
  }
]
        "#;

        let parser = JsonTreeParser;
        let result = parser.parse(json_content).unwrap();

        assert_eq!(result.len(), 3); // src, main.rs, Cargo.toml (synthetic root "." is skipped)

        // Check src directory (now at index 0 since synthetic root is skipped)
        assert_eq!(result[0].name, "src");
        assert_eq!(result[0].node_type, NodeType::Directory);
        assert_eq!(result[0].depth, 1);
        assert_eq!(result[0].path, PathBuf::from("src"));

        // Check main.rs file
        assert_eq!(result[1].name, "main.rs");
        assert_eq!(result[1].node_type, NodeType::File);
        assert_eq!(result[1].depth, 2);
        assert_eq!(result[1].path, PathBuf::from("src/main.rs"));

        // Check Cargo.toml file
        assert_eq!(result[2].name, "Cargo.toml");
        assert_eq!(result[2].node_type, NodeType::File);
        assert_eq!(result[2].depth, 1);
        assert_eq!(result[2].path, PathBuf::from("Cargo.toml"));
    }

    #[test]
    fn test_parse_json_with_apply_function_output() {
        let json_content = r#"
[
  {
    "type": "directory",
    "name": "test",
    "contents": [
      {
        "type": "file",
        "name": "example.txt",
        "apply_command": "CountPluses",
        "apply_command_output": "5"
      }
    ]
  }
]
        "#;

        let parser = JsonTreeParser;
        let result = parser.parse(json_content).unwrap();

        assert_eq!(result.len(), 2); // test directory and example.txt file

        // Check file with apply function output
        let file_node = &result[1];
        assert_eq!(file_node.name, "example.txt");
        assert!(file_node.custom_function_output.is_some());
        if let Some(Ok(output)) = &file_node.custom_function_output {
            assert_eq!(output, "5");
        } else {
            panic!("Expected apply function output");
        }
    }

    #[test]
    fn test_parse_invalid_json() {
        let invalid_json = "{ invalid json }";
        let parser = JsonTreeParser;
        let result = parser.parse(invalid_json);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_empty_json_array() {
        let empty_json = "[]";
        let parser = JsonTreeParser;
        let result = parser.parse(empty_json);
        assert!(result.is_err());
    }
}
