// src/core/input/html.rs

//! HTML format parser for tree files.
//!
//! Parses HTML format files generated by RusTree and reconstructs the NodeInfo structure.

use crate::core::error::RustreeError;
use crate::core::input::TreeParser;
use crate::core::input::text::TextTreeParser;
use crate::core::tree::node::NodeInfo;

pub struct HtmlTreeParser;

impl TreeParser for HtmlTreeParser {
    fn parse(&self, content: &str) -> Result<Vec<NodeInfo>, RustreeError> {
        // Extract the tree content from <pre> tags
        let tree_content = Self::extract_pre_content(content)?;

        // Remove HTML links to get clean text tree format
        let clean_content = Self::remove_html_links(&tree_content);

        // Use the text parser to parse the cleaned content
        let text_parser = TextTreeParser;
        text_parser.parse(&clean_content)
    }
}

impl HtmlTreeParser {
    /// Extract content from <pre> tags
    fn extract_pre_content(content: &str) -> Result<String, RustreeError> {
        // Find the opening <pre> tag
        let start_marker = "<pre>";
        let end_marker = "</pre>";

        if let Some(start_pos) = content.find(start_marker) {
            let content_start = start_pos + start_marker.len();
            if let Some(end_pos) = content[content_start..].find(end_marker) {
                let tree_content = &content[content_start..content_start + end_pos];
                return Ok(tree_content.to_string());
            }
        }

        Err(RustreeError::ParseError(
            "Could not find <pre> content in HTML".to_string(),
        ))
    }

    /// Remove HTML links while preserving the file/directory names
    fn remove_html_links(content: &str) -> String {
        // Use a simple regex-like approach to remove HTML tags
        let mut result = String::new();
        let mut in_tag = false;

        for c in content.chars() {
            if c == '<' {
                in_tag = true;
                // Don't add the '<' character
            } else if c == '>' && in_tag {
                in_tag = false;
                // Don't add the '>' character
            } else if !in_tag {
                // Only add characters when we're not inside a tag
                result.push(c);
            }
            // If in_tag is true and c != '>', we skip the character (it's part of the tag)
        }

        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::tree::node::NodeType;
    use std::path::PathBuf;

    #[test]
    fn test_extract_pre_content() {
        let html_content = r#"<html><body><pre>./
├── file.txt
└── dir/</pre></body></html>"#;

        let content = HtmlTreeParser::extract_pre_content(html_content).unwrap();
        assert_eq!(content, "./\n├── file.txt\n└── dir/");
    }

    #[test]
    fn test_remove_html_links() {
        let content_with_links = r#"./
├── <a href="file.txt">file.txt</a>
└── <a href="dir">dir/</a>"#;

        let clean_content = HtmlTreeParser::remove_html_links(content_with_links);
        assert_eq!(clean_content, "./\n├── file.txt\n└── dir/");
    }

    #[test]
    fn test_parse_simple_html_tree() {
        let html_content = r#"<!DOCTYPE html>
<html>
<head><title>Tree</title></head>
<body>
<pre>./
├── <a href="src">src/</a>
│   ├── <a href="src/main.rs">main.rs</a>
│   └── <a href="src/lib.rs">lib.rs</a>
├── <a href="Cargo.toml">Cargo.toml</a>
└── <a href="README.md">README.md</a>

2 directories, 3 files</pre>
</body>
</html>"#;

        let parser = HtmlTreeParser;
        let result = parser.parse(html_content).unwrap();

        assert_eq!(result.len(), 5);

        // Check src directory
        assert_eq!(result[0].name, "src");
        assert_eq!(result[0].node_type, NodeType::Directory);
        assert_eq!(result[0].depth, 1);
        assert_eq!(result[0].path, PathBuf::from("src"));

        // Check main.rs file
        assert_eq!(result[1].name, "main.rs");
        assert_eq!(result[1].node_type, NodeType::File);
        assert_eq!(result[1].depth, 2);
        assert_eq!(result[1].path, PathBuf::from("src/main.rs"));

        // Check Cargo.toml file
        assert_eq!(result[3].name, "Cargo.toml");
        assert_eq!(result[3].node_type, NodeType::File);
        assert_eq!(result[3].depth, 1);
        assert_eq!(result[3].path, PathBuf::from("Cargo.toml"));
    }

    #[test]
    fn test_parse_html_without_pre_tags() {
        let html_content = "<html><body>No pre tags here</body></html>";
        let parser = HtmlTreeParser;
        let result = parser.parse(html_content);
        assert!(result.is_err());
    }
}
