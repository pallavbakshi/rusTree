// src/core/input/markdown.rs

//! Markdown format parser for tree files.
//!
//! Parses markdown tree files generated by RusTree and reconstructs the NodeInfo structure.

use crate::core::error::RustreeError;
use crate::core::input::TreeParser;
use crate::core::tree::node::{NodeInfo, NodeType};
use std::path::PathBuf;

pub struct MarkdownTreeParser;

impl TreeParser for MarkdownTreeParser {
    fn parse(&self, content: &str) -> Result<Vec<NodeInfo>, RustreeError> {
        let lines: Vec<&str> = content.lines().collect();
        let mut result = Vec::new();
        let mut i = 0;
        let mut directory_stack: Vec<String> = Vec::new();

        // Skip the root heading if present (e.g., "# .")
        if i < lines.len() && lines[i].trim().starts_with('#') {
            i += 1;
            // Skip empty lines after heading
            while i < lines.len() && lines[i].trim().is_empty() {
                i += 1;
            }
        }

        // Parse tree items
        while i < lines.len() {
            let line = lines[i];

            // Skip summary line at the end
            if line.starts_with("__") && line.contains("directories") && line.contains("files") {
                break;
            }

            // Skip empty lines
            if line.trim().is_empty() {
                i += 1;
                continue;
            }

            // Parse markdown list item
            if let Some(node_info) = Self::parse_markdown_line(line, &mut directory_stack)? {
                result.push(node_info);
            }

            i += 1;
        }

        Ok(result)
    }
}

impl MarkdownTreeParser {
    /// Parse a single markdown line into a NodeInfo
    fn parse_markdown_line(
        line: &str,
        directory_stack: &mut Vec<String>,
    ) -> Result<Option<NodeInfo>, RustreeError> {
        let trimmed = line.trim();

        // Skip lines that don't start with list markers
        if !trimmed.starts_with("* ") && !trimmed.starts_with("- ") && !trimmed.starts_with("+ ") {
            return Ok(None);
        }

        // Calculate depth based on leading spaces before the "*"
        let leading_spaces = line.len() - line.trim_start().len();
        let depth = (leading_spaces / 2) + 1; // Each level is 2 spaces + start at depth 1

        // Extract name (everything after the bullet marker and space)
        let name = trimmed[2..].trim().to_string();

        // Determine if it's a directory (ends with "/") or file
        let (clean_name, node_type) = if name.ends_with('/') {
            (name[..name.len() - 1].to_string(), NodeType::Directory)
        } else {
            (name, NodeType::File)
        };

        // Update directory stack based on current depth
        // Truncate stack to match the current depth - 1
        directory_stack.truncate(depth - 1);

        // Build the full path
        let path = if directory_stack.is_empty() {
            PathBuf::from(&clean_name)
        } else {
            let mut full_path = PathBuf::new();
            for dir in directory_stack.iter() {
                full_path.push(dir);
            }
            full_path.push(&clean_name);
            full_path
        };

        // If this is a directory, add it to the stack for future children
        if node_type == NodeType::Directory {
            directory_stack.push(clean_name.clone());
        }

        let node_info = NodeInfo {
            path,
            name: clean_name,
            node_type,
            depth,
            size: None,
            permissions: None,
            mtime: None,
            change_time: None,
            create_time: None,
            line_count: None,
            word_count: None,
            custom_function_output: None,
        };

        Ok(Some(node_info))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_markdown_tree() {
        let markdown_content = r#"# .

* src/
  * main.rs
  * lib.rs
* Cargo.toml
* README.md

__2 directories, 3 files total__"#;

        let parser = MarkdownTreeParser;
        let result = parser.parse(markdown_content).unwrap();

        assert_eq!(result.len(), 5);

        // Check src directory
        assert_eq!(result[0].name, "src");
        assert_eq!(result[0].node_type, NodeType::Directory);
        assert_eq!(result[0].depth, 1);
        assert_eq!(result[0].path, PathBuf::from("src"));

        // Check main.rs file
        assert_eq!(result[1].name, "main.rs");
        assert_eq!(result[1].node_type, NodeType::File);
        assert_eq!(result[1].depth, 2);
        assert_eq!(result[1].path, PathBuf::from("src/main.rs"));

        // Check lib.rs file
        assert_eq!(result[2].name, "lib.rs");
        assert_eq!(result[2].node_type, NodeType::File);
        assert_eq!(result[2].depth, 2);
        assert_eq!(result[2].path, PathBuf::from("src/lib.rs"));

        // Check Cargo.toml file
        assert_eq!(result[3].name, "Cargo.toml");
        assert_eq!(result[3].node_type, NodeType::File);
        assert_eq!(result[3].depth, 1);
        assert_eq!(result[3].path, PathBuf::from("Cargo.toml"));

        // Check README.md file
        assert_eq!(result[4].name, "README.md");
        assert_eq!(result[4].node_type, NodeType::File);
        assert_eq!(result[4].depth, 1);
        assert_eq!(result[4].path, PathBuf::from("README.md"));
    }

    #[test]
    fn test_parse_empty_markdown() {
        let markdown_content = "";
        let parser = MarkdownTreeParser;
        let result = parser.parse(markdown_content).unwrap();
        assert_eq!(result.len(), 0);
    }

    #[test]
    fn test_parse_markdown_only_heading() {
        let markdown_content = "# Project";
        let parser = MarkdownTreeParser;
        let result = parser.parse(markdown_content).unwrap();
        assert_eq!(result.len(), 0);
    }
}
