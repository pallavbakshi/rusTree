// src/core/input/text.rs

//! Text format parser for tree files.
//!
//! Parses ASCII tree format files generated by RusTree and reconstructs the NodeInfo structure.

use crate::core::error::RustreeError;
use crate::core::input::TreeParser;
use crate::core::tree::node::{NodeInfo, NodeType};
use std::path::PathBuf;

pub struct TextTreeParser;

impl TreeParser for TextTreeParser {
    fn parse(&self, content: &str) -> Result<Vec<NodeInfo>, RustreeError> {
        let lines: Vec<&str> = content.lines().collect();
        let mut result = Vec::new();
        let mut directory_stack: Vec<String> = Vec::new();
        let mut i = 0;

        // Skip the root directory line if present (e.g., "./")
        if i < lines.len() && (lines[i].trim() == "./" || lines[i].trim() == ".") {
            i += 1;
        }

        // Parse tree items
        while i < lines.len() {
            let line = lines[i];

            // Skip summary line at the end
            if line.contains("directories,") && line.contains("files") {
                break;
            }

            // Skip empty lines
            if line.trim().is_empty() {
                i += 1;
                continue;
            }

            // Parse text tree line
            if let Some(node_info) = Self::parse_text_line(line, &mut directory_stack)? {
                result.push(node_info);
            }

            i += 1;
        }

        Ok(result)
    }
}

impl TextTreeParser {
    /// Parse a single text tree line into a NodeInfo
    fn parse_text_line(
        line: &str,
        directory_stack: &mut Vec<String>,
    ) -> Result<Option<NodeInfo>, RustreeError> {
        // Skip lines that don't contain tree characters
        if !line.contains("├──") && !line.contains("└──") {
            return Ok(None);
        }

        // Calculate depth by counting tree continuation characters
        let depth = Self::calculate_depth(line)?;

        // Extract the name from the line
        let name = Self::extract_name(line)?;

        // Determine if it's a directory (ends with "/") or file
        let (clean_name, node_type) = if name.ends_with('/') {
            (name[..name.len() - 1].to_string(), NodeType::Directory)
        } else {
            (name, NodeType::File)
        };

        // Update directory stack based on current depth
        directory_stack.truncate(depth.saturating_sub(1));

        // Build the full path
        let path = if directory_stack.is_empty() {
            PathBuf::from(&clean_name)
        } else {
            let mut full_path = PathBuf::new();
            for dir in directory_stack.iter() {
                full_path.push(dir);
            }
            full_path.push(&clean_name);
            full_path
        };

        // If this is a directory, add it to the stack for future children
        if node_type == NodeType::Directory {
            directory_stack.push(clean_name.clone());
        }

        let node_info = NodeInfo {
            path,
            name: clean_name,
            node_type,
            depth,
            size: None,
            permissions: None,
            mtime: None,
            change_time: None,
            create_time: None,
            line_count: None,
            word_count: None,
            custom_function_output: None,
        };

        Ok(Some(node_info))
    }

    /// Calculate the depth based on tree characters in the line
    fn calculate_depth(line: &str) -> Result<usize, RustreeError> {
        // Count the number of tree continuation blocks before the final connector
        let mut depth = 1; // Start at 1 for the root level
        let mut i = 0;
        let chars: Vec<char> = line.chars().collect();

        while i < chars.len() {
            if i + 3 < chars.len() {
                // Check for continuation pattern "│   " (4 characters)
                if chars[i] == '│'
                    && chars[i + 1] == ' '
                    && chars[i + 2] == ' '
                    && chars[i + 3] == ' '
                {
                    depth += 1;
                    i += 4; // Skip the continuation block
                    continue;
                }
                // Check for empty continuation "    " (4 spaces)
                if chars[i] == ' '
                    && chars[i + 1] == ' '
                    && chars[i + 2] == ' '
                    && chars[i + 3] == ' '
                {
                    depth += 1;
                    i += 4; // Skip the empty continuation block
                    continue;
                }
            }

            // Check for tree connectors
            if chars[i] == '├' || chars[i] == '└' {
                break; // Found the final connector
            }

            i += 1;
        }

        Ok(depth)
    }

    /// Extract the filename/directory name from the tree line
    fn extract_name(line: &str) -> Result<String, RustreeError> {
        // Find the position after the tree connector (├── or └──)
        if let Some(pos) = line.find("├── ") {
            let start_pos = pos + "├── ".len();
            return Ok(line[start_pos..].trim().to_string());
        }
        if let Some(pos) = line.find("└── ") {
            let start_pos = pos + "└── ".len();
            return Ok(line[start_pos..].trim().to_string());
        }

        Err(RustreeError::ParseError(
            "Could not extract name from tree line".to_string(),
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_text_tree() {
        let text_content = r#"./
├── src/
│   ├── main.rs
│   └── lib.rs
├── Cargo.toml
└── README.md

2 directories, 3 files"#;

        let parser = TextTreeParser;
        let result = parser.parse(text_content).unwrap();

        assert_eq!(result.len(), 5);

        // Check src directory
        assert_eq!(result[0].name, "src");
        assert_eq!(result[0].node_type, NodeType::Directory);
        assert_eq!(result[0].depth, 1);
        assert_eq!(result[0].path, PathBuf::from("src"));

        // Check main.rs file
        assert_eq!(result[1].name, "main.rs");
        assert_eq!(result[1].node_type, NodeType::File);
        assert_eq!(result[1].depth, 2);
        assert_eq!(result[1].path, PathBuf::from("src/main.rs"));

        // Check lib.rs file
        assert_eq!(result[2].name, "lib.rs");
        assert_eq!(result[2].node_type, NodeType::File);
        assert_eq!(result[2].depth, 2);
        assert_eq!(result[2].path, PathBuf::from("src/lib.rs"));

        // Check Cargo.toml file
        assert_eq!(result[3].name, "Cargo.toml");
        assert_eq!(result[3].node_type, NodeType::File);
        assert_eq!(result[3].depth, 1);
        assert_eq!(result[3].path, PathBuf::from("Cargo.toml"));

        // Check README.md file
        assert_eq!(result[4].name, "README.md");
        assert_eq!(result[4].node_type, NodeType::File);
        assert_eq!(result[4].depth, 1);
        assert_eq!(result[4].path, PathBuf::from("README.md"));
    }

    #[test]
    fn test_parse_empty_text() {
        let text_content = "";
        let parser = TextTreeParser;
        let result = parser.parse(text_content).unwrap();
        assert_eq!(result.len(), 0);
    }

    #[test]
    fn test_parse_text_only_root() {
        let text_content = "./";
        let parser = TextTreeParser;
        let result = parser.parse(text_content).unwrap();
        assert_eq!(result.len(), 0);
    }

    #[test]
    fn test_extract_name() {
        assert_eq!(
            TextTreeParser::extract_name("├── file.txt").unwrap(),
            "file.txt"
        );
        assert_eq!(
            TextTreeParser::extract_name("└── directory/").unwrap(),
            "directory/"
        );
        assert_eq!(
            TextTreeParser::extract_name("│   ├── nested.rs").unwrap(),
            "nested.rs"
        );
    }

    #[test]
    fn test_calculate_depth() {
        assert_eq!(TextTreeParser::calculate_depth("├── file.txt").unwrap(), 1);
        assert_eq!(
            TextTreeParser::calculate_depth("│   ├── nested.rs").unwrap(),
            2
        );
        assert_eq!(
            TextTreeParser::calculate_depth("│   │   └── deep.py").unwrap(),
            3
        );
    }
}
