<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RusTree Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RusTree Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-rustree"><a class="header" href="#introduction-to-rustree">Introduction to RusTree</a></h1>
<p>Welcome to RusTree!</p>
<p>RusTree is a command-line tool and Rust library designed to display directory structures in a tree-like format, similar to the classic <code>tree</code> command, but with enhanced features for analysis and output customization.</p>
<h2 id="what-can-rustree-do"><a class="header" href="#what-can-rustree-do">What can RusTree do?</a></h2>
<ul>
<li><strong>Visualize Directory Structures:</strong> Clearly see the hierarchy of files and folders.</li>
<li><strong>Filter and Ignore Entries:</strong>
<ul>
<li>List only files/directories matching specific wildcard patterns (<code>-P</code> or <code>--filter-include</code>).</li>
<li>Exclude files/directories using glob patterns (<code>-I</code> or <code>--filter-exclude</code>).</li>
<li>Respect <code>.gitignore</code> files (<code>--use-gitignore-rules</code>) and custom ignore files (<code>--gitignore-file</code>).</li>
<li>Perform case-insensitive pattern matching (<code>--case-insensitive-filter</code>).</li>
<li>Prune empty directories from the output (<code>--prune-empty-directories</code>).</li>
</ul>
</li>
<li><strong>Analyze Content:</strong> Get insights like file sizes, modification dates, line counts, and word counts.</li>
<li><strong>Apply Custom Logic:</strong> Use built-in functions (or extend with your own) to process file contents and report results.</li>
<li><strong>Sort Entries:</strong> Organize the tree output by name, size, modification time, or other criteria.</li>
<li><strong>Flexible Output:</strong> Choose between plain text tree format or Markdown.</li>
<li><strong>Cross-Platform:</strong> Built with Rust, aiming for compatibility across different operating systems.</li>
</ul>
<h2 id="who-is-this-for"><a class="header" href="#who-is-this-for">Who is this for?</a></h2>
<ul>
<li><strong>Developers:</strong> Who need to quickly understand the layout of a project or directory.</li>
<li><strong>System Administrators:</strong> For inspecting directory contents and sizes.</li>
<li><strong>Anyone working with files:</strong> Who wants a more powerful alternative to basic <code>ls</code> or <code>dir</code> commands.</li>
<li><strong>Rustaceans:</strong> Who want to use or contribute to a Rust-based utility.</li>
</ul>
<p>This documentation will guide you through installing RusTree, using its command-line interface, and leveraging its capabilities as a Rust library in your own projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This section will help you get RusTree up and running.</p>
<p>We'll cover:</p>
<ul>
<li><a href="./getting_started/installation.html">Installation</a>: How to install the RusTree command-line tool.</li>
<li><a href="./getting_started/basic_usage.html">Basic Usage</a>: A quick tour of how to use RusTree from your terminal.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>RusTree is a Rust application and can be installed using Cargo, Rust's package manager.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>Ensure you have Rust and Cargo installed. If not, please visit <a href="https://rustup.rs/">rustup.rs</a> to install them.</p>
<h3 id="installing-from-cratesio-recommended"><a class="header" href="#installing-from-cratesio-recommended">Installing from Crates.io (Recommended)</a></h3>
<p>Once RusTree is published to <a href="https://crates.io/">crates.io</a>, you can install it directly using:</p>
<pre><code class="language-bash">cargo install rustree
</code></pre>
<p>This will download the source code, compile it, and place the <code>rustree</code> executable in your Cargo binary directory (usually <code>~/.cargo/bin/</code>). Make sure this directory is in your system's <code>PATH</code>.</p>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h3>
<p>If you want to build from the latest source code (e.g., from a Git repository):</p>
<ol>
<li>
<p>Clone the repository:</p>
<pre><code class="language-bash">git clone https://github.com/yourusername/rustree.git # Replace with actual URL
cd rustree
</code></pre>
</li>
<li>
<p>Build and install the binary:</p>
<pre><code class="language-bash">cargo install --path .
</code></pre>
<p>Alternatively, to just build for development:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>The executable will be located at <code>target/release/rustree</code>.</p>
</li>
</ol>
<h3 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h3>
<p>After installation, you should be able to run:</p>
<pre><code class="language-bash">rustree --version
</code></pre>
<p>This command should print the installed version of RusTree. If you see an error, ensure <code>~/.cargo/bin</code> is in your <code>PATH</code> or try opening a new terminal session.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>Once RusTree is installed, you can use it from your command line.</p>
<h3 id="displaying-the-current-directory"><a class="header" href="#displaying-the-current-directory">Displaying the Current Directory</a></h3>
<p>The simplest way to use RusTree is to navigate to the directory you want to inspect and run:</p>
<pre><code class="language-bash">rustree
</code></pre>
<p>This will display the tree structure of the current directory (<code>.</code>).</p>
<h3 id="specifying-a-path"><a class="header" href="#specifying-a-path">Specifying a Path</a></h3>
<p>You can also specify a path to a directory:</p>
<pre><code class="language-bash">rustree /path/to/your/directory
</code></pre>
<p>Or a relative path:</p>
<pre><code class="language-bash">rustree ../some/other/folder
</code></pre>
<h3 id="common-options"><a class="header" href="#common-options">Common Options</a></h3>
<p>Here are a few common options to get you started:</p>
<ul>
<li>
<p><strong>Show all files (including hidden):</strong></p>
<pre><code class="language-bash">rustree -a
# or
rustree --include-hidden
</code></pre>
</li>
<li>
<p><strong>Limit depth:</strong></p>
<pre><code class="language-bash">rustree -L 2  # Show current directory and its direct children (depth 1 and 2)
# or
rustree --depth 2
</code></pre>
</li>
<li>
<p><strong>Show file sizes (in bytes):</strong></p>
<pre><code class="language-bash">rustree -s
# or
rustree --show-size-bytes
</code></pre>
</li>
<li>
<p><strong>Sort by size (ascending):</strong></p>
<pre><code class="language-bash">rustree --sort-by size
</code></pre>
</li>
<li>
<p><strong>Sort by size (descending):</strong></p>
<pre><code class="language-bash">rustree --sort-by size -r
# or
rustree --sort-by size --reverse-sort
</code></pre>
</li>
<li>
<p><strong>Display file contents after tree structure:</strong></p>
<pre><code class="language-bash">rustree --apply-function cat
</code></pre>
<p>This shows the directory tree first, then displays the content of each file with clear headers.</p>
</li>
<li>
<p><strong>Count specific characters in files:</strong></p>
<pre><code class="language-bash">rustree --apply-function count-pluses
</code></pre>
<p>This counts '+' characters in each file and displays the count in metadata.</p>
</li>
</ul>
<h3 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h3>
<p>For a full list of options and commands, use the help flag:</p>
<pre><code class="language-bash">rustree --help
</code></pre>
<p>This will display all available arguments and their descriptions.</p>
<p>Explore the <a href="getting_started/../cli_usage.html">Command-Line Interface (CLI)</a> section for more detailed information on all options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface-cli"><a class="header" href="#command-line-interface-cli">Command-Line Interface (CLI)</a></h1>
<p>This section details the usage of the <code>rustree</code> command-line tool.</p>
<p>The basic syntax is:</p>
<pre><code class="language-bash">rustree [OPTIONS] [PATH]
</code></pre>
<ul>
<li><code>[OPTIONS]</code>: Various flags to control behavior (e.g., depth, sorting, output format, apply functions).</li>
<li><code>[PATH]</code>: Optional path to the directory to scan. Defaults to the current directory (<code>.</code>).</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Tree visualization</strong> with customizable depth and formatting</li>
<li><strong>Metadata display</strong> including sizes, timestamps, line/word counts</li>
<li><strong>Enhanced summary report</strong> with automatic aggregation of metadata totals</li>
<li><strong>Apply functions</strong> to analyze file contents and directory statistics</li>
<li><strong>Flexible filtering</strong> with patterns, gitignore support, and function-specific filtering</li>
<li><strong>Advanced sorting</strong> by various criteria including custom function output</li>
<li><strong>Multiple output formats</strong> (text, markdown) for different use cases</li>
</ul>
<h3 id="enhanced-summary-reports"><a class="header" href="#enhanced-summary-reports">Enhanced Summary Reports</a></h3>
<p>When using metadata flags like <code>--calculate-lines</code>, <code>--calculate-words</code>, or <code>--show-size-bytes</code>, the summary line automatically includes aggregated totals:</p>
<pre><code class="language-bash"># Instead of just: "3 directories, 15 files"
# You now get: "3 directories, 15 files, 1,234 total lines, 5,678 total words, 2.1 MB total"
</code></pre>
<p>This feature works with:</p>
<ul>
<li>Line counts (<code>--calculate-lines</code>)</li>
<li>Word counts (<code>--calculate-words</code>)</li>
<li>File sizes (<code>--show-size-bytes</code>)</li>
<li>Apply function outputs (when numeric)</li>
<li>Large numbers are formatted with thousand separators for readability</li>
</ul>
<h2 id="sub-sections"><a class="header" href="#sub-sections">Sub-sections:</a></h2>
<ul>
<li><a href="./cli_usage/options.html">Options and Flags</a>: A comprehensive list of all available command-line options.</li>
<li><a href="./cli_usage/examples.html">Examples</a>: Practical examples demonstrating various use cases.</li>
</ul>
<p>To see all available options directly from your terminal, run:</p>
<pre><code class="language-bash">rustree --help
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-options"><a class="header" href="#command-line-options">Command-Line Options</a></h1>
<p>This page details all available command-line options for <code>rustree</code>.</p>
<p>The basic syntax is:
<code>rustree [OPTIONS] [PATH]</code></p>
<p>If <code>PATH</code> is omitted, it defaults to the current directory (<code>.</code>).</p>
<h2 id="path-argument"><a class="header" href="#path-argument">Path Argument</a></h2>
<ul>
<li><code>[PATH]</code>
<ul>
<li>Description: The directory or file path to process. If omitted, defaults to the current directory (<code>.</code>).</li>
<li>Example: <code>rustree ./my_project</code>, <code>rustree /var/log/syslog</code></li>
</ul>
</li>
</ul>
<h2 id="listing-control"><a class="header" href="#listing-control">Listing Control</a></h2>
<ul>
<li>
<p><code>-a, --include-hidden</code></p>
<ul>
<li>Description: Include hidden files and directories (those starting with a <code>.</code>) in the listing. (Original <code>tree</code> flag: <code>-a</code>)</li>
<li>Example: <code>rustree -a</code></li>
</ul>
</li>
<li>
<p><code>-d, --directory-only</code></p>
<ul>
<li>Description: List directories only. Files will not be included in the output. (Original <code>tree</code> flag: <code>-d</code>)</li>
<li>Example: <code>rustree -d ./src</code></li>
</ul>
</li>
<li>
<p><code>-L, --depth &lt;LEVEL&gt;</code></p>
<ul>
<li>Description: Descend only <code>&lt;LEVEL&gt;</code> directory levels deep. <code>1</code> means the root and its direct children. (Original <code>tree</code> flag: <code>-L</code>)</li>
<li>Example: <code>rustree -L 2</code> (shows root and its direct children)</li>
</ul>
</li>
<li>
<p><code>-f, --full-path</code></p>
<ul>
<li>Description: Print the full path prefix for each file. (Original <code>tree</code> flag: <code>-f</code>)</li>
<li>Example: <code>rustree -f</code></li>
</ul>
</li>
</ul>
<h2 id="filtering-and-ignoring"><a class="header" href="#filtering-and-ignoring">Filtering and Ignoring</a></h2>
<ul>
<li>
<p><code>-P, --filter-include &lt;PATTERN&gt;</code></p>
<ul>
<li>Description: List only those files and directories that match the specified wildcard pattern. This option can be used multiple times to provide several patterns. If any pattern matches, the entry is listed. (Original <code>tree</code> flag: <code>-P</code>)</li>
<li>Wildcard patterns supported:
<ul>
<li><code>*</code>: any zero or more characters.</li>
<li><code>?</code>: any single character.</li>
<li><code>[...]</code>: any single character listed (e.g., <code>[abc]</code>, <code>[a-z]</code>).</li>
<li><code>[!...]</code>: any single character not listed.</li>
<li><code>|</code>: separates alternate patterns within a single pattern string (e.g., <code>*.txt|*.log</code>).</li>
</ul>
</li>
<li>A <code>/</code> at the end of a pattern (e.g., <code>mydir/</code>) specifically matches directories.</li>
<li>Note: To match hidden files (starting with <code>.</code>) with patterns like <code>*</code>, you must also use the <code>-a</code> or <code>--include-hidden</code> option. If <code>-a</code> is not used, <code>*</code> will not match hidden entries. Patterns explicitly starting with <code>.</code> (e.g., <code>.*</code>) will match hidden files regardless of <code>-a</code>.</li>
<li>This option is affected by <code>--case-insensitive-filter</code>.</li>
<li>Example: <code>rustree -P "*.rs"</code>, <code>rustree --filter-include "*.txt|*.md" --filter-include "docs/"</code></li>
</ul>
</li>
<li>
<p><code>-I, --filter-exclude &lt;PATTERN&gt;</code></p>
<ul>
<li>Description: Do not list those files or directories that match the specified wildcard pattern. This option can be used multiple times to provide several patterns. If any pattern matches, the entry is excluded. (Original <code>tree</code> flag: <code>-I</code>)</li>
<li>Uses the same wildcard pattern syntax as <code>-P, --filter-include</code>.</li>
<li>This option is affected by <code>--case-insensitive-filter</code>.</li>
<li>Example: <code>rustree -I "*.log"</code>, <code>rustree --filter-exclude "target/" --filter-exclude "*.tmp"</code></li>
</ul>
</li>
<li>
<p><code>--use-gitignore-rules</code>, <code>--gitignore</code> (deprecated alias)</p>
<ul>
<li>Description: Respects gitignore rules for filtering files and directories. This includes checking <code>.gitignore</code> files in the scanned directories and their parents, the global gitignore file (e.g., <code>~/.config/git/ignore</code>), and repository-specific exclude files (e.g., <code>$GIT_DIR/info/exclude</code>). The <code>--gitignore</code> flag is deprecated; use <code>--use-gitignore-rules</code> instead.</li>
<li>This option is affected by <code>--case-insensitive-filter</code>.</li>
<li>Example: <code>rustree --use-gitignore-rules</code></li>
</ul>
</li>
<li>
<p><code>--gitignore-file &lt;FILE&gt;</code></p>
<ul>
<li>Description: Use the specified file(s) as additional sources of gitignore patterns. Patterns in these files are matched as if the specified file was located at the root of the scan. This option can be specified multiple times.</li>
<li>This option is affected by <code>--case-insensitive-filter</code>.</li>
<li>Example: <code>rustree --gitignore-file ./.customignore --gitignore-file ./project.ignores</code></li>
</ul>
</li>
<li>
<p><code>--case-insensitive-filter</code></p>
<ul>
<li>Description: Perform case-insensitive matching for all patterns provided via <code>-P</code> (<code>--filter-include</code>), <code>-I</code> (<code>--filter-exclude</code>), <code>--use-gitignore-rules</code> (and its alias <code>--gitignore</code>), and <code>--gitignore-file</code>.</li>
<li>Example: <code>rustree -P "*.TXT" --case-insensitive-filter</code> (would match <code>file.txt</code>)</li>
</ul>
</li>
<li>
<p><code>--prune-empty-directories</code>, <code>--prune</code> (alias)</p>
<ul>
<li>Description: Remove empty directories from the output. An empty directory is one that contains no files and no non-empty subdirectories after all other filtering (e.g., <code>-P</code>, <code>-I</code>, gitignore rules) has been applied. This option is applied before sorting.</li>
<li>Example: <code>rustree --prune-empty-directories</code>, <code>rustree --prune ./my_project</code></li>
</ul>
</li>
</ul>
<h2 id="metadata-reporting"><a class="header" href="#metadata-reporting">Metadata Reporting</a></h2>
<ul>
<li>
<p><code>-s, --show-size-bytes</code></p>
<ul>
<li>Description: Report sizes of files and directories in bytes in the output. (Original <code>tree</code> flag: <code>-s</code>)</li>
<li>Example: <code>rustree -s</code> or <code>rustree --show-size-bytes</code></li>
</ul>
</li>
<li>
<p><code>-D, --show-last-modified</code></p>
<ul>
<li>Description: Report dates for files and directories. By default, this shows the last modification time (mtime). If sorting by change time (<code>-c</code> or <code>--sort-by ctime</code>), this flag will instead display the last status change time (ctime). (Original <code>tree</code> flag: <code>-D</code>)</li>
<li>Example: <code>rustree -D</code> or <code>rustree --show-last-modified</code></li>
</ul>
</li>
</ul>
<h2 id="content-analysis"><a class="header" href="#content-analysis">Content Analysis</a></h2>
<ul>
<li>
<p><code>--calculate-lines</code></p>
<ul>
<li>Description: Calculate and display line counts for files.</li>
<li>Example: <code>rustree --calculate-lines</code></li>
</ul>
</li>
<li>
<p><code>--calculate-words</code></p>
<ul>
<li>Description: Calculate and display word counts for files.</li>
<li>Example: <code>rustree --calculate-words</code></li>
</ul>
</li>
<li>
<p><code>--apply-function &lt;FUNCTION_NAME&gt;</code></p>
<ul>
<li>Description: Apply a built-in function to file or directory contents and display the result. When using the <code>cat</code> function, the tree structure is displayed first, followed by the contents of each file.</li>
<li>Available functions:
<ul>
<li><strong>File functions</strong> (work with file content):
<ul>
<li><code>count-pluses</code>: Counts '+' characters in each file and displays the count in metadata</li>
<li><code>cat</code>: Displays the full content of each file after the tree structure</li>
</ul>
</li>
<li><strong>Directory functions</strong> (work with directory children):
<ul>
<li><code>count-files</code>: Counts the number of files in each directory</li>
<li><code>count-dirs</code>: Counts the number of subdirectories in each directory</li>
<li><code>size-total</code>: Calculates the total size of all files in each directory</li>
<li><code>dir-stats</code>: Shows combined statistics (files, directories, total size) for each directory</li>
</ul>
</li>
</ul>
</li>
<li>Example: <code>rustree --apply-function cat</code>, <code>rustree --apply-function count-pluses</code>, <code>rustree --apply-function dir-stats</code></li>
</ul>
</li>
<li>
<p><code>--apply-include &lt;PATTERN&gt;</code></p>
<ul>
<li>Description: Apply the function only to files/directories matching the specified pattern. Can be used multiple times. Uses the same wildcard syntax as <code>--filter-include</code>.</li>
<li>Example: <code>rustree --apply-function count-pluses --apply-include "*.rs"</code></li>
</ul>
</li>
<li>
<p><code>--apply-exclude &lt;PATTERN&gt;</code></p>
<ul>
<li>Description: Do not apply the function to files/directories matching the specified pattern. Can be used multiple times. Uses the same wildcard syntax as <code>--filter-exclude</code>.</li>
<li>Example: <code>rustree --apply-function dir-stats --apply-exclude "target/*"</code></li>
</ul>
</li>
<li>
<p><code>--apply-include-from &lt;FILE_PATH&gt;</code></p>
<ul>
<li>Description: Read include patterns for apply-function from the specified file. One pattern per line. Lines starting with <code>#</code> and empty lines are ignored.</li>
<li>Example: <code>rustree --apply-function cat --apply-include-from ./include-patterns.txt</code></li>
</ul>
</li>
<li>
<p><code>--apply-exclude-from &lt;FILE_PATH&gt;</code></p>
<ul>
<li>Description: Read exclude patterns for apply-function from the specified file. One pattern per line. Lines starting with <code>#</code> and empty lines are ignored.</li>
<li>Example: <code>rustree --apply-function dir-stats --apply-exclude-from ./exclude-patterns.txt</code></li>
</ul>
</li>
</ul>
<h2 id="sorting"><a class="header" href="#sorting">Sorting</a></h2>
<ul>
<li>
<p><code>-U, --unsorted</code></p>
<ul>
<li>Description: Do not sort the output. List entries in directory order. Overrides other sort options. Equivalent to <code>--sort-by none</code>. (Original <code>tree</code> flag: <code>-U</code>)</li>
<li>Example: <code>rustree -U</code></li>
</ul>
</li>
<li>
<p><code>-t</code></p>
<ul>
<li>Description: Sort the output by last modification time (mtime) instead of alphabetically. Oldest first. Equivalent to <code>--sort-by mtime</code>. (Original <code>tree</code> flag: <code>-t</code>)</li>
<li>Example: <code>rustree -t</code></li>
</ul>
</li>
<li>
<p><code>-c</code></p>
<ul>
<li>Description: Sort the output by last status change time (ctime) instead of alphabetically. Oldest first. Equivalent to <code>--sort-by ctime</code>. (Original <code>tree</code> flag: <code>-c</code>)</li>
<li>Example: <code>rustree -c</code></li>
</ul>
</li>
<li>
<p><code>-v</code></p>
<ul>
<li>Description: Sort the output by version strings embedded in file names. (Original <code>tree</code> flag: <code>-v</code>)</li>
<li>Example: <code>rustree -v</code></li>
</ul>
</li>
<li>
<p><code>--sort-by &lt;KEY&gt;</code></p>
<ul>
<li>Description: Sort the output by the given key.</li>
<li>Possible keys:
<ul>
<li><code>name</code> (default): Alphabetical sort.</li>
<li><code>size</code>: Sort by file/directory size. Default is largest first.</li>
<li><code>mtime</code>: Sort by modification time (oldest first).</li>
<li><code>ctime</code>: Sort by status change time (oldest first).</li>
<li><code>crtime</code>: Sort by creation time (oldest first). (May not be available on all systems/files.)</li>
<li><code>version</code>: Sort by version strings in names.</li>
<li><code>lines</code>: Sort by line count (requires <code>--calculate-lines</code>). Default is most lines first.</li>
<li><code>words</code>: Sort by word count (requires <code>--calculate-words</code>). Default is most words first.</li>
<li><code>custom</code>: Sort by the output of <code>--apply-function</code>.</li>
<li><code>none</code>: No sorting (directory order).</li>
</ul>
</li>
<li>Example: <code>rustree --sort-by size</code>, <code>rustree --sort-by mtime</code></li>
</ul>
</li>
<li>
<p><code>-r, --reverse-sort</code></p>
<ul>
<li>Description: Reverse the order of the sort.</li>
<li>Example: <code>rustree -t -r</code> (newest mtime first), <code>rustree --sort-by size -r</code> (smallest size first)</li>
</ul>
</li>
<li>
<p><code>--dirs-first</code></p>
<ul>
<li>Description: List directories before files. More readable. This applies to all sorting modes and overrides the default mixing behavior. Conflicts with <code>--files-first</code>.</li>
<li>Example: <code>rustree --dirs-first</code>, <code>rustree --sort-by size --dirs-first</code></li>
</ul>
</li>
<li>
<p><code>--files-first</code></p>
<ul>
<li>Description: List files before directories. More readable. This applies to all sorting modes and overrides the default mixing behavior. Conflicts with <code>--dirs-first</code>.</li>
<li>Example: <code>rustree --files-first</code>, <code>rustree --sort-by mtime --files-first</code></li>
</ul>
</li>
</ul>
<h2 id="output-formatting"><a class="header" href="#output-formatting">Output Formatting</a></h2>
<ul>
<li>
<p><code>--output-format &lt;FORMAT&gt;</code></p>
<ul>
<li>Description: Specifies the output format.</li>
<li>Possible values: <code>text</code> (default), <code>markdown</code>.</li>
<li>Example: <code>rustree --output-format markdown</code></li>
</ul>
</li>
<li>
<p><code>--no-summary-report</code></p>
<ul>
<li>Description: Omits printing of the file and directory report at the end of the tree listing. By default, <code>rustree</code> displays a summary line like "4 directories, 6 files" at the end of the output. This flag removes that summary line entirely.</li>
<li>Example: <code>rustree --no-summary-report</code>, <code>rustree --output-format markdown --no-summary-report</code></li>
</ul>
</li>
<li>
<p><code>--no-indent</code></p>
<ul>
<li>Description: Turn off file/directory indentation. (Original <code>tree</code> flag: <code>-i</code>)</li>
<li>Example: <code>rustree --no-indent</code></li>
</ul>
</li>
</ul>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<ul>
<li>
<p><code>-V, --version</code></p>
<ul>
<li>Description: Print version information and exit.</li>
<li>Example: <code>rustree -V</code></li>
</ul>
</li>
<li>
<p><code>-h, --help</code></p>
<ul>
<li>Description: Print help information and exit.</li>
<li>Example: <code>rustree --help</code></li>
</ul>
</li>
<li>
<p><code>--llm-ask &lt;PROMPT&gt;</code></p>
<ul>
<li>Description: Prepend the tree output with a specific prompt string, useful for piping to Large Language Models (LLMs). The prompt is followed by "--- TREE ---" and then the actual tree output.</li>
<li>Example: <code>rustree --llm-ask "Summarize this project structure:" | ollama run mistral</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Here are some practical examples of how to use <code>rustree</code> from the command line.</p>
<ol>
<li>
<p><strong>Basic tree of the current directory:</strong></p>
<pre><code class="language-bash">rustree
</code></pre>
</li>
<li>
<p><strong>Tree of a specific directory, showing hidden files and up to depth 2:</strong></p>
<pre><code class="language-bash">rustree --include-hidden --depth 2 /var/log
# or using short flags
rustree -a -L 2 /var/log
</code></pre>
</li>
<li>
<p><strong>List files in <code>~/Documents</code>, showing sizes and modification times, sorted by modification time (newest first using <code>-t</code> and <code>-r</code>):</strong></p>
<pre><code class="language-bash">rustree -s -D -t -r ~/Documents
# or using long flags
rustree --show-size-bytes --show-last-modified -t --reverse-sort ~/Documents
# or using --sort-by
rustree --show-size-bytes --show-last-modified --sort-by mtime --reverse-sort ~/Documents
</code></pre>
</li>
<li>
<p><strong>Analyze a source code project, showing line counts and word counts, sorted by line count (largest first):</strong></p>
<pre><code class="language-bash">rustree --calculate-lines --calculate-words --sort-by lines -r ./my_project_src
</code></pre>
<p><strong>Enhanced Summary Report</strong>: The output now includes aggregated totals in the summary:</p>
<pre><code>src/
├── [L:  364] [W:1498] lib.rs
├── [L:   63] [W: 243] main.rs
└── core/
    ├── [L:  119] [W: 264] mod.rs
    └── [L:  200] [W: 450] util.rs

2 directories, 4 files, 746 total lines, 2,455 total words
</code></pre>
</li>
<li>
<p><strong>List directories only in the current path:</strong></p>
<pre><code class="language-bash">rustree --directory-only
# or using short flag
rustree -d
</code></pre>
</li>
<li>
<p><strong>List directories only in <code>./src</code>, showing sizes, up to depth 1:</strong></p>
<pre><code class="language-bash">rustree --directory-only --show-size-bytes --depth 1 ./src
# or using short flags
rustree -d -s -L 1 ./src
</code></pre>
</li>
<li>
<p><strong>Output the tree structure as Markdown:</strong></p>
<pre><code class="language-bash">rustree --output-format markdown &gt; project_structure.md
</code></pre>
</li>
<li>
<p><strong>Output tree without the summary report at the end:</strong></p>
<pre><code class="language-bash">rustree --no-summary-report ./my_project
</code></pre>
<p>This will display the tree structure without the summary line that normally shows directory/file counts and metadata totals like "4 directories, 6 files, 1,234 total lines".</p>
</li>
<li>
<p><strong>Generate clean markdown output without summary for documentation:</strong></p>
<pre><code class="language-bash">rustree --output-format markdown --no-summary-report ./src &gt; code_structure.md
</code></pre>
<p>Perfect for including in documentation where you want just the tree structure without file counts.</p>
</li>
<li>
<p><strong>Sort by modification time (oldest first using <code>-t</code>):</strong></p>
</li>
</ol>
<pre><code class="language-bash">rustree -t ./my_project
# or using --sort-by
rustree --sort-by mtime ./my_project
</code></pre>
<ol start="11">
<li><strong>List files in directory order (unsorted using <code>-U</code>):</strong></li>
</ol>
<pre><code class="language-bash">rustree -U ./my_project
# or using long flag
rustree --unsorted ./my_project
# or using --sort-by
rustree --sort-by none ./my_project
</code></pre>
<ol start="12">
<li>
<p><strong>Apply the <code>count-pluses</code> function to files and sort by its custom output:</strong></p>
<pre><code class="language-bash">rustree --apply-function count-pluses --sort-by custom ./config_files
</code></pre>
<p><em>(This counts '+' characters in each file and displays the count in metadata).</em></p>
</li>
<li>
<p><strong>Display file contents after the tree structure using the <code>cat</code> function:</strong></p>
<pre><code class="language-bash">rustree --apply-function cat ./small_project
</code></pre>
<p>This will first display the directory tree, then show the full contents of each file in the project. Useful for getting a complete view of small projects or configuration directories.</p>
</li>
<li>
<p><strong>Combine <code>cat</code> function with filtering to show contents of specific files:</strong></p>
<pre><code class="language-bash">rustree --apply-function cat --filter-include "*.md|*.txt" ./docs
</code></pre>
<p>Shows the tree structure and then displays the contents of only Markdown and text files.</p>
</li>
<li>
<p><strong>Pipe <code>rustree</code> output to an LLM for summarization:</strong></p>
<pre><code class="language-bash">rustree --depth 1 --show-size-bytes ./src --llm-ask "What are the main components in the src directory based on this tree?"
# or using short flags
rustree -L 1 -s ./src --llm-ask "What are the main components in the src directory based on this tree?"
</code></pre>
<p>Then, you would typically pipe this entire output to your LLM command-line tool. For example:</p>
<pre><code class="language-bash">rustree -L 1 -s ./src --llm-ask "Summarize these components" | ollama run mistral
</code></pre>
</li>
<li>
<p><strong>List only Rust source files (<code>*.rs</code>):</strong></p>
<pre><code class="language-bash">rustree --filter-include "*.rs" ./my_project
# or using short flag
rustree -P "*.rs" ./my_project
</code></pre>
</li>
<li>
<p><strong>List only Markdown (<code>*.md</code>) or text (<code>*.txt</code>) files:</strong></p>
<pre><code class="language-bash">rustree --filter-include "*.md|*.txt" ./notes
# or equivalently
rustree -P "*.md" -P "*.txt" ./notes
</code></pre>
</li>
<li>
<p><strong>List only directories named <code>build</code> or <code>target</code>:</strong>
(Note: <code>-P</code> or <code>--filter-include</code> matches files and directories. A trailing <code>/</code> makes it specific to directories.)</p>
<pre><code class="language-bash">rustree --filter-include "build/|target/" ./my_project
# or using short flag
rustree -P "build/|target/" ./my_project
</code></pre>
</li>
<li>
<p><strong>List all Markdown files, including hidden ones (e.g., in <code>.github/</code>):</strong></p>
<pre><code class="language-bash">rustree --include-hidden --filter-include "*.md"
# or using short flags
rustree -a -P "*.md"
</code></pre>
</li>
<li>
<p><strong>List files starting with <code>test_</code> followed by any single character and then <code>.py</code>:</strong></p>
<pre><code class="language-bash">rustree --filter-include "test_?.py" ./tests
# or using short flag
rustree -P "test_?.py" ./tests
</code></pre>
</li>
<li>
<p><strong>List all files within any subdirectory named <code>docs</code>:</strong></p>
<pre><code class="language-bash">rustree --filter-include "docs/**" ./project_root
# or using short flag
rustree -P "docs/**" ./project_root
</code></pre>
</li>
<li>
<p><strong>Ignore all <code>.log</code> files:</strong></p>
<pre><code class="language-bash">rustree --filter-exclude "*.log" ./my_project
# or using short flag
rustree -I "*.log" ./my_project
</code></pre>
</li>
<li>
<p><strong>Ignore the <code>target/</code> directory and all <code>*.tmp</code> files:</strong></p>
<pre><code class="language-bash">rustree --filter-exclude "target/" --filter-exclude "*.tmp" ./my_project
# or using short flags
rustree -I "target/" -I "*.tmp" ./my_project
</code></pre>
</li>
<li>
<p><strong>Use <code>.gitignore</code> files to filter the output:</strong></p>
<pre><code class="language-bash">rustree --use-gitignore-rules ./my_git_repo
# or using the deprecated alias: rustree --gitignore ./my_git_repo
</code></pre>
</li>
<li>
<p><strong>Use a custom ignore file in addition to (or instead of) <code>.gitignore</code>:</strong></p>
<pre><code class="language-bash">rustree --gitignore-file ./.my_custom_ignores ./my_project
</code></pre>
<p>If you also want standard <code>.gitignore</code> behavior, add <code>--use-gitignore-rules</code> (or its alias <code>--gitignore</code>):</p>
<pre><code class="language-bash">rustree --use-gitignore-rules --gitignore-file ./.my_custom_ignores ./my_project
</code></pre>
</li>
<li>
<p><strong>List only <code>.TXT</code> files, case-insensitively (matching <code>file.txt</code>, <code>FILE.TXT</code>, etc.):</strong></p>
<pre><code class="language-bash">rustree --filter-include "*.TXT" --case-insensitive-filter ./my_project
# or using short flag
rustree -P "*.TXT" --case-insensitive-filter ./my_project
</code></pre>
</li>
<li>
<p><strong>Ignore all files ending with <code>.bak</code>, case-insensitively, using <code>-I</code>:</strong></p>
<pre><code class="language-bash">rustree --filter-exclude "*.bak" --case-insensitive-filter ./my_project
# or using short flag
rustree -I "*.bak" --case-insensitive-filter ./my_project
</code></pre>
</li>
<li>
<p><strong>Sort files by version (e.g., <code>file-1.0.0</code>, <code>file-1.2.0</code>, <code>file-2.0.0</code>):</strong></p>
<pre><code class="language-bash">rustree -v ./my_scripts
# or using --sort-by
rustree --sort-by version ./my_scripts
</code></pre>
</li>
<li>
<p><strong>Sort files by change time (ctime) and display change times:</strong></p>
<pre><code class="language-bash">rustree -c -D ./my_project
# or using --sort-by
rustree --sort-by ctime --show-last-modified ./my_project
</code></pre>
<p>This will sort by ctime (oldest first). The <code>-D</code> (or <code>--show-last-modified</code>) flag, when combined with <code>-c</code> (or <code>--sort-by ctime</code>), will display these ctimes.</p>
</li>
<li>
<p><strong>Sort files by creation time (crtime/btime), newest first:</strong>
(Note: Creation time might not be available on all filesystems or OS versions.)</p>
<pre><code class="language-bash">rustree --sort-by crtime -r ./my_photos
</code></pre>
</li>
<li>
<p><strong>Prune empty directories from the output:</strong>
Imagine a project with many empty <code>build/</code> or <code>log/</code> subdirectories.</p>
<pre><code class="language-bash">rustree --prune-empty-directories ./my_project
# or using the alias
rustree --prune ./my_project
</code></pre>
<p>This will list <code>my_project</code>, but any directories within it (or nested deeper) that become empty after other filters (like <code>-P</code>, <code>-I</code>, or gitignore) are applied will not be shown.</p>
</li>
<li>
<p><strong>Prune empty directories while listing only <code>.rs</code> files:</strong></p>
<pre><code class="language-bash">rustree -P "*.rs" --prune ./my_rust_project
</code></pre>
<p>In this case, if a directory <code>src/utils/</code> contains only <code>helper.txt</code> and <code>mod.rs</code>, after <code>-P "*.rs"</code> is applied, <code>helper.txt</code> is filtered out. If <code>src/utils/</code> now only effectively contains <code>mod.rs</code>, it's not empty. However, if <code>src/empty_module/</code> contained only <code>old_code.txt</code>, it would first be filtered by <code>-P</code>, then <code>src/empty_module/</code> would become empty and subsequently pruned by <code>--prune</code>.</p>
</li>
<li>
<p><strong>List directories before files for better readability:</strong></p>
<pre><code class="language-bash">rustree --dirs-first ./my_project
</code></pre>
<p>This will show all directories before any files at each level, making the structure more readable by grouping similar types together.</p>
</li>
<li>
<p><strong>List files before directories:</strong></p>
<pre><code class="language-bash">rustree --files-first ./my_project
</code></pre>
<p>This will show all files before any directories at each level.</p>
</li>
<li>
<p><strong>Combine directory ordering with different sort modes:</strong></p>
<pre><code class="language-bash"># Directories first, sorted by modification time
rustree --dirs-first --sort-by mtime ./my_project

# Files first, sorted by size (largest first)
rustree --files-first --sort-by size -r ./my_project

# Directories first with version sorting
rustree --dirs-first -v ./releases
</code></pre>
</li>
<li>
<p><strong>Directory ordering with metadata and filtering:</strong></p>
<pre><code class="language-bash"># Show directories first with sizes and modification times, only for .rs files and directories
rustree --dirs-first -s -D -P "*.rs|*/" ./src

# Files first, showing line counts for text files
rustree --files-first --calculate-lines -P "*.txt|*.md|*/" ./docs
</code></pre>
</li>
</ol>
<h2 id="apply-function-examples"><a class="header" href="#apply-function-examples">Apply Function Examples</a></h2>
<ol start="37">
<li>
<p><strong>Get directory statistics showing file count, directory count, and total size:</strong></p>
<pre><code class="language-bash">rustree --apply-function dir-stats --show-size-bytes ./my_project
</code></pre>
<p>This shows statistics like <code>[F: "5f,2d,1024B"]</code> for each directory, indicating 5 files, 2 subdirectories, and 1024 bytes total.</p>
</li>
<li>
<p><strong>Count files in each directory:</strong></p>
<pre><code class="language-bash">rustree --apply-function count-files ./project
</code></pre>
<p>Shows <code>[F: "3"]</code> for directories containing 3 files.</p>
</li>
<li>
<p><strong>Calculate total size of files in each directory:</strong></p>
<pre><code class="language-bash">rustree --apply-function size-total --show-size-bytes ./downloads
</code></pre>
<p>Note: <code>--show-size-bytes</code> must be enabled for size-total to work properly.</p>
</li>
<li>
<p><strong>Apply function only to specific directories using patterns:</strong></p>
<pre><code class="language-bash"># Only apply dir-stats to src directories
rustree --apply-function dir-stats --apply-include "src*" ./workspace

# Apply count-files to all directories except target and build
rustree --apply-function count-files --apply-exclude "target/*" --apply-exclude "build/*" ./project
</code></pre>
</li>
<li>
<p><strong>Use pattern files for complex filtering:</strong></p>
<p>Create a file <code>include-patterns.txt</code>:</p>
<pre><code># Include source directories
src/*
lib/*
# Include documentation
docs/*
</code></pre>
<p>Create a file <code>exclude-patterns.txt</code>:</p>
<pre><code># Exclude build artifacts
*target*
*build*
# Exclude temporary files
*.tmp
</code></pre>
<p>Then use:</p>
<pre><code class="language-bash">rustree --apply-function dir-stats \
        --apply-include-from ./include-patterns.txt \
        --apply-exclude-from ./exclude-patterns.txt ./project
</code></pre>
</li>
<li>
<p><strong>Combine cat function with selective application:</strong></p>
<pre><code class="language-bash"># Show contents of only configuration files
rustree --apply-function cat --apply-include "*.toml" --apply-include "*.yml" ./config

# Show contents excluding sensitive files
rustree --apply-function cat --apply-exclude "*secret*" --apply-exclude "*key*" ./scripts
</code></pre>
</li>
<li>
<p><strong>Directory analysis for large projects:</strong></p>
<pre><code class="language-bash"># Get overview of all subdirectories with statistics
rustree -d --apply-function dir-stats --show-size-bytes --sort-by custom -r ./large_project
</code></pre>
<p>This shows only directories (<code>-d</code>), applies statistics function, enables size collection, and sorts by the statistics output in reverse order (largest/most complex directories first).</p>
</li>
<li>
<p><strong>Analyze code organization:</strong></p>
<pre><code class="language-bash"># Count Rust files in each module directory
rustree --apply-function count-files --apply-include "*.rs" -d ./src

# Get comprehensive statistics for source directories only
rustree --apply-function dir-stats --apply-include "src*" --apply-include "lib*" ./workspace
</code></pre>
</li>
</ol>
<h2 id="metadata-aggregation-examples"><a class="header" href="#metadata-aggregation-examples">Metadata Aggregation Examples</a></h2>
<p>The summary report now automatically aggregates metadata values, providing totals for lines, words, sizes, and apply function outputs.</p>
<ol start="45">
<li>
<p><strong>Get comprehensive project statistics:</strong></p>
<pre><code class="language-bash">rustree --calculate-lines --calculate-words --show-size-bytes ./my_project
</code></pre>
<p>Output includes totals in the summary:</p>
<pre><code>my_project/
├── [   1024B] [L:  50] [W: 250] README.md
├── [   2048B] [L: 100] [W: 500] main.rs
└── src/
    ├── [   3072B] [L: 150] [W: 750] lib.rs
    └── [   1536B] [L:  75] [W: 375] util.rs

2 directories, 4 files, 375 total lines, 1,875 total words, 7.7 KB total
</code></pre>
</li>
<li>
<p><strong>Analyze large codebases with human-readable totals:</strong></p>
<pre><code class="language-bash">rustree --calculate-lines --depth 2 ./large_project
</code></pre>
<p>Automatically formats large numbers with thousand separators:</p>
<pre><code>large_project/
├── [L:12345] frontend/
├── [L: 8765] backend/
└── [L: 4321] docs/

4 directories, 156 files, 125,431 total lines
</code></pre>
</li>
<li>
<p><strong>Combine size analysis with directory statistics:</strong></p>
<pre><code class="language-bash">rustree --show-size-bytes --apply-function dir-stats ./project
</code></pre>
<p>Shows both individual file sizes and aggregated directory statistics:</p>
<pre><code>project/
├── [   512B] config.toml
├── [F: "3f,0d,1536B"] src/
│   ├── [  1024B] main.rs
│   └── [   512B] lib.rs
└── [F: "2f,0d,256B"] tests/
    ├── [  128B] test1.rs
    └── [  128B] test2.rs

3 directories, 5 files, 2.3 KB total, 1.8 KB total (from function)
</code></pre>
</li>
<li>
<p><strong>Quick project overview with multiple metadata types:</strong></p>
<pre><code class="language-bash">rustree --depth 1 --calculate-lines --calculate-words --show-size-bytes ./workspace
</code></pre>
<p>Perfect for getting a high-level overview of project complexity:</p>
<pre><code>workspace/
├── [  45.2 KB] [L:1200] [W:6000] frontend/
├── [  32.1 KB] [L: 900] [W:4500] backend/
├── [  12.8 KB] [L: 400] [W:2000] shared/
└── [   5.5 KB] [L: 150] [W: 750] docs/

5 directories, 87 files, 2,650 total lines, 13,250 total words, 95.6 KB total
</code></pre>
</li>
<li>
<p><strong>Compare module sizes in a Rust project:</strong></p>
<pre><code class="language-bash">rustree --depth 2 --show-size-bytes --filter-include "*.rs|*/" --sort-by size -r ./src
</code></pre>
<p>Shows Rust modules sorted by size with total calculations:</p>
<pre><code>src/
├── [  15.2 KB] core/
├── [  12.8 KB] utils/
├── [   8.4 KB] cli/
├── [   3.2 KB] main.rs
└── [   1.1 KB] lib.rs

4 directories, 45 files, 40.7 KB total
</code></pre>
</li>
<li>
<p><strong>Markdown output with metadata aggregation for documentation:</strong></p>
<pre><code class="language-bash">rustree --output-format markdown --calculate-lines --depth 2 ./api &gt; api_overview.md
</code></pre>
<p>Generates markdown with totals:</p>
<pre><code class="language-markdown"># ./api

* handlers/ 1250L
* models/ 800L
* routes/ 600L
* main.rs 150L

__2 directories, 25 files, 2,800 total lines total__
</code></pre>
</li>
</ol>
<p>Note: The enhanced summary report automatically detects which metadata types are being displayed and includes appropriate totals. No additional flags are needed - the aggregation happens automatically when metadata options like <code>--calculate-lines</code>, <code>--calculate-words</code>, or <code>--show-size-bytes</code> are used.</p>
<p>These examples cover common use cases. Combine options as needed to achieve your desired output! Remember to use <code>rustree --help</code> for a full list of options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-usage-api"><a class="header" href="#library-usage-api">Library Usage (API)</a></h1>
<p>Beyond the command-line tool, <code>rustree</code> can be used as a library in your own Rust projects. This allows you to programmatically generate and process directory tree information.</p>
<h2 id="adding-rustree-as-a-dependency"><a class="header" href="#adding-rustree-as-a-dependency">Adding RusTree as a Dependency</a></h2>
<p>To use <code>rustree</code> in your project, add it to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rustree = "0.1.0" # Replace with the desired version
</code></pre>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<p>The library revolves around a few key components:</p>
<ul>
<li><a href="./library_usage/concepts.html#rustreelibconfig"><code>RustreeLibConfig</code></a>: A struct to configure the behavior of the tree generation (depth, hidden files, analysis options, sorting, etc.).</li>
<li><a href="./library_usage/concepts.html#nodeinfo"><code>NodeInfo</code></a>: A struct representing a single entry (file or directory) in the tree, containing its metadata and analysis results.</li>
<li><a href="./library_usage/concepts.html#get_tree_nodes"><code>get_tree_nodes()</code></a>: The main function to walk a directory, analyze entries, and return a <code>Vec&lt;NodeInfo&gt;</code>.</li>
<li><a href="./library_usage/concepts.html#format_nodes"><code>format_nodes()</code></a>: A function to format a <code>Vec&lt;NodeInfo&gt;</code> into a string representation (e.g., text tree, Markdown).</li>
<li>Enums for options like <a href="./library_usage/concepts.html#sortkey"><code>SortKey</code></a>, <a href="./library_usage/concepts.html#liboutputformat"><code>LibOutputFormat</code></a>, etc.</li>
</ul>
<h2 id="sub-sections-1"><a class="header" href="#sub-sections-1">Sub-sections:</a></h2>
<ul>
<li><a href="./library_usage/concepts.html">Core Concepts</a>: Detailed explanation of the main types and functions.</li>
<li><a href="./library_usage/examples.html">Examples</a>: Code examples demonstrating how to use the library.</li>
</ul>
<p>The API documentation generated by <code>cargo doc</code> (and available on <code>docs.rs</code> if published) provides the most detailed reference for all public items.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="core-library-concepts"><a class="header" href="#core-library-concepts">Core Library Concepts</a></h2>
<p>Understanding these core components will help you effectively use the <code>rustree</code> library.</p>
<h3 id="rustreelibconfig"><a class="header" href="#rustreelibconfig"><code>RustreeLibConfig</code></a></h3>
<p>This struct (defined in <code>src/config/tree_options.rs</code>) is central to controlling how <code>rustree</code> behaves. It has been refactored into a hierarchical structure, grouping related options into sub-structs for better organization. You create an instance of <code>RustreeLibConfig</code> and set fields within these sub-structs:</p>
<ul>
<li><strong><code>input_source: InputSourceOptions</code></strong> (from <code>src/config/input_source.rs</code>):
<ul>
<li><code>root_display_name</code>: How the root directory is named in the output.</li>
<li><code>root_node_size</code>: Optional size of the root node itself, used by formatters if <code>metadata.show_size_bytes</code> is true.</li>
<li><code>root_is_directory</code>: Indicates if the root path itself is a directory, used by formatters.</li>
</ul>
</li>
<li><strong><code>listing: ListingOptions</code></strong> (from <code>src/config/listing.rs</code>):
<ul>
<li><code>max_depth</code>: The maximum depth of traversal.</li>
<li><code>show_hidden</code>: Whether to include hidden files/directories.</li>
<li><code>list_directories_only</code>: If <code>true</code>, only directories (including symlinks to directories) are included in the results.</li>
</ul>
</li>
<li><strong><code>filtering: FilteringOptions</code></strong> (from <code>src/config/filtering.rs</code>):
<ul>
<li><code>match_patterns</code>: <code>Option&lt;Vec&lt;String&gt;&gt;</code> containing patterns to filter entries. Only entries matching any pattern will be included. Corresponds to the CLI <code>-P</code>/<code>--filter-include</code> options.</li>
<li><code>ignore_patterns</code>: <code>Option&lt;Vec&lt;String&gt;&gt;</code> containing patterns to ignore entries. Entries matching any pattern will be excluded. Corresponds to the CLI <code>-I</code>/<code>--filter-exclude</code> options.</li>
<li><code>use_gitignore_rules</code>: If <code>true</code>, standard gitignore files (<code>.gitignore</code>, global gitignore, etc.) will be used for filtering.</li>
<li><code>gitignore_file</code>: <code>Option&lt;Vec&lt;PathBuf&gt;&gt;</code> specifying paths to custom files to be used as additional gitignore files.</li>
<li><code>case_insensitive_filter</code>: If <code>true</code>, all pattern matching (<code>match_patterns</code>, <code>ignore_patterns</code>, and gitignore processing) will be case-insensitive.</li>
<li><code>prune_empty_directories</code>: If <code>true</code>, empty directories are removed from the results after initial walking and filtering, but before sorting. An empty directory is one that contains no files and no non-empty subdirectories after other filters have been applied.</li>
</ul>
</li>
<li><strong><code>sorting: SortingOptions</code></strong> (from <code>src/config/sorting.rs</code>):
<ul>
<li><code>sort_by</code>: An optional <code>SortKey</code> (from <code>src/config/sorting.rs</code>) to sort sibling entries.</li>
<li><code>reverse_sort</code>: Whether to reverse the sort order.</li>
<li><code>files_before_directories</code>: A <code>bool</code> (default <code>true</code>) that, when sorting by size, determines if files and symlinks are grouped before directories. If <code>false</code>, types are intermingled based purely on size.</li>
</ul>
</li>
<li><strong><code>metadata: MetadataOptions</code></strong> (from <code>src/config/metadata.rs</code>):
<ul>
<li><code>show_size_bytes</code>: Whether to collect and report file sizes in bytes. Applies to directories as well.</li>
<li><code>show_last_modified</code>: Whether to collect and report last modification times (mtime).</li>
<li><code>report_change_time</code>: Whether to collect and report last status change times (ctime).</li>
<li><code>report_creation_time</code>: Whether to collect and report creation times (btime/crtime).</li>
<li><code>calculate_line_count</code>, <code>calculate_word_count</code>: Whether to perform these analyses on files.</li>
<li><code>apply_function</code>: An optional <code>BuiltInFunction</code> (from <code>src/config/metadata.rs</code>) to apply to file contents.</li>
<li><code>report_permissions</code>: (Currently not exposed via CLI, defaults to false).</li>
</ul>
</li>
<li><strong><code>misc: MiscOptions</code></strong> (from <code>src/config/misc.rs</code>):
<ul>
<li>Currently no fields, reserved for future use.</li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustree::{
    RustreeLibConfig, SortKey, BuiltInFunction,
    InputSourceOptions, ListingOptions, FilteringOptions, SortingOptions, MetadataOptions,
};
use std::path::PathBuf;

let config = RustreeLibConfig {
    input_source: InputSourceOptions {
        root_display_name: "MyProject".to_string(),
        root_node_size: None, // Typically set by the CLI handler or by checking metadata
        root_is_directory: true, // Typically set by the CLI handler or by checking metadata
        ..Default::default()
    },
    listing: ListingOptions {
        max_depth: Some(3),
        show_hidden: false,
        list_directories_only: false,
        ..Default::default()
    },
    filtering: FilteringOptions {
        match_patterns: Some(vec!["*.rs".to_string(), "src/".to_string()]), // Example -P patterns
        ignore_patterns: Some(vec!["*.log".to_string(), "target/".to_string()]), // Example -I patterns
        use_gitignore_rules: true,
        gitignore_file: Some(vec![PathBuf::from(".customignore")]),
        case_insensitive_filter: false,
        ..Default::default()
    },
    sorting: SortingOptions {
        sort_by: Some(SortKey::Size),
        reverse_sort: false, // Size sort is descending by default, so false means largest first.
        files_before_directories: true, // Default behavior
        ..Default::default()
    },
    metadata: MetadataOptions {
        show_size_bytes: true,
        show_last_modified: true,
        report_change_time: false,
        report_creation_time: false,
        calculate_line_count: false, // Example: not calculating line count
        apply_function: Some(BuiltInFunction::Cat), // Example: applying cat function to display file contents
        ..Default::default()
    },
    ..Default::default() // Use defaults for misc and other fields if not specified
};
<span class="boring">}</span></code></pre></pre>
<h3 id="nodeinfo"><a class="header" href="#nodeinfo"><code>NodeInfo</code></a></h3>
<p>Each file or directory encountered during the scan is represented by a <code>NodeInfo</code> struct (defined in <code>src/core/tree/node.rs</code>). It contains:</p>
<ul>
<li><code>path</code>: The full <code>PathBuf</code> to the entry.</li>
<li><code>name</code>: The file or directory name as a <code>String</code>.</li>
<li><code>node_type</code>: A <code>NodeType</code> enum (<code>File</code>, <code>Directory</code>, <code>Symlink</code>). When <code>listing.list_directories_only</code> is active, symlinks pointing to directories will have <code>NodeType::Directory</code>.</li>
<li><code>depth</code>: The entry's depth in the tree.</li>
<li><code>size</code>: <code>Option&lt;u64&gt;</code> for file or directory size (if <code>metadata.report_sizes</code> is enabled).</li>
<li><code>mtime</code>: <code>Option&lt;SystemTime&gt;</code> for last modification time.</li>
<li><code>change_time</code>: <code>Option&lt;SystemTime&gt;</code> for last status change time (ctime).</li>
<li><code>create_time</code>: <code>Option&lt;SystemTime&gt;</code> for creation time (btime/crtime).</li>
<li><code>line_count</code>, <code>word_count</code>: <code>Option&lt;usize&gt;</code> for analysis results (applicable to files only).</li>
<li><code>custom_function_output</code>: <code>Option&lt;Result&lt;String, ApplyFnError&gt;&gt;</code> (where <code>ApplyFnError</code> is from <code>src/config/metadata.rs</code>) for results of <code>metadata.apply_function</code>.</li>
</ul>
<p>You typically receive a <code>Vec&lt;NodeInfo&gt;</code> from <code>get_tree_nodes()</code>.</p>
<h3 id="get_tree_nodes"><a class="header" href="#get_tree_nodes"><code>get_tree_nodes()</code></a></h3>
<p>This is the primary function for generating the tree data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustree::{get_tree_nodes, RustreeLibConfig, NodeInfo, RustreeError};
use std::path::Path;

fn list_directory_contents(path_str: &amp;str, config: &amp;RustreeLibConfig) -&gt; Result&lt;Vec&lt;NodeInfo&gt;, RustreeError&gt; {
    let root_path = Path::new(path_str);
    get_tree_nodes(root_path, config)
}
<span class="boring">}</span></code></pre></pre>
<p>It takes the root path and a <code>RustreeLibConfig</code> and returns a <code>Result&lt;Vec&lt;NodeInfo&gt;, RustreeError&gt;</code>.
The processing order is:</p>
<ol>
<li>Walk the directory structure, applying initial filters (<code>match_patterns</code>, <code>ignore_patterns</code>, gitignore rules, etc.) and collecting metadata.</li>
<li>If <code>config.filtering.prune_empty_directories</code> is <code>true</code>, empty directories are pruned from the collected nodes.</li>
<li>If <code>config.listing.list_directories_only</code> is <code>true</code>, the node list is filtered to retain only directories. This happens <em>after</em> pruning, so pruning decisions are based on the full content before this filter.</li>
<li>If sorting is specified (<code>config.sorting.sort_by</code>), the remaining nodes are sorted.
The final <code>Vec&lt;NodeInfo&gt;</code> reflects these processing steps.</li>
</ol>
<h3 id="format_nodes"><a class="header" href="#format_nodes"><code>format_nodes()</code></a></h3>
<p>Once you have the <code>Vec&lt;NodeInfo&gt;</code>, you can format it into a string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustree::{format_nodes, NodeInfo, LibOutputFormat, RustreeLibConfig, RustreeError};

fn display_tree(nodes: &amp;[NodeInfo], format: LibOutputFormat, config: &amp;RustreeLibConfig) -&gt; Result&lt;String, RustreeError&gt; {
    format_nodes(nodes, format, config)
}
<span class="boring">}</span></code></pre></pre>
<p>This function takes the nodes, a <code>LibOutputFormat</code> enum (<code>Text</code> or <code>Markdown</code>, from <code>src/config/output_format.rs</code> and re-exported), and the <code>RustreeLibConfig</code> (as some config options affect formatting).</p>
<h3 id="key-enums"><a class="header" href="#key-enums">Key Enums</a></h3>
<ul>
<li><strong><code>SortKey</code></strong>: <code>Name</code>, <code>Version</code>, <code>Size</code>, <code>MTime</code>, <code>ChangeTime</code>, <code>CreateTime</code>, <code>Words</code>, <code>Lines</code>, <code>Custom</code>, <code>None</code>. Defined in <code>src/config/sorting.rs</code>. Used in <code>RustreeLibConfig.sorting.sort_by</code>.</li>
<li><strong><code>LibOutputFormat</code></strong>: <code>Text</code>, <code>Markdown</code>. Defined in <code>src/config/output_format.rs</code> (as <code>OutputFormat</code>). Used with <code>format_nodes()</code>.</li>
<li><strong><code>BuiltInFunction</code></strong>: <code>CountPluses</code> (counts '+' characters), <code>Cat</code> (returns full file content). Defined in <code>src/config/metadata.rs</code>. Used in <code>RustreeLibConfig.metadata.apply_function</code>. When using <code>Cat</code>, the <code>format_nodes()</code> function automatically displays file contents after the tree structure.</li>
<li><strong><code>ApplyFnError</code></strong>: Error type for <code>BuiltInFunction</code> application. Defined in <code>src/config/metadata.rs</code>.</li>
<li><strong><code>NodeType</code></strong>: <code>File</code>, <code>Directory</code>, <code>Symlink</code>. Defined in <code>src/core/tree/node.rs</code>. Found in <code>NodeInfo</code>.</li>
<li><strong><code>RustreeError</code></strong>: The error type returned by library functions. Defined in <code>src/core/error.rs</code>. Includes variants like <code>Io</code>, <code>GlobPattern</code>, <code>IgnoreError</code>, and <code>TreeBuildError</code> (for errors during internal tree construction or sorting).</li>
</ul>
<p>Refer to the API documentation (generated by <code>cargo doc</code>) for the full details of these types and their variants/fields.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="library-usage-examples"><a class="header" href="#library-usage-examples">Library Usage Examples</a></h2>
<p>Here are some examples of how to use <code>rustree</code> as a library in your Rust code.
Make sure to add <code>rustree</code> to your <code>Cargo.toml</code> dependencies.
All key types like <code>RustreeLibConfig</code>, <code>NodeInfo</code>, <code>SortKey</code>, <code>LibOutputFormat</code>, <code>RustreeError</code> are re-exported by <code>rustree</code>'s <code>lib.rs</code>.</p>
<h3 id="example-1-basic-tree-listing"><a class="header" href="#example-1-basic-tree-listing">Example 1: Basic Tree Listing</a></h3>
<p>This example shows how to get a simple text tree of a directory.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, RustreeError,
    InputSourceOptions, ListingOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "."; // Current directory
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: path_obj.file_name().unwrap_or_default().to_string_lossy().into_owned(),
            root_is_directory: path_obj.is_dir(), // Set based on actual path
            ..Default::default()
        },
        listing: ListingOptions {
            max_depth: Some(2), // Limit depth to 2 levels
            ..Default::default()
        },
        ..Default::default()
    };

    // 1. Get the tree nodes
    let nodes = get_tree_nodes(path_obj, &amp;config)?;

    // 2. Format the nodes into a string
    let output_string = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;

    // 3. Print the output
    println!("{}", output_string);

    Ok(())
}</code></pre></pre>
<h3 id="example-2-reporting-sizes-and-sorting"><a class="header" href="#example-2-reporting-sizes-and-sorting">Example 2: Reporting Sizes and Sorting</a></h3>
<p>This example demonstrates reporting file sizes and sorting by size in descending order.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, SortKey, RustreeError,
    InputSourceOptions, MetadataOptions, SortingOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./src";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Source Files".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        metadata: MetadataOptions {
            show_size_bytes: true,
            show_last_modified: true, // To see mtime in output if sorting by size
            ..Default::default()
        },
        sorting: SortingOptions {
            sort_by: Some(SortKey::Size),
            reverse_sort: true, // Largest files first
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    let output_string = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    println!("{}", output_string);

    Ok(())
}
</code></pre></pre>
<h3 id="example-3-using-markdown-output-and-line-counts"><a class="header" href="#example-3-using-markdown-output-and-line-counts">Example 3: Using Markdown Output and Line Counts</a></h3>
<p>This example shows how to calculate line counts and output in Markdown format.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, SortKey, RustreeError,
    InputSourceOptions, MetadataOptions, SortingOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./src";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Project Source (Markdown)".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        metadata: MetadataOptions {
            calculate_line_count: true,
            ..Default::default()
        },
        sorting: SortingOptions {
            sort_by: Some(SortKey::Lines), // Sort by line count
            reverse_sort: true,            // Most lines first
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    
    // Output as Markdown
    let markdown_output = format_nodes(&amp;nodes, LibOutputFormat::Markdown, &amp;config)?;
    println!("\n--- Markdown Output ---");
    println!("{}", markdown_output);
    // You could write this string to a .md file

    Ok(())
}</code></pre></pre>
<h3 id="example-4-using-the-cat-function-to-display-file-contents"><a class="header" href="#example-4-using-the-cat-function-to-display-file-contents">Example 4: Using the Cat Function to Display File Contents</a></h3>
<p>This example demonstrates using the <code>Cat</code> built-in function to display file contents after the tree structure.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, BuiltInFunction, RustreeError,
    InputSourceOptions, MetadataOptions, FilteringOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./config"; // Directory with configuration files
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Configuration Files".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        metadata: MetadataOptions {
            apply_function: Some(BuiltInFunction::Cat), // Display file contents
            show_size_bytes: true, // Also show file sizes
            ..Default::default()
        },
        filtering: FilteringOptions {
            // Only show text-based config files
            match_patterns: Some(vec!["*.toml".to_string(), "*.json".to_string(), "*.yaml".to_string()]),
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    
    // format_nodes will automatically display the tree first, then file contents
    let output = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    println!("{}", output);
    
    // The output will show:
    // 1. Directory tree structure with file sizes
    // 2. "--- File Contents ---" section
    // 3. Each file's content with clear headers

    Ok(())
}</code></pre></pre>
<h3 id="example-5-combining-apply-functions-with-custom-sorting"><a class="header" href="#example-5-combining-apply-functions-with-custom-sorting">Example 5: Combining Apply Functions with Custom Sorting</a></h3>
<p>This example shows how to use built-in functions and sort by their results.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, BuiltInFunction, SortKey, RustreeError,
    InputSourceOptions, MetadataOptions, SortingOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./text_files";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Text Analysis".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        metadata: MetadataOptions {
            apply_function: Some(BuiltInFunction::CountPluses), // Count '+' characters
            calculate_line_count: true,
            calculate_word_count: true,
            ..Default::default()
        },
        sorting: SortingOptions {
            sort_by: Some(SortKey::Custom), // Sort by the apply_function result
            reverse_sort: true, // Files with most '+' characters first
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    let output = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    println!("{}", output);

    Ok(())
}</code></pre></pre>
<h3 id="example-6-directory-analysis-with-built-in-functions"><a class="header" href="#example-6-directory-analysis-with-built-in-functions">Example 6: Directory Analysis with Built-in Functions</a></h3>
<p>This example demonstrates using directory functions to analyze project structure.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, BuiltInFunction, SortKey, RustreeError,
    InputSourceOptions, MetadataOptions, SortingOptions, ListingOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./my_project";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Project Analysis".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        listing: ListingOptions {
            list_directories_only: true, // Only show directories
            ..Default::default()
        },
        metadata: MetadataOptions {
            apply_function: Some(BuiltInFunction::DirStats), // Get comprehensive directory stats
            show_size_bytes: true, // Required for size calculations
            ..Default::default()
        },
        sorting: SortingOptions {
            sort_by: Some(SortKey::Custom), // Sort by directory stats (complexity)
            reverse_sort: true, // Most complex directories first
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    let output = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    println!("{}", output);
    
    // Output will show directories with stats like [F: "15f,3d,52KB"]
    // meaning 15 files, 3 subdirectories, 52KB total size

    Ok(())
}</code></pre></pre>
<h3 id="example-7-selective-function-application-with-filtering"><a class="header" href="#example-7-selective-function-application-with-filtering">Example 7: Selective Function Application with Filtering</a></h3>
<p>This example shows how to apply functions only to specific files or directories using patterns.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, BuiltInFunction, RustreeError,
    InputSourceOptions, MetadataOptions, FilteringOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./workspace";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Workspace Analysis".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        metadata: MetadataOptions {
            apply_function: Some(BuiltInFunction::CountFiles), // Count files in directories
            show_size_bytes: true,
            ..Default::default()
        },
        filtering: FilteringOptions {
            // Apply function only to source directories, exclude build artifacts
            apply_include_patterns: Some(vec!["src*".to_string(), "lib*".to_string()]),
            apply_exclude_patterns: Some(vec!["*target*".to_string(), "*build*".to_string()]),
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    let output = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    println!("{}", output);

    Ok(())
}</code></pre></pre>
<h3 id="example-8-file-content-analysis-with-filtering"><a class="header" href="#example-8-file-content-analysis-with-filtering">Example 8: File Content Analysis with Filtering</a></h3>
<p>This example demonstrates using the cat function with selective application for code review.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, BuiltInFunction, RustreeError,
    InputSourceOptions, MetadataOptions, FilteringOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./src";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Code Review".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        metadata: MetadataOptions {
            apply_function: Some(BuiltInFunction::Cat), // Show file contents
            calculate_line_count: true,
            ..Default::default()
        },
        filtering: FilteringOptions {
            // Only show Rust files and exclude test files
            match_patterns: Some(vec!["*.rs".to_string()]),
            apply_exclude_patterns: Some(vec!["*test*".to_string(), "*tests*".to_string()]),
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    let output = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    println!("{}", output);
    
    // This will show:
    // 1. Tree structure of all .rs files
    // 2. File contents for non-test .rs files only

    Ok(())
}</code></pre></pre>
<h3 id="example-9-working-with-nodeinfo-directly"><a class="header" href="#example-9-working-with-nodeinfo-directly">Example 9: Working with NodeInfo Directly</a></h3>
<p>This example shows how to work with the raw <code>NodeInfo</code> data for custom processing.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, RustreeLibConfig, BuiltInFunction, RustreeError,
    InputSourceOptions, MetadataOptions, NodeType,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./project";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        metadata: MetadataOptions {
            apply_function: Some(BuiltInFunction::CountFiles),
            show_size_bytes: true,
            calculate_line_count: true,
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;

    // Custom analysis of the nodes
    for node in &amp;nodes {
        match node.node_type {
            NodeType::Directory =&gt; {
                if let Some(Ok(file_count)) = &amp;node.custom_function_output {
                    println!("Directory '{}' contains {} files", node.name, file_count);
                }
            }
            NodeType::File =&gt; {
                if let Some(lines) = node.line_count {
                    println!("File '{}' has {} lines", node.name, lines);
                }
                if let Some(size) = node.size {
                    println!("File '{}' is {} bytes", node.name, size);
                }
            }
            _ =&gt; {}
        }
    }

    Ok(())
}</code></pre></pre>
<p>These examples should give you a good starting point for integrating <code>rustree</code> into your applications. Remember to handle the <code>Result</code> types appropriately in production code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This section provides an overview of RusTree's internal architecture.</p>
<p>Understanding the architecture can be helpful if you plan to contribute to RusTree or want a deeper understanding of how it works.</p>
<h2 id="sub-sections-2"><a class="header" href="#sub-sections-2">Sub-sections:</a></h2>
<ul>
<li><a href="./architecture/overview.html">Overview</a>: A high-level look at the components and data flow.</li>
<li><a href="./architecture/modules.html">Core Modules</a>: Details about the main modules within the <code>rustree</code> library.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="architectural-overview"><a class="header" href="#architectural-overview">Architectural Overview</a></h2>
<p>RusTree is designed with a modular approach, separating concerns into different components. The primary data flow for the library is as follows:</p>
<ol>
<li>
<p><strong>Configuration (<code>RustreeLibConfig</code> from <code>src/config/tree_options.rs</code>)</strong>: The process starts with a configuration object that dictates how the tree traversal, analysis, and formatting should occur. <code>RustreeLibConfig</code> is composed of sub-structs like <code>ListingOptions</code>, <code>FilteringOptions</code> (including <code>prune_empty_directories</code>), <code>MetadataOptions</code> (controlling reporting of mtime, ctime, crtime, etc.), and <code>SortingOptions</code> (specifying sort keys like <code>Name</code>, <code>Version</code>, <code>MTime</code>, <code>ChangeTime</code>, <code>CreateTime</code>, <code>None</code>, and behaviors like <code>files_before_directories</code>).</p>
</li>
<li>
<p><strong>Walking (<code>core::walker</code>)</strong>:</p>
<ul>
<li>The <code>walk_directory</code> function (in <code>core::walker::filesystem</code>) uses the <code>ignore</code> crate to traverse the file system.</li>
<li>It respects configuration settings from <code>RustreeLibConfig</code>:
<ul>
<li><code>config.listing.max_depth</code>, <code>config.listing.show_hidden</code>.</li>
<li><code>config.filtering.use_gitignore_rules</code> and <code>config.filtering.gitignore_file</code> for gitignore rules (handled by the <code>ignore</code> crate).</li>
<li><code>config.filtering.ignore_patterns</code> (CLI <code>-I</code>) are compiled by <code>core::filter::pattern</code> and used by the <code>ignore</code> crate's <code>WalkBuilder::filter_entry()</code> to prune the walk.</li>
<li><code>config.filtering.case_insensitive_filter</code> controls case sensitivity for all pattern matching.</li>
</ul>
</li>
<li>After the <code>ignore</code> crate yields an entry, further filtering is applied by the walker using <code>core::filter::pattern::entry_matches_glob_patterns</code>:
<ul>
<li><code>config.filtering.match_patterns</code> (CLI <code>-P</code>): Files and symlinks must match these patterns. Directories are generally kept if they might contain matching children.</li>
</ul>
</li>
<li>For each qualifying entry, it gathers initial metadata (mtime, ctime, crtime based on <code>config.metadata</code> and platform capabilities). Symlinks are resolved. The <code>list_directories_only</code> filter is NOT applied at this stage.</li>
</ul>
</li>
<li>
<p><strong>Metadata Collection &amp; Analysis (<code>core::metadata</code>)</strong>:</p>
<ul>
<li>As the walker processes entries, it invokes functions from <code>core::metadata</code> based on <code>config.metadata</code>.</li>
<li><code>core::metadata::size_calculator</code>: Calculates line counts and word counts for files.</li>
<li><code>core::metadata::file_info</code>: Applies built-in functions (from <code>config::metadata::BuiltInFunction</code>) to file content using <code>apply_builtin_to_file</code>.</li>
<li>The results are stored in <code>NodeInfo</code> objects (defined in <code>core::tree::node</code>). This step is skipped for directories for file-specific analyses.</li>
</ul>
</li>
<li>
<p><strong>Node Representation (<code>NodeInfo</code> from <code>core::tree::node</code>)</strong>:</p>
<ul>
<li>Each qualifying file system entry is represented by a <code>NodeInfo</code> struct. This struct holds its path, name, effective <code>node_type</code>, depth, metadata (size, mtime, change_time, create_time), and any analysis results.</li>
<li>The walker produces a <code>Vec&lt;NodeInfo&gt;</code>.</li>
</ul>
</li>
<li>
<p><strong>Pruning (<code>lib.rs</code>, using <code>core::tree::manipulator</code>)</strong>:</p>
<ul>
<li>If <code>config.filtering.prune_empty_directories</code> is <code>true</code>, the <code>Vec&lt;NodeInfo&gt;</code> is processed to remove empty directories.</li>
<li>This involves building a temporary tree, pruning nodes where a directory contains no files and no non-empty subdirectories, and then flattening the tree back.</li>
<li>This step occurs <em>after</em> all initial walking and filtering, but <em>before</em> the <code>list_directories_only</code> filter and sorting.</li>
</ul>
</li>
<li>
<p><strong><code>list_directories_only</code> Filtering (<code>lib.rs</code>)</strong>:</p>
<ul>
<li>If <code>config.listing.list_directories_only</code> is <code>true</code>, the <code>Vec&lt;NodeInfo&gt;</code> (potentially already pruned) is further filtered to retain only entries with <code>NodeType::Directory</code>.</li>
<li>This ensures that pruning decisions are made based on the full content of directories before they are potentially removed by this filter.</li>
</ul>
</li>
<li>
<p><strong>Sorting (<code>core::sorter</code>)</strong>:</p>
<ul>
<li>If <code>config.sorting.sort_by</code> specifies a <code>SortKey</code>, the <code>sort_nodes_with_options</code> function (in <code>core::sorter::strategies</code>) sorts the (potentially pruned and filtered) <code>Vec&lt;NodeInfo&gt;</code>.</li>
<li>Sorting involves building a temporary tree, sorting sibling nodes at each level using comparison logic from <code>core::sorter::comparators</code> (which respects <code>config.sorting.reverse_sort</code> and <code>config.sorting.files_before_directories</code>), and then flattening the tree back.</li>
<li>Default size sorting is now largest first, with files/symlinks grouped before directories. Version sorting is more intelligent. If <code>SortKey::None</code> is used, directory traversal order is preserved.</li>
</ul>
</li>
<li>
<p><strong>Formatting (<code>core::formatter</code>)</strong>:</p>
<ul>
<li>The processed (sorted or unsorted) <code>Vec&lt;NodeInfo&gt;</code> is passed to a formatter.</li>
<li>The <code>TreeFormatter</code> trait defines the interface. Formatters use <code>core::metadata::file_info::format_node_metadata</code> for consistent metadata display.</li>
<li><code>TextTreeFormatter</code>: Generates plain text, <code>tree</code>-like output.</li>
<li><code>MarkdownFormatter</code>: Generates a Markdown list.</li>
<li>The formatter produces the final string output, considering configuration like <code>config.input_source.root_display_name</code>. The choice of formatter is determined by <code>LibOutputFormat</code> (from <code>config::output_format</code>).</li>
</ul>
</li>
</ol>
<h3 id="cli-layer"><a class="header" href="#cli-layer">CLI Layer</a></h3>
<p>The command-line interface (<code>src/cli/</code>) acts as a wrapper around the core library:</p>
<ul>
<li><strong>Argument Parsing (<code>cli::args</code>)</strong>: Uses <code>clap</code> to parse arguments.</li>
<li><strong>Mapping (<code>cli::mapping</code>)</strong>: The <code>map_cli_to_lib_config</code> function translates <code>CliArgs</code> into <code>RustreeLibConfig</code> (e.g., setting <code>sorting.sort_by</code>, <code>sorting.files_before_directories</code>, <code>metadata.show_last_modified</code>).</li>
<li><strong>Orchestration (<code>main.rs</code>)</strong>:
<ol>
<li>Parses CLI args.</li>
<li>Maps CLI args to library config.</li>
<li>Calls <code>rustree::get_tree_nodes()</code>.</li>
<li>Calls <code>rustree::format_nodes()</code>.</li>
<li>Prints the output.</li>
</ol>
</li>
</ul>
<p>This separation allows the core library to be used independently.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="core-library-modules"><a class="header" href="#core-library-modules">Core Library Modules</a></h2>
<p>The <code>rustree</code> library is organized into several modules, each with a specific responsibility. The <code>src/core/</code> directory, in particular, has been significantly refactored into sub-modules for better organization and clarity.</p>
<h3 id="srcconfig---configuration-module"><a class="header" href="#srcconfig---configuration-module"><code>src/config/</code> - Configuration Module</a></h3>
<p>This top-level module centralizes all configuration-related definitions for the library. It groups related options into sub-modules and specific structs.</p>
<ul>
<li>
<p><strong><code>tree_options.rs</code></strong>:</p>
<ul>
<li>Defines <code>RustreeLibConfig</code>, the main configuration struct. It is composed of several sub-structs:
<ul>
<li><code>InputSourceOptions</code> (from <code>input_source.rs</code>): Options related to the root input, like display name and initial metadata.</li>
<li><code>ListingOptions</code> (from <code>listing.rs</code>): Options controlling directory traversal, such as <code>max_depth</code>, <code>show_hidden</code>, and <code>list_directories_only</code>.</li>
<li><code>FilteringOptions</code> (from <code>filtering.rs</code>): Options for including/excluding files/directories, such as <code>match_patterns</code>, <code>ignore_patterns</code>, <code>use_gitignore_rules</code>, <code>gitignore_file</code>, and <code>case_insensitive_filter</code>.</li>
<li><code>SortingOptions</code> (from <code>sorting.rs</code>): Options for sorting, including <code>sort_by</code> (using <code>SortKey</code>), <code>reverse_sort</code>, and <code>files_before_directories</code>.</li>
<li><code>MetadataOptions</code> (from <code>metadata.rs</code>): Options for collecting and reporting metadata, like <code>show_size_bytes</code>, <code>show_last_modified</code>, <code>calculate_line_count</code>, <code>calculate_word_count</code>, and <code>apply_function</code> (using <code>BuiltInFunction</code>).</li>
<li><code>MiscOptions</code> (from <code>misc.rs</code>): For miscellaneous options.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>input_source.rs</code></strong>:</p>
<ul>
<li>Defines <code>InputSourceOptions</code> struct for root path display and initial metadata.</li>
</ul>
</li>
<li>
<p><strong><code>listing.rs</code></strong>:</p>
<ul>
<li>Defines <code>ListingOptions</code> struct for directory traversal settings.</li>
</ul>
</li>
<li>
<p><strong><code>filtering.rs</code></strong>:</p>
<ul>
<li>Defines <code>FilteringOptions</code> struct for inclusion/exclusion patterns, gitignore settings, and the <code>prune_empty_directories</code> flag.</li>
</ul>
</li>
<li>
<p><strong><code>sorting.rs</code></strong>:</p>
<ul>
<li>Defines the <code>SortKey</code> enum (e.g., <code>Name</code>, <code>Size</code>, <code>MTime</code>, <code>Version</code>, <code>ChangeTime</code>, <code>CreateTime</code>, <code>None</code>).</li>
<li>Defines <code>DirectoryFileOrder</code> enum to control directory vs. file ordering (<code>Default</code>, <code>DirsFirst</code>, <code>FilesFirst</code>).</li>
<li>Defines <code>SortingOptions</code> struct, used in <code>RustreeLibConfig</code> to specify sorting criteria, order, directory/file ordering preference, and backward compatibility options.</li>
</ul>
</li>
<li>
<p><strong><code>metadata.rs</code></strong>:</p>
<ul>
<li>Defines <code>MetadataOptions</code> struct for metadata collection and content analysis flags (e.g., <code>show_size_bytes</code>, <code>show_last_modified</code>, <code>report_change_time</code>, <code>report_creation_time</code>).</li>
<li>Defines <code>BuiltInFunction</code> enum for functions applicable to file content, including <code>CountPluses</code> (counts '+' characters) and <code>Cat</code> (returns full file content).</li>
<li>Defines <code>ApplyFnError</code> for errors during custom function application.</li>
</ul>
</li>
<li>
<p><strong><code>output_format.rs</code></strong> (formerly <code>output.rs</code>):</p>
<ul>
<li>Defines the <code>OutputFormat</code> enum (re-exported as <code>LibOutputFormat</code>), used to specify the desired output format (e.g., Text, Markdown).</li>
</ul>
</li>
<li>
<p><strong><code>misc.rs</code></strong>:</p>
<ul>
<li>Defines <code>MiscOptions</code> struct for any other configuration options.</li>
</ul>
</li>
</ul>
<h3 id="srccore---core-logic-modules"><a class="header" href="#srccore---core-logic-modules"><code>src/core/</code> - Core Logic Modules</a></h3>
<p>The <code>src/core/</code> directory houses the main operational logic of <code>rustree</code>.</p>
<ul>
<li>
<p><strong><code>tree/</code></strong>: This sub-module manages the tree data structure itself.</p>
<ul>
<li><code>node.rs</code>: Defines <code>NodeInfo</code>, the struct representing a single file system entry (file, directory, symlink) and its collected data (including <code>path</code>, <code>name</code>, <code>node_type</code>, <code>depth</code>, <code>size</code>, <code>mtime</code>, <code>change_time</code>, <code>create_time</code>, analysis results). Defines <code>NodeType</code>, an enum for the type of file system entry.</li>
<li><code>builder.rs</code>: Contains logic for constructing a <code>Vec&lt;TempNode&gt;</code> (a temporary tree structure) from a flat <code>Vec&lt;NodeInfo&gt;</code> and for flattening it back. This is primarily used by the sorter.</li>
<li><code>manipulator.rs</code>: Provides utilities for modifying tree structures, such as pruning, filtering, and transforming nodes.</li>
<li><code>traversal.rs</code>: Implements various tree traversal algorithms (DFS pre-order, post-order, BFS) and a <code>TreeVisitor</code> trait for custom operations during traversal.</li>
</ul>
</li>
<li>
<p><strong><code>walker/</code></strong>: This sub-module is responsible for traversing the file system.</p>
<ul>
<li><code>filesystem.rs</code>: Contains the <code>walk_directory</code> function. It uses the <code>ignore</code> crate (<code>ignore::WalkBuilder</code>) for directory walking. It implements initial filtering logic based on <code>RustreeLibConfig</code> (hidden files, max depth, gitignore rules, ignore patterns). After the <code>ignore</code> crate yields an entry, it applies further filtering (match patterns). The <code>list_directories_only</code> filter is applied later in <code>lib.rs</code> after potential pruning. It handles symlink resolution and populates <code>NodeInfo</code> structs with basic metadata, triggering content analysis via the <code>metadata</code> module.</li>
<li><code>depth_control.rs</code>: (Placeholder for future depth-specific control logic).</li>
<li><code>input_source.rs</code>: (Placeholder for future advanced input source handling).</li>
<li><code>symlinks.rs</code>: (Placeholder for future advanced symlink resolution strategies).</li>
</ul>
</li>
<li>
<p><strong><code>filter/</code></strong>: This sub-module handles all filtering logic beyond what the <code>ignore</code> crate provides directly during its walk.</p>
<ul>
<li><code>pattern.rs</code>: Contains <code>compile_glob_patterns</code> to prepare glob patterns from <code>FilteringOptions</code> and <code>entry_matches_glob_patterns</code> to check if a <code>DirEntry</code> matches these compiled patterns. This is used by the <code>walker</code> after the <code>ignore</code> crate's initial pass.</li>
<li><code>gitignore.rs</code>: (Placeholder for future gitignore-specific filtering utilities, complementing the <code>ignore</code> crate's built-in support).</li>
<li><code>composite.rs</code>: (Placeholder for combining multiple filter criteria).</li>
<li><code>matcher.rs</code>: (Placeholder for generic matching logic).</li>
<li><code>size_filter.rs</code>: (Placeholder for size-based filtering).</li>
</ul>
</li>
<li>
<p><strong><code>metadata/</code></strong>: This sub-module handles metadata collection, calculation, and content analysis.</p>
<ul>
<li><code>file_info.rs</code>:
<ul>
<li>Defines <code>format_node_metadata</code> for consistently formatting metadata strings for display (used by formatters). For the <code>Cat</code> function, metadata display is suppressed since content is shown separately.</li>
<li>Contains <code>apply_builtin_to_file</code> and <code>apply_builtin_function</code> for applying <code>BuiltInFunction</code>s to file content, handling <code>ApplyFnError</code>. The <code>Cat</code> function simply returns the full file content.</li>
</ul>
</li>
<li><code>size_calculator.rs</code>: Provides functions like <code>count_lines_from_string</code> and <code>count_words_from_string</code>.</li>
<li><code>time_formatter.rs</code>: (Placeholder for advanced time formatting utilities).</li>
<li><code>extended_attrs.rs</code>: (Placeholder for reading extended file attributes).</li>
</ul>
</li>
<li>
<p><strong><code>sorter/</code></strong>: This sub-module is responsible for sorting nodes while preserving the tree hierarchy.</p>
<ul>
<li><code>strategies.rs</code>: Contains <code>sort_nodes_with_options</code> (and the older <code>sort_nodes</code>), which orchestrates tree building, sorting of sibling nodes, and tree flattening.</li>
<li><code>comparators.rs</code>: Defines <code>compare_siblings_with_options</code> which implements the comparison logic for various <code>SortKey</code>s, considering <code>SortingOptions</code> like <code>reverse_sort</code>, <code>files_before_directories</code> (legacy), and the new <code>directory_file_order</code> enum. It includes universal directory/file ordering that applies to all sort keys, improved version string comparison, and enhanced size sorting logic. The <code>apply_directory_file_ordering</code> function provides consistent directory vs. file ordering across all sorting modes.</li>
<li><code>composite.rs</code>: (Placeholder for defining and using composite sort keys).</li>
</ul>
</li>
<li>
<p><strong><code>formatter/</code></strong>: This sub-module is responsible for generating the final output string.</p>
<ul>
<li><code>base.rs</code>: Defines the <code>TreeFormatter</code> trait, which all specific formatters implement.</li>
<li><code>text_tree.rs</code>: Implements <code>TextTreeFormatter</code> for the classic <code>tree</code>-like text output. It uses <code>core::metadata::file_info::format_node_metadata</code> for consistent metadata display.</li>
<li><code>markdown.rs</code>: Implements <code>MarkdownFormatter</code> for generating Markdown lists. It also uses <code>core::metadata::file_info::format_node_metadata</code>.</li>
<li><code>mod.rs</code> (in <code>formatter</code>): Re-exports <code>OutputFormat</code> (as <code>LibOutputFormat</code>) from <code>src/config/output_format.rs</code>.</li>
</ul>
</li>
<li>
<p><strong><code>util.rs</code></strong>: Contains general utility functions like <code>is_hidden</code>, <code>format_size</code>, <code>truncate_string</code>.</p>
</li>
<li>
<p><strong><code>error.rs</code></strong>:</p>
<ul>
<li>Defines <code>RustreeError</code>, the common error type used throughout the library. This includes variants for I/O errors, glob pattern errors, errors from the <code>ignore</code> crate (<code>IgnoreError</code>), and <code>TreeBuildError</code> (for errors during internal tree construction for sorting or pruning).</li>
</ul>
</li>
</ul>
<h3 id="top-level-library-file-srclibrs"><a class="header" href="#top-level-library-file-srclibrs">Top-Level Library File (<code>src/lib.rs</code>)</a></h3>
<ul>
<li>
<p>Re-exports key public types from the <code>config</code> and <code>core</code> modules to form the library's public API. This includes:</p>
<ul>
<li><code>RustreeLibConfig</code> and its constituent option structs: <code>InputSourceOptions</code>, <code>ListingOptions</code>, <code>FilteringOptions</code>, <code>SortingOptions</code> (including <code>directory_file_order</code> and legacy <code>files_before_directories</code>), <code>MetadataOptions</code>, <code>MiscOptions</code>.</li>
<li>Enums and related types: <code>SortKey</code>, <code>DirectoryFileOrder</code>, <code>BuiltInFunction</code>, <code>ApplyFnError</code>.</li>
<li><code>LibOutputFormat</code> (an alias for <code>OutputFormat</code>).</li>
</ul>
</li>
<li>
<p>Core types: <code>NodeInfo</code> (from <code>core::tree::node</code>), <code>NodeType</code>, and <code>RustreeError</code>.</p>
</li>
<li>
<p>The <code>cli</code> module, while part of the crate, is marked <code>#[doc(hidden)]</code> and is not part of the stable public API.</p>
</li>
<li>
<p>Provides the main entry-point functions:</p>
<ul>
<li><code>get_tree_nodes()</code>: Orchestrates the main logic:
<ol>
<li>Walking the file system (via <code>core::walker</code>), applying initial filters and collecting metadata.</li>
<li>If <code>config.filtering.prune_empty_directories</code> is true, prunes empty directories from the results (using <code>core::tree::manipulator</code> and <code>core::tree::builder</code>).</li>
<li>If <code>config.listing.list_directories_only</code> is true, filters the results to include only directories. This occurs <em>after</em> pruning.</li>
<li>If sorting is requested, sorts the nodes (via <code>core::sorter::strategies::sort_nodes_with_options</code>). Errors during sorting or tree building for pruning now map to <code>RustreeError::TreeBuildError</code>.</li>
</ol>
</li>
<li><code>format_nodes()</code>: Takes the processed nodes and applies the chosen formatter. For the <code>Cat</code> function, it first generates the normal tree output, then appends a "--- File Contents ---" section with the content of each file.</li>
</ul>
</li>
</ul>
<p>This modular structure aims to make the codebase maintainable and extensible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-rustdoc"><a class="header" href="#api-reference-rustdoc">API Reference (rustdoc)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Contributions to RusTree are welcome! Whether it's bug reports, feature requests, documentation improvements, or code contributions, your help is appreciated.</p>
<h2 id="ways-to-contribute"><a class="header" href="#ways-to-contribute">Ways to Contribute</a></h2>
<ul>
<li><strong>Reporting Bugs:</strong> If you find a bug, please open an issue on the GitHub repository. Include steps to reproduce, expected behavior, and actual behavior.</li>
<li><strong>Suggesting Enhancements:</strong> Have an idea for a new feature or an improvement to an existing one? Open an issue to discuss it.</li>
<li><strong>Improving Documentation:</strong> If you find parts of the documentation unclear or missing, feel free to suggest changes or submit a pull request.</li>
<li><strong>Writing Code:</strong> If you'd like to contribute code, please follow the guidelines below.</li>
</ul>
<h2 id="code-contributions"><a class="header" href="#code-contributions">Code Contributions</a></h2>
<ol>
<li><strong>Fork the Repository:</strong> Start by forking the official RusTree repository on GitHub.</li>
<li><strong>Clone Your Fork:</strong> Clone your forked repository to your local machine.
<pre><code class="language-bash">git clone https://github.com/your-username/rustree.git
cd rustree
</code></pre>
</li>
<li><strong>Create a Branch:</strong> Create a new branch for your feature or bug fix.
<pre><code class="language-bash">git checkout -b my-new-feature
</code></pre>
</li>
<li><strong>Make Changes:</strong> Implement your changes.
<ul>
<li>Follow the existing code style. Consider using <code>rustfmt</code> to format your code (<code>cargo fmt</code>).</li>
<li>Add tests for any new functionality or bug fixes.</li>
<li>Ensure all tests pass (<code>cargo test</code>).</li>
<li>Update documentation (both <code>rustdoc</code> comments and <code>mdBook</code> if applicable).</li>
</ul>
</li>
<li><strong>Commit Your Changes:</strong> Commit your changes with a clear and descriptive commit message.
<pre><code class="language-bash">git commit -am "Add some feature"
</code></pre>
</li>
<li><strong>Push to Your Fork:</strong> Push your changes to your forked repository.
<pre><code class="language-bash">git push origin my-new-feature
</code></pre>
</li>
<li><strong>Submit a Pull Request:</strong> Open a pull request from your branch on your fork to the <code>main</code> branch of the official RusTree repository.
<ul>
<li>Provide a clear title and description for your pull request.</li>
<li>Reference any related issues.</li>
</ul>
</li>
</ol>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<ul>
<li>Ensure you have Rust installed (see <a href="https://rustup.rs/">rustup.rs</a>).</li>
<li>To build the project: <code>cargo build</code></li>
<li>To run tests: <code>cargo test</code></li>
<li>To format code: <code>cargo fmt</code></li>
<li>To run linters (clippy): <code>cargo clippy</code></li>
<li>To run benchmarks: <code>cargo bench</code></li>
<li>To build and view <code>rustdoc</code> API documentation: <code>cargo doc --open</code></li>
<li>To build and view <code>mdBook</code> documentation (from the project root):
<pre><code class="language-bash"># Install mdbook if you haven't already: cargo install mdbook
mdbook serve docs
</code></pre>
</li>
</ul>
<p>Thank you for considering contributing to RusTree!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions-faq"><a class="header" href="#frequently-asked-questions-faq">Frequently Asked Questions (FAQ)</a></h1>
<p><strong>Q: How do I ignore files and directories?</strong>
A: RusTree offers several ways:</p>
<ul>
<li><strong><code>-I &lt;PATTERN&gt;</code> or <code>--filter-exclude &lt;PATTERN&gt;</code></strong>: Exclude files/directories matching the glob pattern. This can be used multiple times.</li>
<li><strong><code>--use-gitignore-rules</code> (alias: <code>--gitignore</code>)</strong>: This flag tells RusTree to respect standard gitignore behavior. It will look for <code>.gitignore</code> files in the current directory and parent directories, as well as global gitignore configurations (e.g., <code>~/.config/git/ignore</code> or <code>$XDG_CONFIG_HOME/git/ignore</code>) and repository-specific exclude files (e.g., <code>.git/info/exclude</code>). Note: <code>--gitignore</code> is a deprecated alias.</li>
<li><strong><code>--gitignore-file &lt;FILE&gt;</code></strong>: This option lets you specify one or more custom files that contain gitignore-style patterns. These patterns are applied as if the file was located at the root of the scan.</li>
<li><strong><code>--case-insensitive-filter</code></strong>: This flag makes all pattern matching (from <code>-P</code>/<code>--filter-include</code>, <code>-I</code>/<code>--filter-exclude</code>, <code>--use-gitignore-rules</code>, and <code>--gitignore-file</code>) case-insensitive.</li>
</ul>
<p>These options can be combined. For example, you can use <code>--use-gitignore-rules</code> and also add specific <code>-I</code> patterns.</p>
<p><strong>Q: How does the <code>-P</code> (or <code>--filter-include</code>) pattern matching work?</strong>
A: The <code>-P &lt;PATTERN&gt;</code> or <code>--filter-include &lt;PATTERN&gt;</code> option allows you to specify wildcard patterns to list only matching files and directories.</p>
<ul>
<li>Wildcard patterns supported:
<ul>
<li><code>*</code>: any zero or more characters.</li>
<li><code>?</code>: any single character.</li>
<li><code>[...]</code>: any single character listed (e.g., <code>[abc]</code>, <code>[a-z]</code>).</li>
<li><code>[!...]</code>: any single character not listed.</li>
<li><code>|</code>: separates alternate patterns within a single pattern string (e.g., <code>*.txt|*.log</code>).</li>
</ul>
</li>
<li>A <code>/</code> at the end of a pattern (e.g., <code>mydir/</code>) specifically matches directories.</li>
<li>Note: To match hidden files (starting with <code>.</code>) with patterns like <code>*</code>, you must also use the <code>-a</code> or <code>--include-hidden</code> option. If <code>-a</code> is not used, <code>*</code> will not match hidden entries. Patterns explicitly starting with <code>.</code> (e.g., <code>.*</code>) will match hidden files regardless of <code>-a</code>.</li>
<li>The matching can be made case-insensitive using the <code>--case-insensitive-filter</code> flag.</li>
</ul>
<p><strong>Q: How does <code>--case-insensitive-filter</code> work?</strong>
A: The <code>--case-insensitive-filter</code> flag makes all pattern matching operations case-insensitive. This applies to:</p>
<ul>
<li>Patterns specified with <code>-P &lt;PATTERN&gt;</code> or <code>--filter-include &lt;PATTERN&gt;</code>.</li>
<li>Patterns specified with <code>-I &lt;PATTERN&gt;</code> or <code>--filter-exclude &lt;PATTERN&gt;</code>.</li>
<li>Patterns found in <code>.gitignore</code> files when <code>--use-gitignore-rules</code> (or its alias <code>--gitignore</code>) is active.</li>
<li>Patterns found in custom ignore files specified with <code>--gitignore-file</code>.</li>
</ul>
<p>For example, if <code>--case-insensitive-filter</code> is used, a pattern like <code>-P "*.JPG"</code> would match <code>image.jpg</code>, <code>image.JPG</code>, and <code>image.Jpg</code>. Similarly, an ignore pattern like <code>-I "README.MD"</code> would ignore <code>readme.md</code>.</p>
<p><strong>Q: If I use <code>-d</code> with <code>-s</code> (show size in bytes), will it show directory sizes?</strong>
A: Yes. When <code>-d</code> (or <code>--directory-only</code>) and <code>-s</code> (or <code>--show-size-bytes</code>) are used together, RusTree will report the sizes of the directories themselves (as reported by the operating system, which might vary in meaning, e.g., size of metadata vs. total content size on some systems).</p>
<p>Similarly, if <code>-D</code> (or <code>--show-last-modified</code>) is used with <code>-d</code>, it will show the relevant date (modification or change time, depending on whether <code>-c</code> is also active) for the directories.</p>
<p><strong>Q: How does the <code>-D</code> (or <code>--show-last-modified</code>) flag interact with <code>-c</code> (sort by change time)?</strong>
A:</p>
<ul>
<li>If you use <code>-D</code> (or <code>--show-last-modified</code>) alone, it displays the last modification time (mtime).</li>
<li>If you use <code>-c</code> alone, it sorts by change time (ctime), but <code>-D</code> (or <code>--show-last-modified</code>) is needed to <em>display</em> a time.</li>
<li>If you use both <code>-D</code> (or <code>--show-last-modified</code>) and <code>-c</code> (or <code>-D</code> and <code>--sort-by ctime</code>), then <code>-D</code> (or <code>--show-last-modified</code>) will display the last status change time (ctime) instead of the modification time. This allows you to see the ctime for entries when sorting by ctime.</li>
</ul>
<p><strong>Q: What are apply functions and how do they work?</strong>
A: Apply functions let you analyze and process file or directory contents. They come in two types:</p>
<ul>
<li><strong>File functions</strong> work on file content:
<ul>
<li><code>count-pluses</code>: Counts '+' characters in each file</li>
<li><code>cat</code>: Displays file contents after the tree structure</li>
</ul>
</li>
<li><strong>Directory functions</strong> work on directory children:
<ul>
<li><code>count-files</code>: Counts files in each directory</li>
<li><code>count-dirs</code>: Counts subdirectories in each directory</li>
<li><code>size-total</code>: Calculates total size of files in each directory</li>
<li><code>dir-stats</code>: Shows combined statistics (files, dirs, total size)</li>
</ul>
</li>
</ul>
<p>Use <code>--apply-function &lt;FUNCTION_NAME&gt;</code> to enable a function. The results appear in metadata like <code>[F: "5"]</code> or after the tree (for <code>cat</code>).</p>
<p><strong>Q: Can I apply functions only to specific files or directories?</strong>
A: Yes! Use apply-function filtering:</p>
<ul>
<li><code>--apply-include &lt;PATTERN&gt;</code>: Apply function only to matching files/directories</li>
<li><code>--apply-exclude &lt;PATTERN&gt;</code>: Don't apply function to matching files/directories</li>
<li><code>--apply-include-from &lt;FILE&gt;</code>: Read include patterns from a file</li>
<li><code>--apply-exclude-from &lt;FILE&gt;</code>: Read exclude patterns from a file</li>
</ul>
<p>These use the same wildcard syntax as <code>--filter-include</code> and can be combined. Pattern files support comments (lines starting with <code>#</code>) and ignore empty lines.</p>
<p><strong>Q: Why do I get <code>[F: "0"]</code> for all directories when using <code>size-total</code>?</strong>
A: The <code>size-total</code> function requires file size information to work. Make sure to use <code>--show-size-bytes</code> (or <code>-s</code>) along with <code>--apply-function size-total</code>. Without this flag, file sizes aren't collected and the total will always be 0.</p>
<p><strong>Q: How do apply functions work with sorting?</strong>
A: You can sort by apply function results using <code>--sort-by custom</code>. This sorts by the function output:</p>
<ul>
<li>Numeric results (like counts) are sorted numerically</li>
<li>String results are sorted lexicographically</li>
<li>Use <code>--reverse-sort</code> to reverse the order</li>
</ul>
<p>For example: <code>rustree --apply-function dir-stats --sort-by custom -r</code> sorts directories by complexity (most files/subdirs first).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
