<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RusTree Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RusTree Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/pallavbakshi/rusTree" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-rustree"><a class="header" href="#introduction-to-rustree">Introduction to RusTree</a></h1>
<p>Welcome to RusTree!</p>
<p>RusTree is a command-line tool and Rust library designed to display directory structures in a tree-like format, similar to the classic <code>tree</code> command, but with enhanced features for analysis and output customization.</p>
<h2 id="what-can-rustree-do"><a class="header" href="#what-can-rustree-do">What can RusTree do?</a></h2>
<ul>
<li><strong>Visualize Directory Structures:</strong> Clearly see the hierarchy of files and folders.</li>
<li><strong>Filter and Ignore Entries:</strong>
<ul>
<li>List only files/directories matching specific wildcard patterns (<code>-P</code> or <code>--filter-include</code>).</li>
<li>Exclude files/directories using glob patterns (<code>-I</code> or <code>--filter-exclude</code>).</li>
<li>Respect <code>.gitignore</code> files (<code>--use-gitignore-rules</code>) and custom ignore files (<code>--gitignore-file</code>).</li>
<li>Perform case-insensitive pattern matching (<code>--case-insensitive-filter</code>).</li>
<li>Prune empty directories from the output (<code>--prune-empty-directories</code>).</li>
</ul>
</li>
<li><strong>Analyze Content:</strong> Get insights like file sizes, modification dates, line counts, and word counts.</li>
<li><strong>Apply Custom Logic:</strong> Use built-in functions (or extend with your own) to process file contents and report results.</li>
<li><strong>Sort Entries:</strong> Organize the tree output by name, size, modification time, or other criteria.</li>
<li><strong>Flexible Output:</strong> Choose between plain text tree format, Markdown, JSON, or a self-contained HTML page.</li>
<li><strong>Cross-Platform:</strong> Built with Rust, aiming for compatibility across different operating systems.</li>
</ul>
<h2 id="who-is-this-for"><a class="header" href="#who-is-this-for">Who is this for?</a></h2>
<ul>
<li><strong>Developers:</strong> Who need to quickly understand the layout of a project or directory.</li>
<li><strong>System Administrators:</strong> For inspecting directory contents and sizes.</li>
<li><strong>Anyone working with files:</strong> Who wants a more powerful alternative to basic <code>ls</code> or <code>dir</code> commands.</li>
<li><strong>Rustaceans:</strong> Who want to use or contribute to a Rust-based utility.</li>
</ul>
<p>This documentation will guide you through installing RusTree, using its command-line interface, and leveraging its capabilities as a Rust library in your own projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This section will help you get RusTree up and running.</p>
<p>We'll cover:</p>
<ul>
<li><a href="./getting_started/installation.html">Installation</a>: How to install the RusTree command-line tool.</li>
<li><a href="./getting_started/basic_usage.html">Basic Usage</a>: A quick tour of how to use RusTree from your terminal.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>RusTree is a Rust application and can be installed using Cargo, Rust's package manager.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>Ensure you have Rust and Cargo installed. If not, please visit <a href="https://rustup.rs/">rustup.rs</a> to install them.</p>
<h3 id="installing-from-cratesio-recommended"><a class="header" href="#installing-from-cratesio-recommended">Installing from Crates.io (Recommended)</a></h3>
<p>Once RusTree is published to <a href="https://crates.io/">crates.io</a>, you can install it directly using:</p>
<pre><code class="language-bash">cargo install rustree
</code></pre>
<p>This will download the source code, compile it, and place the <code>rustree</code> executable in your Cargo binary directory (usually <code>~/.cargo/bin/</code>). Make sure this directory is in your system's <code>PATH</code>.</p>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h3>
<p>If you want to build from the latest source code (e.g., from a Git repository):</p>
<ol>
<li>
<p>Clone the repository:</p>
<pre><code class="language-bash">git clone https://github.com/pallavbakshi/rusTree.git
cd rusTree
</code></pre>
</li>
<li>
<p>Build and install the binary:</p>
<pre><code class="language-bash">cargo install --path .
</code></pre>
<p>Alternatively, to just build for development:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>The executable will be located at <code>target/release/rustree</code>.</p>
</li>
</ol>
<h3 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h3>
<p>After installation, you should be able to run:</p>
<pre><code class="language-bash">rustree --version
</code></pre>
<p>This command should print the installed version of RusTree. If you see an error, ensure <code>~/.cargo/bin</code> is in your <code>PATH</code> or try opening a new terminal session.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>Once RusTree is installed, you can use it from your command line.</p>
<h3 id="displaying-the-current-directory"><a class="header" href="#displaying-the-current-directory">Displaying the Current Directory</a></h3>
<p>The simplest way to use RusTree is to navigate to the directory you want to inspect and run:</p>
<pre><code class="language-bash">rustree
</code></pre>
<p>This will display the tree structure of the current directory (<code>.</code>).</p>
<h3 id="specifying-a-path"><a class="header" href="#specifying-a-path">Specifying a Path</a></h3>
<p>You can also specify a path to a directory:</p>
<pre><code class="language-bash">rustree /path/to/your/directory
</code></pre>
<p>Or a relative path:</p>
<pre><code class="language-bash">rustree ../some/other/folder
</code></pre>
<h3 id="common-options"><a class="header" href="#common-options">Common Options</a></h3>
<p>Here are a few common options to get you started:</p>
<ul>
<li>
<p><strong>Show all files (including hidden):</strong></p>
<pre><code class="language-bash">rustree -a
# or
rustree --include-hidden
</code></pre>
</li>
<li>
<p><strong>Limit depth:</strong></p>
<pre><code class="language-bash">rustree -L 2  # Show current directory and its direct children (depth 1 and 2)
# or
rustree --depth 2
</code></pre>
</li>
<li>
<p><strong>Show file sizes (in bytes):</strong></p>
<pre><code class="language-bash">rustree -s
# or
rustree --show-size-bytes
</code></pre>
</li>
<li>
<p><strong>Sort by size (ascending):</strong></p>
<pre><code class="language-bash">rustree --sort-by size
</code></pre>
</li>
<li>
<p><strong>Sort by size (descending):</strong></p>
<pre><code class="language-bash">rustree --sort-by size -r
# or
rustree --sort-by size --reverse-sort
</code></pre>
</li>
<li>
<p><strong>Display file contents after tree structure:</strong></p>
<pre><code class="language-bash">rustree --apply-function cat
</code></pre>
<p>This shows the directory tree first, then displays the content of each file with clear headers.</p>
</li>
<li>
<p><strong>Count specific characters in files:</strong></p>
<pre><code class="language-bash">rustree --apply-function count-pluses
</code></pre>
<p>This counts '+' characters in each file and displays the count in metadata.</p>
</li>
</ul>
<h3 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h3>
<p>For a full list of options and commands, use the help flag:</p>
<pre><code class="language-bash">rustree --help
</code></pre>
<p>This will display all available arguments and their descriptions.</p>
<p>Explore the <a href="getting_started/../cli_usage.html">Command-Line Interface (CLI)</a> section for more detailed information on all options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface-cli"><a class="header" href="#command-line-interface-cli">Command-Line Interface (CLI)</a></h1>
<p>This section provides comprehensive documentation for the <code>rustree</code> command-line tool, organized by functional areas for easy navigation.</p>
<h2 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h2>
<pre><code class="language-bash">rustree [OPTIONS] [PATH]
</code></pre>
<ul>
<li><code>[OPTIONS]</code>: Various flags to control behavior (e.g., depth, sorting, output format, apply functions).</li>
<li><code>[PATH]</code>: Optional path to the directory to scan. Defaults to the current directory (<code>.</code>).</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Tree visualization</strong> with customizable depth and formatting</li>
<li><strong>Metadata display</strong> including sizes, timestamps, line/word counts</li>
<li><strong>Enhanced summary reports</strong> with automatic aggregation of metadata totals</li>
<li><strong>Apply functions</strong> to analyze file contents and directory statistics</li>
<li><strong>Flexible filtering</strong> with patterns, gitignore support, and function-specific filtering</li>
<li><strong>Advanced sorting</strong> by various criteria including custom function output</li>
<li><strong>Multiple output formats</strong> (text, markdown, JSON, HTML) for different use cases</li>
<li><strong>LLM integration</strong> for AI-powered project analysis</li>
<li><strong>Directory comparison</strong> and change tracking</li>
<li><strong>Configuration file support</strong> for persistent settings</li>
</ul>
<h2 id="documentation-organization"><a class="header" href="#documentation-organization">Documentation Organization</a></h2>
<p>The CLI documentation is organized into the following sections:</p>
<h3 id="core-usage"><a class="header" href="#core-usage">Core Usage</a></h3>
<ul>
<li><strong><a href="./cli_usage/getting_started.html">Getting Started</a></strong> - Basic commands and essential options for new users</li>
<li><strong><a href="./cli_usage/configuration.html">Configuration</a></strong> - Config files, shell completions, and persistent settings</li>
</ul>
<h3 id="tree-control"><a class="header" href="#tree-control">Tree Control</a></h3>
<ul>
<li><strong><a href="./cli_usage/listing_and_traversal.html">Listing and Traversal</a></strong> - Control tree depth, hidden files, and path display</li>
<li><strong><a href="./cli_usage/filtering_and_patterns.html">Filtering and Patterns</a></strong> - Include/exclude patterns, gitignore integration, size filtering</li>
</ul>
<h3 id="analysis-and-display"><a class="header" href="#analysis-and-display">Analysis and Display</a></h3>
<ul>
<li><strong><a href="./cli_usage/metadata_and_analysis.html">Metadata and Analysis</a></strong> - File sizes, timestamps, line/word counts, and content analysis</li>
<li><strong><a href="./cli_usage/apply_functions.html">Apply Functions</a></strong> - Built-in and external functions for file and directory analysis</li>
<li><strong><a href="./cli_usage/sorting_and_ordering.html">Sorting and Ordering</a></strong> - Sort by various criteria and control output organization</li>
</ul>
<h3 id="output-and-integration"><a class="header" href="#output-and-integration">Output and Integration</a></h3>
<ul>
<li><strong><a href="./cli_usage/output_formats.html">Output Formats</a></strong> - Text, Markdown, JSON, HTML formats and customization</li>
<li><strong><a href="./cli_usage/llm_integration.html">LLM Integration</a></strong> - AI-powered analysis with various LLM providers</li>
<li><strong><a href="./cli_usage/diff_and_comparison.html">Diff and Comparison</a></strong> - Directory comparison and change tracking</li>
</ul>
<h3 id="reference"><a class="header" href="#reference">Reference</a></h3>
<ul>
<li><strong><a href="./cli_usage/options.html">Options and Flags</a></strong> - Comprehensive reference of all available command-line options</li>
<li><strong><a href="./cli_usage/examples.html">Examples</a></strong> - Practical examples demonstrating various use cases</li>
</ul>
<h2 id="enhanced-summary-reports"><a class="header" href="#enhanced-summary-reports">Enhanced Summary Reports</a></h2>
<p>When using metadata flags like <code>--calculate-lines</code>, <code>--calculate-words</code>, or <code>--show-size-bytes</code>, the summary line automatically includes aggregated totals:</p>
<pre><code class="language-bash"># Instead of just: "3 directories, 15 files"
# You now get: "3 directories, 15 files, 1,234 total lines, 5,678 total words, 2.1 MB total"
</code></pre>
<p>This feature works with:</p>
<ul>
<li>Line counts (<code>--calculate-lines</code>)</li>
<li>Word counts (<code>--calculate-words</code>)</li>
<li>File sizes (<code>--show-size-bytes</code>)</li>
<li>Apply function outputs (when numeric)</li>
<li>Large numbers are formatted with thousand separators for readability</li>
</ul>
<h2 id="quick-help"><a class="header" href="#quick-help">Quick Help</a></h2>
<p>To see all available options directly from your terminal:</p>
<pre><code class="language-bash">rustree --help        # Full help with all options
rustree -h            # Short help summary
rustree --version     # Show version information
</code></pre>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>If you're new to RusTree, start with the <a href="./cli_usage/getting_started.html">Getting Started</a> guide for the most commonly used commands and options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-rustree-cli"><a class="header" href="#getting-started-with-rustree-cli">Getting Started with RusTree CLI</a></h1>
<p>This page covers the most basic and commonly used RusTree commands to get you started quickly.</p>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<p>The simplest way to use RusTree is just to run it without any arguments:</p>
<pre><code class="language-bash">rustree
</code></pre>
<p>This displays a tree of the current directory with default settings.</p>
<h2 id="essential-options"><a class="header" href="#essential-options">Essential Options</a></h2>
<h3 id="specify-a-directory"><a class="header" href="#specify-a-directory">Specify a Directory</a></h3>
<p>Point RusTree at any directory:</p>
<pre><code class="language-bash">rustree /path/to/directory
rustree ~/Documents
rustree ./src
</code></pre>
<h3 id="control-tree-depth"><a class="header" href="#control-tree-depth">Control Tree Depth</a></h3>
<p>Limit how deep into subdirectories RusTree scans:</p>
<pre><code class="language-bash"># Show only the root and direct children (depth 1)
rustree -L 1

# Show up to 3 levels deep
rustree --depth 3 ./my_project
</code></pre>
<h3 id="show-hidden-files"><a class="header" href="#show-hidden-files">Show Hidden Files</a></h3>
<p>Include files and directories that start with a dot:</p>
<pre><code class="language-bash"># Show hidden files
rustree -a

# Long form
rustree --include-hidden
</code></pre>
<h3 id="display-file-sizes"><a class="header" href="#display-file-sizes">Display File Sizes</a></h3>
<p>Show the size of each file:</p>
<pre><code class="language-bash"># Show sizes in bytes
rustree -s

# Long form
rustree --show-size-bytes
</code></pre>
<h3 id="show-modification-times"><a class="header" href="#show-modification-times">Show Modification Times</a></h3>
<p>Display when files were last modified:</p>
<pre><code class="language-bash"># Show modification times
rustree -D

# Long form  
rustree --show-last-modified
</code></pre>
<h2 id="common-combinations"><a class="header" href="#common-combinations">Common Combinations</a></h2>
<h3 id="explore-a-project-structure"><a class="header" href="#explore-a-project-structure">Explore a Project Structure</a></h3>
<pre><code class="language-bash"># Get an overview of a project (2 levels deep, with sizes)
rustree -L 2 -s ./my_project
</code></pre>
<h3 id="analyze-source-code"><a class="header" href="#analyze-source-code">Analyze Source Code</a></h3>
<pre><code class="language-bash"># Look at source files with metadata
rustree -a -s -D --depth 3 ./src
</code></pre>
<h3 id="quick-directory-overview"><a class="header" href="#quick-directory-overview">Quick Directory Overview</a></h3>
<pre><code class="language-bash"># See directory structure only (no files)
rustree -d -L 2 ./workspace
</code></pre>
<h2 id="simple-filtering"><a class="header" href="#simple-filtering">Simple Filtering</a></h2>
<h3 id="show-only-specific-file-types"><a class="header" href="#show-only-specific-file-types">Show Only Specific File Types</a></h3>
<pre><code class="language-bash"># Show only Rust files
rustree -P "*.rs"

# Show only documentation files
rustree -P "*.md|*.txt"
</code></pre>
<h3 id="hide-specific-files-or-directories"><a class="header" href="#hide-specific-files-or-directories">Hide Specific Files or Directories</a></h3>
<pre><code class="language-bash"># Hide log files
rustree -I "*.log"

# Hide build directories
rustree -I "target/|build/"
</code></pre>
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<ul>
<li>Use <code>rustree --help</code> for a complete list of options</li>
<li>Use <code>rustree -h</code> for a shorter summary</li>
<li>Check <code>rustree --version</code> to see your version</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Once you're comfortable with these basics, explore more advanced features:</p>
<ul>
<li><strong><a href="cli_usage/./listing_and_traversal.html">Listing and Traversal</a></strong> - Advanced tree structure control</li>
<li><strong><a href="cli_usage/./filtering_and_patterns.html">Filtering and Patterns</a></strong> - Powerful include/exclude capabilities</li>
<li><strong><a href="cli_usage/./metadata_and_analysis.html">Metadata and Analysis</a></strong> - File analysis and information display</li>
<li><strong><a href="cli_usage/./examples.html">Examples</a></strong> - Comprehensive examples for all features</li>
</ul>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--depth &lt;N&gt;</code></td><td><code>-L &lt;N&gt;</code></td><td>Limit tree depth to N levels</td></tr>
<tr><td><code>--include-hidden</code></td><td><code>-a</code></td><td>Show hidden files/directories</td></tr>
<tr><td><code>--show-size-bytes</code></td><td><code>-s</code></td><td>Display file sizes</td></tr>
<tr><td><code>--show-last-modified</code></td><td><code>-D</code></td><td>Show modification times</td></tr>
<tr><td><code>--directory-only</code></td><td><code>-d</code></td><td>Show directories only</td></tr>
<tr><td><code>--filter-include &lt;PATTERN&gt;</code></td><td><code>-P &lt;PATTERN&gt;</code></td><td>Include only matching files</td></tr>
<tr><td><code>--filter-exclude &lt;PATTERN&gt;</code></td><td><code>-I &lt;PATTERN&gt;</code></td><td>Exclude matching files</td></tr>
<tr><td><code>--help</code></td><td><code>-h</code></td><td>Show help information</td></tr>
<tr><td><code>--version</code></td><td><code>-V</code></td><td>Show version information</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="listing-and-traversal"><a class="header" href="#listing-and-traversal">Listing and Traversal</a></h1>
<p>This page covers options that control how RusTree traverses directories and what elements of the tree structure it displays.</p>
<h2 id="tree-depth-control"><a class="header" href="#tree-depth-control">Tree Depth Control</a></h2>
<h3 id="maximum-depth"><a class="header" href="#maximum-depth">Maximum Depth</a></h3>
<p>Control how deep RusTree descends into subdirectories:</p>
<pre><code class="language-bash"># Show only direct children (depth 1)
rustree -L 1

# Scan up to 3 levels deep
rustree --depth 3 ./project

# No depth limit (default behavior)
rustree ./project
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Quick project overview
rustree -L 2 ~/my_project

# Detailed but limited scan
rustree --depth 4 --show-size-bytes ./src
</code></pre>
<h2 id="hidden-files-and-directories"><a class="header" href="#hidden-files-and-directories">Hidden Files and Directories</a></h2>
<h3 id="including-hidden-files"><a class="header" href="#including-hidden-files">Including Hidden Files</a></h3>
<p>By default, RusTree ignores files and directories starting with a dot (<code>.</code>). Use <code>-a</code> to include them:</p>
<pre><code class="language-bash"># Show hidden files and directories
rustree -a

# Long form
rustree --include-hidden

# Combine with other options
rustree -a -L 2 -s
</code></pre>
<p><strong>Important:</strong> When using pattern matching (<code>-P</code>), you need <code>-a</code> for patterns like <code>*</code> to match hidden files. Patterns that explicitly start with <code>.</code> (like <code>.*</code>) will match hidden files regardless.</p>
<pre><code class="language-bash"># This WON'T match .hidden_file
rustree -P "*"

# This WILL match .hidden_file  
rustree -a -P "*"

# This WILL match .hidden_file (explicit dot pattern)
rustree -P ".*"
</code></pre>
<h2 id="directory-vs-file-display"><a class="header" href="#directory-vs-file-display">Directory vs File Display</a></h2>
<h3 id="directory-only-mode"><a class="header" href="#directory-only-mode">Directory-Only Mode</a></h3>
<p>Show only directories, excluding all files:</p>
<pre><code class="language-bash"># Show directory structure only
rustree -d

# Long form
rustree --directory-only

# Combine with depth and metadata
rustree -d -L 3 -s ./workspace
</code></pre>
<p>This is useful for understanding the overall organization of large projects without being overwhelmed by individual files.</p>
<h3 id="full-path-display"><a class="header" href="#full-path-display">Full Path Display</a></h3>
<p>Show the complete relative path for each entry:</p>
<pre><code class="language-bash"># Display full paths
rustree -f

# Long form  
rustree --full-path
</code></pre>
<p><strong>Example output:</strong></p>
<pre><code>my_project/
├── README.md
├── src/
│   ├── src/main.rs        # Shows full path from root
│   ├── src/lib.rs
│   └── src/utils/
│       └── src/utils/helper.rs
└── tests/
    └── tests/integration_test.rs
</code></pre>
<p>This is particularly useful when you need to know exact file locations, especially for documentation or when working with tools that need full paths.</p>
<h2 id="path-arguments"><a class="header" href="#path-arguments">Path Arguments</a></h2>
<h3 id="scanning-multiple-paths"><a class="header" href="#scanning-multiple-paths">Scanning Multiple Paths</a></h3>
<p>RusTree can scan a specific directory by providing it as an argument:</p>
<pre><code class="language-bash"># Scan a specific directory
rustree ~/Documents

# Scan relative path
rustree ./src

# Scan with options
rustree -a -L 2 /etc/nginx
</code></pre>
<h3 id="current-directory"><a class="header" href="#current-directory">Current Directory</a></h3>
<p>When no path is specified, RusTree scans the current directory:</p>
<pre><code class="language-bash"># These are equivalent
rustree
rustree .
rustree ./
</code></pre>
<h2 id="combining-traversal-options"><a class="header" href="#combining-traversal-options">Combining Traversal Options</a></h2>
<h3 id="common-combinations-1"><a class="header" href="#common-combinations-1">Common Combinations</a></h3>
<pre><code class="language-bash"># Project structure overview
rustree -d -L 2 --full-path ./my_project

# Hidden configuration files
rustree -a -P ".*" /etc

# Detailed source code structure  
rustree -f --include-hidden --depth 4 ./src

# Quick directory tree with sizes
rustree -d -s -L 3 ~/workspace
</code></pre>
<h3 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h3>
<p>For large directories, consider:</p>
<ul>
<li>Using <code>--depth</code> to limit traversal depth</li>
<li>Using <code>--directory-only</code> to skip files when analyzing structure</li>
<li>Combining with <a href="cli_usage/./filtering_and_patterns.html">filtering</a> to focus on relevant content</li>
</ul>
<h2 id="integration-with-other-features"><a class="header" href="#integration-with-other-features">Integration with Other Features</a></h2>
<p>Traversal options work seamlessly with other RusTree features:</p>
<ul>
<li><strong><a href="cli_usage/./filtering_and_patterns.html">Filtering</a></strong>: Control which files are included based on patterns</li>
<li><strong><a href="cli_usage/./metadata_and_analysis.html">Metadata</a></strong>: Add file information to the traversal output</li>
<li><strong><a href="cli_usage/./sorting_and_ordering.html">Sorting</a></strong>: Control how entries are ordered in the tree</li>
<li><strong><a href="cli_usage/./output_formats.html">Output Formats</a></strong>: Change how the traversal results are displayed</li>
</ul>
<h2 id="quick-reference-1"><a class="header" href="#quick-reference-1">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--depth &lt;N&gt;</code></td><td><code>-L &lt;N&gt;</code></td><td>Limit traversal to N levels deep</td></tr>
<tr><td><code>--include-hidden</code></td><td><code>-a</code></td><td>Include hidden files/directories (starting with <code>.</code>)</td></tr>
<tr><td><code>--directory-only</code></td><td><code>-d</code></td><td>Show directories only, exclude files</td></tr>
<tr><td><code>--full-path</code></td><td><code>-f</code></td><td>Display complete relative paths for all entries</td></tr>
</tbody></table>
</div>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>See the <a href="cli_usage/./examples.html">Examples</a> page for more detailed usage scenarios and combinations with other features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filtering-and-patterns"><a class="header" href="#filtering-and-patterns">Filtering and Patterns</a></h1>
<p>RusTree provides powerful filtering capabilities to show only the files and directories you're interested in. This page covers include/exclude patterns, gitignore integration, and size-based filtering.</p>
<h2 id="pattern-syntax"><a class="header" href="#pattern-syntax">Pattern Syntax</a></h2>
<p>RusTree uses glob patterns for matching files and directories:</p>
<ul>
<li><code>*</code> - Matches any number of characters (except <code>/</code>)</li>
<li><code>?</code> - Matches exactly one character</li>
<li><code>[abc]</code> - Matches any character in brackets</li>
<li><code>[a-z]</code> - Matches any character in range</li>
<li><code>[!abc]</code> - Matches any character NOT in brackets</li>
<li><code>**</code> - Matches any number of directories (recursive)</li>
<li><code>|</code> - Separates alternative patterns within one argument</li>
</ul>
<h2 id="include-patterns"><a class="header" href="#include-patterns">Include Patterns</a></h2>
<h3 id="basic-include-filtering"><a class="header" href="#basic-include-filtering">Basic Include Filtering</a></h3>
<p>Show only files/directories that match specific patterns:</p>
<pre><code class="language-bash"># Show only Rust files
rustree -P "*.rs"

# Show only documentation files
rustree --filter-include "*.md"

# Multiple file types using pipe separator
rustree -P "*.rs|*.toml|*.md"
</code></pre>
<h3 id="multiple-include-patterns"><a class="header" href="#multiple-include-patterns">Multiple Include Patterns</a></h3>
<p>You can specify multiple <code>-P</code> options:</p>
<pre><code class="language-bash"># These are equivalent
rustree -P "*.rs" -P "*.toml" -P "*.md"
rustree -P "*.rs|*.toml|*.md"
</code></pre>
<h3 id="directory-specific-patterns"><a class="header" href="#directory-specific-patterns">Directory-Specific Patterns</a></h3>
<p>Use a trailing <code>/</code> to match directories only:</p>
<pre><code class="language-bash"># Match directories named "src" or "lib"
rustree -P "src/|lib/"

# Match any directory ending with "_test"  
rustree -P "*_test/"
</code></pre>
<h3 id="path-based-patterns"><a class="header" href="#path-based-patterns">Path-Based Patterns</a></h3>
<p>Use <code>/</code> or <code>**</code> for path-based matching:</p>
<pre><code class="language-bash"># Files directly in src directory
rustree -P "src/*.rs"

# Rust files anywhere in the tree
rustree -P "**/*.rs"

# Files in any subdirectory of src
rustree -P "src/**"

# Specific nested path
rustree -P "src/cli/*.rs"
</code></pre>
<h2 id="exclude-patterns"><a class="header" href="#exclude-patterns">Exclude Patterns</a></h2>
<h3 id="basic-exclude-filtering"><a class="header" href="#basic-exclude-filtering">Basic Exclude Filtering</a></h3>
<p>Hide files/directories that match patterns:</p>
<pre><code class="language-bash"># Hide log files
rustree -I "*.log"

# Hide build directories
rustree --filter-exclude "target/"

# Hide multiple types
rustree -I "*.tmp|*.log|*.bak"
</code></pre>
<h3 id="multiple-exclude-patterns"><a class="header" href="#multiple-exclude-patterns">Multiple Exclude Patterns</a></h3>
<pre><code class="language-bash"># Multiple exclude options
rustree -I "target/" -I "node_modules/" -I "*.log"

# Pipe-separated in single option
rustree -I "target/|node_modules/|*.log"
</code></pre>
<h3 id="complex-exclusions"><a class="header" href="#complex-exclusions">Complex Exclusions</a></h3>
<pre><code class="language-bash"># Hide all hidden directories but keep hidden files
rustree -I ".*/"

# Hide test files but keep test directories  
rustree -I "*test*.rs" --filter-include "*test*/"
</code></pre>
<h2 id="pattern-files"><a class="header" href="#pattern-files">Pattern Files</a></h2>
<h3 id="include-patterns-from-file"><a class="header" href="#include-patterns-from-file">Include Patterns from File</a></h3>
<p>Store patterns in files for reusability:</p>
<p>Create <code>include-patterns.txt</code>:</p>
<pre><code># Source code files
*.rs
*.go
*.js
*.ts

# Configuration files  
*.toml
*.yml
*.yaml

# Documentation
*.md
README*
</code></pre>
<p>Use the file:</p>
<pre><code class="language-bash">rustree --filter-include-from ./include-patterns.txt
</code></pre>
<h3 id="exclude-patterns-from-file"><a class="header" href="#exclude-patterns-from-file">Exclude Patterns from File</a></h3>
<p>Create <code>exclude-patterns.txt</code>:</p>
<pre><code># Build artifacts
target/
build/
dist/

# Dependencies
node_modules/
vendor/

# Temporary files
*.tmp
*.log
*.swp
.DS_Store
</code></pre>
<p>Use the file:</p>
<pre><code class="language-bash">rustree --filter-exclude-from ./exclude-patterns.txt
</code></pre>
<h3 id="multiple-pattern-files"><a class="header" href="#multiple-pattern-files">Multiple Pattern Files</a></h3>
<pre><code class="language-bash"># Load from multiple files
rustree --filter-include-from ./src-patterns.txt \
        --filter-include-from ./docs-patterns.txt \
        --filter-exclude-from ./ignore-patterns.txt
</code></pre>
<h3 id="pattern-file-format"><a class="header" href="#pattern-file-format">Pattern File Format</a></h3>
<ul>
<li>One pattern per line</li>
<li>Lines starting with <code>#</code> are comments</li>
<li>Empty lines are ignored</li>
<li>Same glob syntax as command-line patterns</li>
</ul>
<h2 id="gitignore-integration"><a class="header" href="#gitignore-integration">Gitignore Integration</a></h2>
<h3 id="basic-gitignore-support"><a class="header" href="#basic-gitignore-support">Basic Gitignore Support</a></h3>
<p>Respect <code>.gitignore</code> files automatically:</p>
<pre><code class="language-bash"># Use .gitignore rules
rustree --use-gitignore-rules

# Old alias (deprecated but still works)
rustree --gitignore
</code></pre>
<p>This respects:</p>
<ul>
<li><code>.gitignore</code> files in the scanned directories</li>
<li>Global gitignore file (<code>~/.config/git/ignore</code>)</li>
<li>Repository exclude files (<code>$GIT_DIR/info/exclude</code>)</li>
</ul>
<h3 id="custom-ignore-files"><a class="header" href="#custom-ignore-files">Custom Ignore Files</a></h3>
<p>Use specific files as gitignore sources:</p>
<pre><code class="language-bash"># Use custom ignore file
rustree --gitignore-file ./.customignore

# Multiple ignore files
rustree --gitignore-file ./.customignore --gitignore-file ./project.ignores

# Combine with standard gitignore
rustree --use-gitignore-rules --gitignore-file ./.extraignores
</code></pre>
<h2 id="case-sensitivity"><a class="header" href="#case-sensitivity">Case Sensitivity</a></h2>
<h3 id="case-insensitive-matching"><a class="header" href="#case-insensitive-matching">Case-Insensitive Matching</a></h3>
<p>Make all pattern matching case-insensitive:</p>
<pre><code class="language-bash"># Match *.TXT, *.txt, *.Txt, etc.
rustree -P "*.txt" --case-insensitive-filter

# Apply to all filter types
rustree -P "*.RS" -I "TARGET/" --case-insensitive-filter --use-gitignore-rules
</code></pre>
<p>Affects:</p>
<ul>
<li>Include patterns (<code>-P</code>, <code>--filter-include</code>)</li>
<li>Exclude patterns (<code>-I</code>, <code>--filter-exclude</code>)</li>
<li>Pattern files (<code>--filter-include-from</code>, <code>--filter-exclude-from</code>)</li>
<li>Gitignore patterns (<code>--use-gitignore-rules</code>, <code>--gitignore-file</code>)</li>
</ul>
<h2 id="size-based-filtering"><a class="header" href="#size-based-filtering">Size-Based Filtering</a></h2>
<h3 id="minimum-file-size"><a class="header" href="#minimum-file-size">Minimum File Size</a></h3>
<p>Include only files above a certain size:</p>
<pre><code class="language-bash"># Files at least 100KB
rustree --min-file-size 100K

# Files at least 2MB
rustree --min-file-size 2M

# Files at least 1GB
rustree --min-file-size 1G
</code></pre>
<h3 id="maximum-file-size"><a class="header" href="#maximum-file-size">Maximum File Size</a></h3>
<p>Include only files below a certain size:</p>
<pre><code class="language-bash"># Files no larger than 500KB  
rustree --max-file-size 500K

# Small files only (under 1MB)
rustree --max-file-size 1M
</code></pre>
<h3 id="size-ranges"><a class="header" href="#size-ranges">Size Ranges</a></h3>
<p>Combine min and max for size ranges:</p>
<pre><code class="language-bash"># Files between 10KB and 1MB
rustree --min-file-size 10K --max-file-size 1M

# Medium-sized files (100KB to 10MB)
rustree --min-file-size 100K --max-file-size 10M
</code></pre>
<h3 id="size-units"><a class="header" href="#size-units">Size Units</a></h3>
<p>Supported size suffixes (base-1024):</p>
<ul>
<li><code>K</code> - Kibibytes (1024 bytes)</li>
<li><code>M</code> - Mebibytes (1024² bytes)</li>
<li><code>G</code> - Gibibytes (1024³ bytes)</li>
</ul>
<p><strong>Note:</strong> Size filtering only applies to files, not directories.</p>
<h2 id="empty-directory-pruning"><a class="header" href="#empty-directory-pruning">Empty Directory Pruning</a></h2>
<h3 id="remove-empty-directories"><a class="header" href="#remove-empty-directories">Remove Empty Directories</a></h3>
<p>Hide directories that become empty after filtering:</p>
<pre><code class="language-bash"># Remove empty directories
rustree --prune-empty-directories

# Short alias
rustree --prune

# Combine with filtering
rustree -P "*.rs" --prune
</code></pre>
<p>This is applied after all other filtering, so a directory containing only filtered-out files will be considered empty and pruned.</p>
<h2 id="hidden-files-and-patterns"><a class="header" href="#hidden-files-and-patterns">Hidden Files and Patterns</a></h2>
<h3 id="pattern-matching-with-hidden-files"><a class="header" href="#pattern-matching-with-hidden-files">Pattern Matching with Hidden Files</a></h3>
<p>By default, patterns like <code>*</code> don't match hidden files:</p>
<pre><code class="language-bash"># This WON'T match .hidden_file
rustree -P "*"

# This WILL match .hidden_file
rustree -a -P "*"

# This WILL match .hidden_file (explicit dot)
rustree -P ".*"
</code></pre>
<p>Use <code>-a</code> with general patterns to include hidden files in pattern matching.</p>
<h2 id="combining-filters"><a class="header" href="#combining-filters">Combining Filters</a></h2>
<h3 id="complex-filtering-examples"><a class="header" href="#complex-filtering-examples">Complex Filtering Examples</a></h3>
<pre><code class="language-bash"># Source code only, no build artifacts
rustree -P "*.rs|*.toml" -I "target/" --use-gitignore-rules

# Large documentation files
rustree -P "*.md" --min-file-size 10K --max-file-size 1M

# Configuration files with custom ignore
rustree -P "*.yml|*.yaml|*.toml|*.json" \
        --filter-exclude-from ./temp-ignores.txt \
        --case-insensitive-filter

# Include from file, exclude specific patterns
rustree --filter-include-from ./source-patterns.txt \
        -I "*.test.*" -I "*_backup*" \
        --prune-empty-directories
</code></pre>
<h2 id="integration-with-other-features-1"><a class="header" href="#integration-with-other-features-1">Integration with Other Features</a></h2>
<p>Filtering works with all other RusTree features:</p>
<ul>
<li><strong><a href="cli_usage/./apply_functions.html">Apply Functions</a></strong>: Apply functions only to filtered files</li>
<li><strong><a href="cli_usage/./metadata_and_analysis.html">Metadata Analysis</a></strong>: Show metadata for filtered files</li>
<li><strong><a href="cli_usage/./sorting_and_ordering.html">Sorting</a></strong>: Sort filtered results</li>
<li><strong><a href="cli_usage/./output_formats.html">Output Formats</a></strong>: Format filtered output</li>
</ul>
<h2 id="quick-reference-2"><a class="header" href="#quick-reference-2">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--filter-include &lt;PATTERN&gt;</code></td><td><code>-P</code></td><td>Include only files matching pattern</td></tr>
<tr><td><code>--filter-exclude &lt;PATTERN&gt;</code></td><td><code>-I</code></td><td>Exclude files matching pattern</td></tr>
<tr><td><code>--filter-include-from &lt;FILE&gt;</code></td><td></td><td>Read include patterns from file</td></tr>
<tr><td><code>--filter-exclude-from &lt;FILE&gt;</code></td><td></td><td>Read exclude patterns from file</td></tr>
<tr><td><code>--use-gitignore-rules</code></td><td></td><td>Respect .gitignore files</td></tr>
<tr><td><code>--gitignore-file &lt;FILE&gt;</code></td><td></td><td>Use specific file as gitignore source</td></tr>
<tr><td><code>--case-insensitive-filter</code></td><td></td><td>Make all pattern matching case-insensitive</td></tr>
<tr><td><code>--min-file-size &lt;SIZE&gt;</code></td><td></td><td>Include only files at least this size</td></tr>
<tr><td><code>--max-file-size &lt;SIZE&gt;</code></td><td></td><td>Include only files no larger than this size</td></tr>
<tr><td><code>--prune-empty-directories</code></td><td></td><td>Remove directories that become empty after filtering</td></tr>
</tbody></table>
</div>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>See the <a href="cli_usage/./examples.html">Examples</a> page for more detailed filtering scenarios and real-world use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metadata-and-analysis"><a class="header" href="#metadata-and-analysis">Metadata and Analysis</a></h1>
<p>RusTree can collect and display various types of metadata about files and directories, from basic size and timestamp information to detailed content analysis. This page covers all metadata and analysis options.</p>
<h2 id="file-size-information"><a class="header" href="#file-size-information">File Size Information</a></h2>
<h3 id="basic-size-display"><a class="header" href="#basic-size-display">Basic Size Display</a></h3>
<p>Show file sizes alongside the tree structure:</p>
<pre><code class="language-bash"># Show sizes in bytes
rustree -s

# Long form
rustree --show-size-bytes
</code></pre>
<h3 id="human-readable-sizes"><a class="header" href="#human-readable-sizes">Human-Readable Sizes</a></h3>
<p>Format sizes in a more readable format:</p>
<pre><code class="language-bash"># Show sizes in human-readable format (1.2 MB instead of 1234567B)
rustree -s --human-friendly

# Combine with other metadata
rustree -s --human-friendly -D --calculate-lines
</code></pre>
<p>The <code>--human-friendly</code> flag converts raw byte counts to readable formats like:</p>
<ul>
<li><code>1.2 KB</code> instead of <code>1234B</code></li>
<li><code>3.4 MB</code> instead of <code>3456789B</code></li>
<li><code>2.1 GB</code> instead of <code>2147483648B</code></li>
</ul>
<h2 id="timestamp-information"><a class="header" href="#timestamp-information">Timestamp Information</a></h2>
<h3 id="modification-times"><a class="header" href="#modification-times">Modification Times</a></h3>
<p>Display when files were last modified:</p>
<pre><code class="language-bash"># Show modification times
rustree -D

# Long form
rustree --show-last-modified
</code></pre>
<h3 id="change-times"><a class="header" href="#change-times">Change Times</a></h3>
<p>When combined with change time sorting, <code>-D</code> shows change times instead:</p>
<pre><code class="language-bash"># Sort by change time and show change times
rustree -c -D

# Or using long form
rustree --sort-by change_time --show-last-modified
</code></pre>
<h3 id="creation-times"><a class="header" href="#creation-times">Creation Times</a></h3>
<p>Show file creation times (where supported by the filesystem):</p>
<pre><code class="language-bash"># Show creation times (may not be available on all systems)
rustree --show-creation-time
</code></pre>
<p><strong>Note:</strong> Creation time support varies by operating system and filesystem. It's most reliable on Windows and macOS, less so on Linux.</p>
<h2 id="content-analysis"><a class="header" href="#content-analysis">Content Analysis</a></h2>
<h3 id="line-counting"><a class="header" href="#line-counting">Line Counting</a></h3>
<p>Count the number of lines in text files:</p>
<pre><code class="language-bash"># Calculate and display line counts
rustree --calculate-lines

# Combine with other analysis
rustree --calculate-lines --show-size-bytes
</code></pre>
<h3 id="word-counting"><a class="header" href="#word-counting">Word Counting</a></h3>
<p>Count words in text files:</p>
<pre><code class="language-bash"># Calculate and display word counts  
rustree --calculate-words

# Combine with line counting
rustree --calculate-lines --calculate-words
</code></pre>
<h3 id="content-analysis-with-filtering"><a class="header" href="#content-analysis-with-filtering">Content Analysis with Filtering</a></h3>
<p>Content analysis works with any file RusTree can read as text:</p>
<pre><code class="language-bash"># Analyze only source code files
rustree --calculate-lines --calculate-words -P "*.rs|*.js|*.py"

# Analyze documentation
rustree --calculate-lines --calculate-words -P "*.md|*.txt"
</code></pre>
<h2 id="enhanced-summary-reports-1"><a class="header" href="#enhanced-summary-reports-1">Enhanced Summary Reports</a></h2>
<p>When using metadata options, RusTree automatically aggregates totals in the summary line:</p>
<pre><code class="language-bash"># This shows enhanced summary with totals
rustree --calculate-lines --calculate-words --show-size-bytes
</code></pre>
<p>Example output:</p>
<pre><code>my_project/
├── [   1024B] [L:  50] [W: 250] README.md
├── [   2048B] [L: 100] [W: 500] main.rs
└── src/
    ├── [   3072B] [L: 150] [W: 750] lib.rs
    └── [   1536B] [L:  75] [W: 375] util.rs

2 directories, 4 files, 375 total lines, 1,875 total words, 7.7 KB total
</code></pre>
<p>The summary automatically includes:</p>
<ul>
<li>Total line counts (when <code>--calculate-lines</code> is used)</li>
<li>Total word counts (when <code>--calculate-words</code> is used)</li>
<li>Total file sizes (when <code>--show-size-bytes</code> is used)</li>
<li>Large numbers formatted with thousand separators</li>
</ul>
<h2 id="combining-metadata-options"><a class="header" href="#combining-metadata-options">Combining Metadata Options</a></h2>
<h3 id="comprehensive-analysis"><a class="header" href="#comprehensive-analysis">Comprehensive Analysis</a></h3>
<pre><code class="language-bash"># Full metadata analysis
rustree --show-size-bytes --show-last-modified --calculate-lines --calculate-words --human-friendly

# Focus on source code with full analysis
rustree -P "*.rs" --show-size-bytes --calculate-lines --calculate-words --sort-by size -r
</code></pre>
<h3 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h3>
<p>Content analysis (line/word counting) requires reading file contents, which can be slower for:</p>
<ul>
<li>Very large files</li>
<li>Large numbers of files</li>
<li>Network-mounted filesystems</li>
</ul>
<p>Consider using <a href="cli_usage/./filtering_and_patterns.html">filtering</a> to limit analysis to relevant files:</p>
<pre><code class="language-bash"># Analyze only source files to improve performance
rustree --calculate-lines -P "*.rs|*.js|*.py" --depth 3
</code></pre>
<h2 id="metadata-display-format"><a class="header" href="#metadata-display-format">Metadata Display Format</a></h2>
<h3 id="size-formatting"><a class="header" href="#size-formatting">Size Formatting</a></h3>
<p>Sizes are displayed in brackets before the filename:</p>
<pre><code class="language-bash">rustree -s
# Output: ├── [   1024B] config.toml
</code></pre>
<p>With <code>--human-friendly</code>:</p>
<pre><code class="language-bash">rustree -s --human-friendly  
# Output: ├── [  1.0 KB] config.toml
</code></pre>
<h3 id="line-and-word-count-display"><a class="header" href="#line-and-word-count-display">Line and Word Count Display</a></h3>
<p>Line and word counts appear in brackets with prefixes:</p>
<pre><code class="language-bash">rustree --calculate-lines --calculate-words
# Output: ├── [L: 150] [W: 750] main.rs
</code></pre>
<h3 id="timestamp-display"><a class="header" href="#timestamp-display">Timestamp Display</a></h3>
<p>Timestamps are shown in a readable format:</p>
<pre><code class="language-bash">rustree -D
# Output: ├── [2024-01-15 14:30:25] main.rs
</code></pre>
<h2 id="integration-with-other-features-2"><a class="header" href="#integration-with-other-features-2">Integration with Other Features</a></h2>
<h3 id="sorting-by-metadata"><a class="header" href="#sorting-by-metadata">Sorting by Metadata</a></h3>
<p>Use metadata for sorting (see <a href="cli_usage/./sorting_and_ordering.html">Sorting and Ordering</a>):</p>
<pre><code class="language-bash"># Sort by file size (largest first)
rustree -s --sort-by size -r

# Sort by line count (most lines first)  
rustree --calculate-lines --sort-by lines -r

# Sort by modification time (newest first)
rustree -D --sort-by mtime -r
</code></pre>
<h3 id="filtering-with-metadata"><a class="header" href="#filtering-with-metadata">Filtering with Metadata</a></h3>
<p>Combine with <a href="cli_usage/./filtering_and_patterns.html#size-based-filtering">size-based filtering</a>:</p>
<pre><code class="language-bash"># Show metadata for large files only
rustree -s --min-file-size 1M --calculate-lines

# Analyze medium-sized source files
rustree --calculate-lines --calculate-words \
        -P "*.rs" \
        --min-file-size 1K --max-file-size 100K
</code></pre>
<h3 id="output-formatting"><a class="header" href="#output-formatting">Output Formatting</a></h3>
<p>Metadata works with all <a href="cli_usage/./output_formats.html">output formats</a>:</p>
<pre><code class="language-bash"># JSON output with metadata
rustree --show-size-bytes --calculate-lines --output-format json

# Markdown documentation with analysis
rustree --calculate-lines -P "*.md" --output-format markdown
</code></pre>
<h2 id="project-analysis-examples"><a class="header" href="#project-analysis-examples">Project Analysis Examples</a></h2>
<h3 id="code-complexity-analysis"><a class="header" href="#code-complexity-analysis">Code Complexity Analysis</a></h3>
<pre><code class="language-bash"># Analyze source code complexity
rustree --calculate-lines --calculate-words --show-size-bytes \
        -P "*.rs|*.js|*.py" \
        --sort-by lines -r \
        --depth 3
</code></pre>
<h3 id="documentation-overview"><a class="header" href="#documentation-overview">Documentation Overview</a></h3>
<pre><code class="language-bash"># Analyze documentation completeness
rustree --calculate-words --show-size-bytes \
        -P "*.md|*.txt|README*" \
        --sort-by words -r
</code></pre>
<h3 id="large-file-detection"><a class="header" href="#large-file-detection">Large File Detection</a></h3>
<pre><code class="language-bash"># Find large files with metadata
rustree --show-size-bytes --human-friendly \
        --min-file-size 1M \
        --sort-by size -r \
        --full-path
</code></pre>
<h3 id="module-size-comparison"><a class="header" href="#module-size-comparison">Module Size Comparison</a></h3>
<pre><code class="language-bash"># Compare module sizes in a project
rustree --show-size-bytes --calculate-lines \
        --directory-only --depth 2 \
        --sort-by size -r
</code></pre>
<h2 id="quick-reference-3"><a class="header" href="#quick-reference-3">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--show-size-bytes</code></td><td><code>-s</code></td><td>Display file sizes in bytes</td></tr>
<tr><td><code>--show-last-modified</code></td><td><code>-D</code></td><td>Show modification times (or change times with <code>-c</code>)</td></tr>
<tr><td><code>--calculate-lines</code></td><td></td><td>Count and display lines in text files</td></tr>
<tr><td><code>--calculate-words</code></td><td></td><td>Count and display words in text files</td></tr>
<tr><td><code>--human-friendly</code></td><td></td><td>Format sizes in readable units (KB, MB, GB)</td></tr>
<tr><td><code>--show-creation-time</code></td><td></td><td>Show file creation times (where supported)</td></tr>
</tbody></table>
</div>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>See the <a href="cli_usage/./examples.html">Examples</a> page for more detailed metadata analysis scenarios and real-world use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apply-functions"><a class="header" href="#apply-functions">Apply Functions</a></h1>
<p>Apply functions allow you to execute operations on files and directories during the tree traversal. RusTree includes powerful built-in functions for analysis and supports external commands for custom processing.</p>
<h2 id="built-in-functions"><a class="header" href="#built-in-functions">Built-In Functions</a></h2>
<h3 id="file-content-functions"><a class="header" href="#file-content-functions">File Content Functions</a></h3>
<p>These functions operate on individual file contents:</p>
<h4 id="cat-function"><a class="header" href="#cat-function">Cat Function</a></h4>
<p>Display the complete contents of files after the tree structure:</p>
<pre><code class="language-bash"># Show tree structure, then file contents
rustree --apply-function cat

# Show contents of specific file types only
rustree --apply-function cat -P "*.md|*.txt"
</code></pre>
<p><strong>Output format:</strong></p>
<pre><code>project/
├── README.md
├── config.toml
└── src/
    └── main.rs

2 directories, 3 files

--- File Contents ---

=== README.md ===
# My Project
This is a sample project...

=== config.toml ===
[package]
name = "my-project"
version = "0.1.0"

=== src/main.rs ===
fn main() {
    println!("Hello, world!");
}
</code></pre>
<h4 id="count-pluses-function"><a class="header" href="#count-pluses-function">Count Pluses Function</a></h4>
<p>Count occurrences of the '+' character in each file:</p>
<pre><code class="language-bash"># Count '+' characters in files
rustree --apply-function count-pluses

# Focus on specific file types
rustree --apply-function count-pluses -P "*.rs|*.js"
</code></pre>
<p><strong>Output format:</strong></p>
<pre><code>project/
├── [+: 5] README.md
├── [+: 0] config.toml
└── src/
    └── [+: 12] main.rs
</code></pre>
<h3 id="directory-analysis-functions"><a class="header" href="#directory-analysis-functions">Directory Analysis Functions</a></h3>
<p>These functions analyze directory contents:</p>
<h4 id="directory-statistics"><a class="header" href="#directory-statistics">Directory Statistics</a></h4>
<p>Get comprehensive statistics for each directory:</p>
<pre><code class="language-bash"># Show files, subdirs, and total size for each directory
rustree --apply-function dir-stats --show-size-bytes
</code></pre>
<p><strong>Output format:</strong></p>
<pre><code>project/
├── [F: "2f,1d,1024B"] src/
│   └── main.rs
└── [F: "1f,0d,512B"] docs/
    └── README.md
</code></pre>
<p>Format: <code>[F: "XFiles,YDirs,ZBytes"]</code></p>
<h4 id="count-files"><a class="header" href="#count-files">Count Files</a></h4>
<p>Count the number of files in each directory:</p>
<pre><code class="language-bash"># Count files in each directory
rustree --apply-function count-files
</code></pre>
<p><strong>Output format:</strong></p>
<pre><code>project/
├── [F: "3"] src/
└── [F: "1"] docs/
</code></pre>
<h4 id="count-directories"><a class="header" href="#count-directories">Count Directories</a></h4>
<p>Count the number of subdirectories in each directory:</p>
<pre><code class="language-bash"># Count subdirectories  
rustree --apply-function count-dirs
</code></pre>
<h4 id="size-total"><a class="header" href="#size-total">Size Total</a></h4>
<p>Calculate total size of all files in each directory:</p>
<pre><code class="language-bash"># Calculate total size (requires --show-size-bytes)
rustree --apply-function size-total --show-size-bytes
</code></pre>
<p><strong>Note:</strong> <code>--show-size-bytes</code> must be enabled for size calculations to work.</p>
<h2 id="external-commands"><a class="header" href="#external-commands">External Commands</a></h2>
<h3 id="custom-command-execution"><a class="header" href="#custom-command-execution">Custom Command Execution</a></h3>
<p>Execute any external command on file contents:</p>
<pre><code class="language-bash"># Run wc -l on each file (count lines)
rustree --apply-function-cmd "wc -l"

# Run grep to count pattern matches
rustree --apply-function-cmd "grep -c 'TODO'"

# Run custom analysis script
rustree --apply-function-cmd "./analyze-file.sh"
</code></pre>
<h3 id="command-result-types"><a class="header" href="#command-result-types">Command Result Types</a></h3>
<p>Specify how to interpret command output:</p>
<pre><code class="language-bash"># Treat output as text (default)
rustree --apply-function-cmd "file" --apply-function-cmd-kind text

# Treat output as a number  
rustree --apply-function-cmd "wc -l" --apply-function-cmd-kind number

# Treat output as raw bytes
rustree --apply-function-cmd "md5sum" --apply-function-cmd-kind bytes
</code></pre>
<h3 id="command-timeout"><a class="header" href="#command-timeout">Command Timeout</a></h3>
<p>Set timeout for external commands:</p>
<pre><code class="language-bash"># Set 10-second timeout
rustree --apply-function-cmd "slow-analysis" --apply-timeout 10

# Quick timeout for fast commands
rustree --apply-function-cmd "grep -c pattern" --apply-timeout 2
</code></pre>
<p>Default timeout is 5 seconds.</p>
<h2 id="function-specific-filtering"><a class="header" href="#function-specific-filtering">Function-Specific Filtering</a></h2>
<h3 id="include-patterns-1"><a class="header" href="#include-patterns-1">Include Patterns</a></h3>
<p>Apply functions only to files/directories matching patterns:</p>
<pre><code class="language-bash"># Apply cat only to configuration files
rustree --apply-function cat --apply-include "*.toml|*.yml|*.json"

# Count pluses only in source code
rustree --apply-function count-pluses --apply-include "*.rs|*.js|*.py"

# Directory stats for source directories only  
rustree --apply-function dir-stats --apply-include "src*|lib*"
</code></pre>
<h3 id="exclude-patterns-1"><a class="header" href="#exclude-patterns-1">Exclude Patterns</a></h3>
<p>Skip applying functions to matching files/directories:</p>
<pre><code class="language-bash"># Apply cat but exclude temporary files
rustree --apply-function cat --apply-exclude "*.tmp|*.log"

# Directory stats excluding build directories
rustree --apply-function dir-stats --apply-exclude "target/*|build/*"
</code></pre>
<h3 id="pattern-files-1"><a class="header" href="#pattern-files-1">Pattern Files</a></h3>
<p>Use files to specify include/exclude patterns:</p>
<p>Create <code>apply-include.txt</code>:</p>
<pre><code># Include source files
*.rs
*.js
*.py

# Include configs  
*.toml
*.yml
</code></pre>
<p>Create <code>apply-exclude.txt</code>:</p>
<pre><code># Exclude tests
*test*
*Test*

# Exclude temp files
*.tmp
*.bak
</code></pre>
<p>Use the files:</p>
<pre><code class="language-bash">rustree --apply-function cat \
        --apply-include-from ./apply-include.txt \
        --apply-exclude-from ./apply-exclude.txt
</code></pre>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="combining-with-other-features"><a class="header" href="#combining-with-other-features">Combining with Other Features</a></h3>
<p>Apply functions work seamlessly with other RusTree features:</p>
<pre><code class="language-bash"># Apply function with filtering and sorting
rustree --apply-function count-pluses \
        -P "*.rs" \
        --sort-by custom -r \
        --depth 3

# External command with metadata
rustree --apply-function-cmd "wc -l" \
        --apply-function-cmd-kind number \
        --show-size-bytes \
        --sort-by custom

# Directory analysis with full metadata
rustree --apply-function dir-stats \
        --show-size-bytes \
        --show-last-modified \
        --sort-by custom -r
</code></pre>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<p>For large projects, optimize apply function usage:</p>
<pre><code class="language-bash"># Limit depth to improve performance
rustree --apply-function cat --depth 2

# Use specific filtering to reduce scope
rustree --apply-function-cmd "analyze" \
        --apply-include "*.rs" \
        --apply-exclude "**/target/**"

# Set shorter timeout for fast commands
rustree --apply-function-cmd "grep -c pattern" \
        --apply-timeout 1
</code></pre>
<h2 id="sorting-by-function-output"><a class="header" href="#sorting-by-function-output">Sorting by Function Output</a></h2>
<p>Sort the tree by apply function results:</p>
<pre><code class="language-bash"># Sort by count-pluses output (highest first)
rustree --apply-function count-pluses --sort-by custom -r

# Sort by directory statistics  
rustree --apply-function dir-stats --sort-by custom

# Sort by external command output
rustree --apply-function-cmd "wc -l" --sort-by custom -r
</code></pre>
<p>See <a href="cli_usage/./sorting_and_ordering.html">Sorting and Ordering</a> for more details.</p>
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h2>
<h3 id="code-analysis"><a class="header" href="#code-analysis">Code Analysis</a></h3>
<pre><code class="language-bash"># Find files with the most TODO comments
rustree --apply-function-cmd "grep -c 'TODO'" \
        --apply-function-cmd-kind number \
        -P "*.rs|*.js|*.py" \
        --sort-by custom -r

# Analyze complexity by line count
rustree --apply-function-cmd "wc -l" \
        --apply-function-cmd-kind number \
        --apply-include "*.rs" \
        --sort-by custom -r
</code></pre>
<h3 id="configuration-management"><a class="header" href="#configuration-management">Configuration Management</a></h3>
<pre><code class="language-bash"># Display all configuration files
rustree --apply-function cat \
        --apply-include "*.toml|*.yml|*.json|*.ini" \
        --depth 2

# Find large config files
rustree --apply-function-cmd "wc -c" \
        --apply-function-cmd-kind number \
        --apply-include "*.config|*.conf" \
        --sort-by custom -r
</code></pre>
<h3 id="project-statistics"><a class="header" href="#project-statistics">Project Statistics</a></h3>
<pre><code class="language-bash"># Comprehensive directory analysis
rustree --apply-function dir-stats \
        --show-size-bytes \
        --apply-exclude "**/target/**" \
        --apply-exclude "**/node_modules/**" \
        --sort-by custom -r

# Find directories with most files
rustree --apply-function count-files \
        --directory-only \
        --sort-by custom -r \
        --depth 3
</code></pre>
<h3 id="documentation-review"><a class="header" href="#documentation-review">Documentation Review</a></h3>
<pre><code class="language-bash"># Review all markdown documentation
rustree --apply-function cat \
        --apply-include "*.md|README*" \
        --depth 3

# Find largest documentation files
rustree --apply-function-cmd "wc -w" \
        --apply-function-cmd-kind number \
        --apply-include "*.md" \
        --sort-by custom -r
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="command-failures"><a class="header" href="#command-failures">Command Failures</a></h3>
<p>When external commands fail:</p>
<ul>
<li>Error output is captured and displayed</li>
<li>Tree generation continues for other files</li>
<li>Failed commands show error message in output</li>
</ul>
<h3 id="timeout-handling"><a class="header" href="#timeout-handling">Timeout Handling</a></h3>
<p>When commands exceed timeout:</p>
<ul>
<li>Command is terminated</li>
<li>Timeout message is displayed</li>
<li>Processing continues with remaining files</li>
</ul>
<h3 id="file-access-issues"><a class="header" href="#file-access-issues">File Access Issues</a></h3>
<p>When files can't be read:</p>
<ul>
<li>Built-in functions skip unreadable files</li>
<li>External commands receive empty input</li>
<li>Warning messages may be displayed</li>
</ul>
<h2 id="quick-reference-4"><a class="header" href="#quick-reference-4">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--apply-function &lt;FUNCTION&gt;</code></td><td>Apply built-in function (cat, count-pluses, dir-stats, etc.)</td></tr>
<tr><td><code>--apply-function-cmd &lt;CMD&gt;</code></td><td>Apply external command to files</td></tr>
<tr><td><code>--apply-function-cmd-kind &lt;KIND&gt;</code></td><td>Command output type (text, number, bytes)</td></tr>
<tr><td><code>--apply-timeout &lt;SECONDS&gt;</code></td><td>Timeout for external commands (default: 5)</td></tr>
<tr><td><code>--apply-include &lt;PATTERN&gt;</code></td><td>Apply function only to matching files/dirs</td></tr>
<tr><td><code>--apply-exclude &lt;PATTERN&gt;</code></td><td>Skip function for matching files/dirs</td></tr>
<tr><td><code>--apply-include-from &lt;FILE&gt;</code></td><td>Read include patterns from file</td></tr>
<tr><td><code>--apply-exclude-from &lt;FILE&gt;</code></td><td>Read exclude patterns from file</td></tr>
</tbody></table>
</div>
<h3 id="built-in-functions-1"><a class="header" href="#built-in-functions-1">Built-in Functions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>cat</code></td><td>File</td><td>Display complete file contents</td></tr>
<tr><td><code>count-pluses</code></td><td>File</td><td>Count '+' characters in files</td></tr>
<tr><td><code>count-files</code></td><td>Directory</td><td>Count files in directories</td></tr>
<tr><td><code>count-dirs</code></td><td>Directory</td><td>Count subdirectories</td></tr>
<tr><td><code>size-total</code></td><td>Directory</td><td>Calculate total size (needs <code>--show-size-bytes</code>)</td></tr>
<tr><td><code>dir-stats</code></td><td>Directory</td><td>Combined stats (files, dirs, size)</td></tr>
</tbody></table>
</div>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<p>See the <a href="cli_usage/./examples.html">Examples</a> page for more detailed apply function scenarios and real-world use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorting-and-ordering"><a class="header" href="#sorting-and-ordering">Sorting and Ordering</a></h1>
<p>RusTree provides flexible sorting options to organize tree output by various criteria. You can sort by name, size, timestamps, content analysis results, or custom function output.</p>
<h2 id="basic-sorting"><a class="header" href="#basic-sorting">Basic Sorting</a></h2>
<h3 id="default-behavior"><a class="header" href="#default-behavior">Default Behavior</a></h3>
<p>By default, RusTree sorts entries alphabetically by name:</p>
<pre><code class="language-bash"># Default alphabetical sorting
rustree
</code></pre>
<h3 id="disable-sorting"><a class="header" href="#disable-sorting">Disable Sorting</a></h3>
<p>Display entries in directory order (as they appear on disk):</p>
<pre><code class="language-bash"># No sorting - directory order
rustree -U

# Long form
rustree --unsorted

# Alternative form
rustree --sort-by none
</code></pre>
<h2 id="sort-by-name"><a class="header" href="#sort-by-name">Sort by Name</a></h2>
<h3 id="alphabetical-sorting"><a class="header" href="#alphabetical-sorting">Alphabetical Sorting</a></h3>
<pre><code class="language-bash"># Explicit alphabetical sorting (default)
rustree --sort-by name
</code></pre>
<h3 id="version-sorting"><a class="header" href="#version-sorting">Version Sorting</a></h3>
<p>Sort by version numbers embedded in filenames:</p>
<pre><code class="language-bash"># Version-aware sorting (file-1.0.0 before file-1.10.0)
rustree -v

# Long form
rustree --sort-by version
</code></pre>
<p>This is useful for files with version numbers where you want proper numerical ordering instead of lexicographic ordering.</p>
<h2 id="sort-by-size"><a class="header" href="#sort-by-size">Sort by Size</a></h2>
<h3 id="file-size-sorting"><a class="header" href="#file-size-sorting">File Size Sorting</a></h3>
<p>Sort by file size (requires size information):</p>
<pre><code class="language-bash"># Sort by size (largest first)
rustree --show-size-bytes --sort-by size

# Sort by size (smallest first) 
rustree -s --sort-by size --reverse-sort
</code></pre>
<p><strong>Note:</strong> You must enable <code>--show-size-bytes</code> for size sorting to work.</p>
<h2 id="sort-by-time"><a class="header" href="#sort-by-time">Sort by Time</a></h2>
<h3 id="modification-time"><a class="header" href="#modification-time">Modification Time</a></h3>
<p>Sort by when files were last modified:</p>
<pre><code class="language-bash"># Sort by modification time (oldest first)
rustree -t

# Long form
rustree --sort-by mtime

# Newest first
rustree -t -r
</code></pre>
<h3 id="change-time"><a class="header" href="#change-time">Change Time</a></h3>
<p>Sort by when file metadata was last changed:</p>
<pre><code class="language-bash"># Sort by change time (oldest first)
rustree -c

# Long form  
rustree --sort-by change_time

# Show change times when using this sort
rustree -c -D
</code></pre>
<h3 id="creation-time"><a class="header" href="#creation-time">Creation Time</a></h3>
<p>Sort by file creation time (where supported):</p>
<pre><code class="language-bash"># Sort by creation time
rustree --sort-by create_time

# Newest created files first
rustree --sort-by create_time --reverse-sort
</code></pre>
<h2 id="sort-by-content-analysis"><a class="header" href="#sort-by-content-analysis">Sort by Content Analysis</a></h2>
<h3 id="line-count-sorting"><a class="header" href="#line-count-sorting">Line Count Sorting</a></h3>
<p>Sort by number of lines in files (requires line counting):</p>
<pre><code class="language-bash"># Sort by line count (most lines first)
rustree --calculate-lines --sort-by lines

# Fewest lines first
rustree --calculate-lines --sort-by lines --reverse-sort
</code></pre>
<h3 id="word-count-sorting"><a class="header" href="#word-count-sorting">Word Count Sorting</a></h3>
<p>Sort by number of words in files (requires word counting):</p>
<pre><code class="language-bash"># Sort by word count (most words first)
rustree --calculate-words --sort-by words

# Fewest words first
rustree --calculate-words --sort-by words -r
</code></pre>
<h2 id="sort-by-custom-functions"><a class="header" href="#sort-by-custom-functions">Sort by Custom Functions</a></h2>
<h3 id="apply-function-results"><a class="header" href="#apply-function-results">Apply Function Results</a></h3>
<p>Sort by the output of apply functions:</p>
<pre><code class="language-bash"># Sort by count-pluses output (most '+' characters first)
rustree --apply-function count-pluses --sort-by custom -r

# Sort by directory statistics
rustree --apply-function dir-stats --sort-by custom

# Sort by external command output
rustree --apply-function-cmd "wc -l" --sort-by custom -r
</code></pre>
<h2 id="reverse-sorting"><a class="header" href="#reverse-sorting">Reverse Sorting</a></h2>
<h3 id="reverse-any-sort-order"><a class="header" href="#reverse-any-sort-order">Reverse Any Sort Order</a></h3>
<p>Add <code>-r</code> or <code>--reverse-sort</code> to reverse any sort:</p>
<pre><code class="language-bash"># Reverse alphabetical (Z to A)
rustree -r

# Largest files first
rustree -s --sort-by size -r

# Newest modifications first  
rustree -t -r

# Most complex files first (by line count)
rustree --calculate-lines --sort-by lines -r
</code></pre>
<h2 id="directory-vs-file-ordering"><a class="header" href="#directory-vs-file-ordering">Directory vs File Ordering</a></h2>
<h3 id="directories-first"><a class="header" href="#directories-first">Directories First</a></h3>
<p>Show all directories before files at each level:</p>
<pre><code class="language-bash"># Directories before files
rustree --dirs-first

# Combine with other sorting
rustree --dirs-first --sort-by size -r
</code></pre>
<h3 id="files-first"><a class="header" href="#files-first">Files First</a></h3>
<p>Show all files before directories at each level:</p>
<pre><code class="language-bash"># Files before directories
rustree --files-first

# Combine with sorting
rustree --files-first --sort-by mtime -r
</code></pre>
<p><strong>Note:</strong> <code>--dirs-first</code> and <code>--files-first</code> are mutually exclusive.</p>
<h2 id="sort-conflicts-and-precedence"><a class="header" href="#sort-conflicts-and-precedence">Sort Conflicts and Precedence</a></h2>
<h3 id="single-letter-sort-options"><a class="header" href="#single-letter-sort-options">Single-Letter Sort Options</a></h3>
<p>The single-letter sort options (<code>-t</code>, <code>-c</code>, <code>-v</code>, <code>-U</code>) conflict with each other and with <code>--sort-by</code>:</p>
<pre><code class="language-bash"># These conflict - only the last one applies
rustree -t -c -v    # Only -v (version) applies

# Use --sort-by for explicit control
rustree --sort-by mtime
</code></pre>
<h3 id="sort-order-precedence"><a class="header" href="#sort-order-precedence">Sort Order Precedence</a></h3>
<ol>
<li><code>--sort-by</code> takes precedence over single-letter options</li>
<li><code>-U</code> (unsorted) disables all other sorting</li>
<li><code>-r</code> applies to whatever sort is active</li>
</ol>
<h2 id="complex-sorting-examples"><a class="header" href="#complex-sorting-examples">Complex Sorting Examples</a></h2>
<h3 id="multi-criteria-analysis"><a class="header" href="#multi-criteria-analysis">Multi-Criteria Analysis</a></h3>
<pre><code class="language-bash"># Large source files with most lines first
rustree --show-size-bytes --calculate-lines \
        -P "*.rs|*.js|*.py" \
        --sort-by lines -r \
        --dirs-first

# Recently modified large files
rustree -s -D --sort-by mtime -r \
        --min-file-size 1M \
        --files-first

# Complex directories by statistics
rustree --apply-function dir-stats \
        --directory-only \
        --sort-by custom -r \
        --depth 2
</code></pre>
<h3 id="combining-with-filtering"><a class="header" href="#combining-with-filtering">Combining with Filtering</a></h3>
<pre><code class="language-bash"># Largest documentation files
rustree -s -P "*.md|*.txt" \
        --sort-by size -r \
        --max-file-size 1M

# Most recently changed configuration
rustree -c -D --sort-by change_time -r \
        -P "*.toml|*.yml|*.json"

# Source files by complexity
rustree --calculate-lines --calculate-words \
        -P "*.rs" \
        --sort-by lines -r \
        --apply-exclude "**/target/**"
</code></pre>
<h2 id="performance-considerations-2"><a class="header" href="#performance-considerations-2">Performance Considerations</a></h2>
<h3 id="expensive-sorts"><a class="header" href="#expensive-sorts">Expensive Sorts</a></h3>
<p>Some sorts require additional processing:</p>
<ul>
<li><strong>Size sorting</strong>: Requires reading file metadata</li>
<li><strong>Content analysis sorting</strong>: Requires reading and analyzing file contents</li>
<li><strong>Custom function sorting</strong>: Depends on function complexity</li>
</ul>
<p>Consider using <a href="cli_usage/./filtering_and_patterns.html">filtering</a> to reduce the number of files processed:</p>
<pre><code class="language-bash"># Efficient: filter first, then sort
rustree --calculate-lines -P "*.rs" --sort-by lines -r

# Less efficient: sort everything, then filter might happen later
rustree --calculate-lines --sort-by lines -r
</code></pre>
<h3 id="large-directory-optimization"><a class="header" href="#large-directory-optimization">Large Directory Optimization</a></h3>
<p>For large directories:</p>
<pre><code class="language-bash"># Limit depth to improve performance
rustree --sort-by size -r --depth 2

# Use directory-only for structure analysis
rustree --sort-by size -r --directory-only

# Combine with pruning
rustree --sort-by lines -r --prune-empty-directories
</code></pre>
<h2 id="integration-with-other-features-3"><a class="header" href="#integration-with-other-features-3">Integration with Other Features</a></h2>
<h3 id="output-formats"><a class="header" href="#output-formats">Output Formats</a></h3>
<p>Sorting works with all output formats:</p>
<pre><code class="language-bash"># Sorted JSON output
rustree --sort-by size -r --output-format json

# Sorted Markdown
rustree --sort-by mtime -r --output-format markdown
</code></pre>
<h3 id="metadata-display"><a class="header" href="#metadata-display">Metadata Display</a></h3>
<p>Show relevant metadata for your sort criteria:</p>
<pre><code class="language-bash"># Show sizes when sorting by size
rustree -s --sort-by size -r

# Show times when sorting by time
rustree -D --sort-by mtime -r

# Show line counts when sorting by lines
rustree --calculate-lines --sort-by lines -r
</code></pre>
<h2 id="quick-reference-5"><a class="header" href="#quick-reference-5">Quick Reference</a></h2>
<h3 id="sort-keys"><a class="header" href="#sort-keys">Sort Keys</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--sort-by name</code></td><td>(default)</td><td>Alphabetical sorting</td></tr>
<tr><td><code>--sort-by version</code></td><td><code>-v</code></td><td>Version-aware sorting</td></tr>
<tr><td><code>--sort-by size</code></td><td></td><td>Sort by file size (needs <code>--show-size-bytes</code>)</td></tr>
<tr><td><code>--sort-by mtime</code></td><td><code>-t</code></td><td>Sort by modification time</td></tr>
<tr><td><code>--sort-by change_time</code></td><td><code>-c</code></td><td>Sort by change time</td></tr>
<tr><td><code>--sort-by create_time</code></td><td></td><td>Sort by creation time</td></tr>
<tr><td><code>--sort-by lines</code></td><td></td><td>Sort by line count (needs <code>--calculate-lines</code>)</td></tr>
<tr><td><code>--sort-by words</code></td><td></td><td>Sort by word count (needs <code>--calculate-words</code>)</td></tr>
<tr><td><code>--sort-by custom</code></td><td></td><td>Sort by apply function output</td></tr>
<tr><td><code>--sort-by none</code></td><td><code>-U</code></td><td>No sorting (directory order)</td></tr>
</tbody></table>
</div>
<h3 id="sort-modifiers"><a class="header" href="#sort-modifiers">Sort Modifiers</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Short</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--reverse-sort</code></td><td><code>-r</code></td><td>Reverse the sort order</td></tr>
<tr><td><code>--dirs-first</code></td><td></td><td>Show directories before files</td></tr>
<tr><td><code>--files-first</code></td><td></td><td>Show files before directories</td></tr>
</tbody></table>
</div>
<h3 id="sort-direction-defaults"><a class="header" href="#sort-direction-defaults">Sort Direction Defaults</a></h3>
<ul>
<li><strong>Name/Version</strong>: A to Z (use <code>-r</code> for Z to A)</li>
<li><strong>Size</strong>: Largest first (use <code>-r</code> for smallest first)</li>
<li><strong>Time</strong>: Oldest first (use <code>-r</code> for newest first)</li>
<li><strong>Lines/Words</strong>: Most first (use <code>-r</code> for fewest first)</li>
<li><strong>Custom</strong>: Depends on function output type</li>
</ul>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<p>See the <a href="cli_usage/./examples.html">Examples</a> page for more detailed sorting scenarios and real-world use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-formats-1"><a class="header" href="#output-formats-1">Output Formats</a></h1>
<p>RusTree supports multiple output formats to suit different use cases, from human-readable text to structured data formats and web-ready HTML. This page covers all output format options and customization.</p>
<h2 id="available-formats"><a class="header" href="#available-formats">Available Formats</a></h2>
<h3 id="text-format-default"><a class="header" href="#text-format-default">Text Format (Default)</a></h3>
<p>The default tree-like text output:</p>
<pre><code class="language-bash"># Default text format
rustree

# Explicit text format
rustree --output-format text
</code></pre>
<p><strong>Example output:</strong></p>
<pre><code>my_project/
├── README.md
├── src/
│   ├── main.rs
│   └── lib.rs
└── tests/
    └── integration.rs

2 directories, 4 files
</code></pre>
<h3 id="markdown-format"><a class="header" href="#markdown-format">Markdown Format</a></h3>
<p>List-based Markdown output suitable for documentation:</p>
<pre><code class="language-bash"># Markdown format
rustree --output-format markdown
</code></pre>
<p><strong>Example output:</strong></p>
<pre><code class="language-markdown"># my_project

* README.md
* src/
  * main.rs
  * lib.rs
* tests/
  * integration.rs

__2 directories, 4 files total__
</code></pre>
<h3 id="json-format"><a class="header" href="#json-format">JSON Format</a></h3>
<p>Structured JSON data for programmatic processing:</p>
<pre><code class="language-bash"># JSON format
rustree --output-format json
</code></pre>
<p><strong>Example output:</strong></p>
<pre><code class="language-json">{
  "nodes": [
    {
      "path": "./README.md",
      "name": "README.md",
      "type": "file",
      "depth": 1,
      "size": 1024
    },
    {
      "path": "./src",
      "name": "src",
      "type": "directory", 
      "depth": 1
    }
  ],
  "summary": {
    "directories": 2,
    "files": 4,
    "total_size": 5120
  }
}
</code></pre>
<h3 id="html-format"><a class="header" href="#html-format">HTML Format</a></h3>
<p>Web-ready HTML with optional hyperlinks and customization:</p>
<pre><code class="language-bash"># Basic HTML format
rustree --output-format html

# HTML with hyperlinks
rustree --output-format html --html-base-href https://example.com/repo
</code></pre>
<h2 id="summary-report-control"><a class="header" href="#summary-report-control">Summary Report Control</a></h2>
<h3 id="disable-summary"><a class="header" href="#disable-summary">Disable Summary</a></h3>
<p>Remove the summary line from output:</p>
<pre><code class="language-bash"># No summary report
rustree --no-summary-report

# Useful for clean Markdown documentation
rustree --output-format markdown --no-summary-report &gt; structure.md
</code></pre>
<h3 id="enhanced-summary-with-metadata"><a class="header" href="#enhanced-summary-with-metadata">Enhanced Summary with Metadata</a></h3>
<p>When using metadata options, the summary automatically includes totals:</p>
<pre><code class="language-bash"># Enhanced summary with aggregated metadata
rustree --calculate-lines --calculate-words --show-size-bytes
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>my_project/
├── [1024B] [L: 50] [W: 250] README.md
└── src/
    └── [2048B] [L: 100] [W: 500] main.rs

1 directory, 2 files, 150 total lines, 750 total words, 3.1 KB total
</code></pre>
<h2 id="html-customization"><a class="header" href="#html-customization">HTML Customization</a></h2>
<h3 id="base-url-for-links"><a class="header" href="#base-url-for-links">Base URL for Links</a></h3>
<p>Create clickable links in HTML output:</p>
<pre><code class="language-bash"># Add base URL to all links
rustree --output-format html --html-base-href https://github.com/user/repo/blob/main

# Local file links
rustree --output-format html --html-base-href file:///path/to/project
</code></pre>
<h3 id="strip-path-components"><a class="header" href="#strip-path-components">Strip Path Components</a></h3>
<p>Remove leading path components from links:</p>
<pre><code class="language-bash"># Scan subdirectory but link to parent paths
rustree src/ --output-format html \
       --html-base-href https://example.com \
       --html-strip-first-component
</code></pre>
<p>This is useful when scanning a subdirectory but wanting links to be relative to the parent.</p>
<h3 id="disable-links"><a class="header" href="#disable-links">Disable Links</a></h3>
<p>Generate HTML without hyperlinks:</p>
<pre><code class="language-bash"># Plain HTML without &lt;a&gt; tags
rustree --output-format html --html-no-links
</code></pre>
<h3 id="custom-html-templates"><a class="header" href="#custom-html-templates">Custom HTML Templates</a></h3>
<h4 id="custom-header"><a class="header" href="#custom-header">Custom Header</a></h4>
<p>Replace the default HTML header:</p>
<pre><code class="language-bash"># Use custom intro HTML
rustree --output-format html --html-intro-file ./templates/header.html

# Suppress header entirely
rustree --output-format html --html-intro-file /dev/null
</code></pre>
<h4 id="custom-footer"><a class="header" href="#custom-footer">Custom Footer</a></h4>
<p>Replace the default HTML footer:</p>
<pre><code class="language-bash"># Use custom outro HTML  
rustree --output-format html --html-outro-file ./templates/footer.html

# Suppress footer entirely
rustree --output-format html --html-outro-file /dev/null
</code></pre>
<h2 id="format-specific-features"><a class="header" href="#format-specific-features">Format-Specific Features</a></h2>
<h3 id="json-with-metadata"><a class="header" href="#json-with-metadata">JSON with Metadata</a></h3>
<p>JSON format includes all collected metadata:</p>
<pre><code class="language-bash"># Rich JSON with full metadata
rustree --output-format json \
        --show-size-bytes \
        --calculate-lines \
        --show-last-modified
</code></pre>
<h3 id="markdown-with-metadata"><a class="header" href="#markdown-with-metadata">Markdown with Metadata</a></h3>
<p>Metadata appears inline in Markdown format:</p>
<pre><code class="language-bash"># Markdown with file sizes and line counts
rustree --output-format markdown \
        --show-size-bytes \
        --calculate-lines \
        --human-friendly
</code></pre>
<h3 id="json-processing"><a class="header" href="#json-processing">JSON Processing</a></h3>
<p>Use JSON output with external tools:</p>
<pre><code class="language-bash"># Pretty-print JSON
rustree --output-format json | jq '.'

# Extract specific information
rustree --output-format json | jq '.nodes[] | select(.type == "file") | .name'

# Get file count
rustree --output-format json | jq '.summary.files'

# Find large files
rustree --output-format json --show-size-bytes | \
  jq '.nodes[] | select(.size &gt; 1000000) | .path'
</code></pre>
<h2 id="llm-integration-with-formats"><a class="header" href="#llm-integration-with-formats">LLM Integration with Formats</a></h2>
<h3 id="combined-json-output"><a class="header" href="#combined-json-output">Combined JSON Output</a></h3>
<p>When using LLM features with JSON format, both tree and LLM data are included:</p>
<pre><code class="language-bash"># Tree + LLM analysis in single JSON
rustree --output-format json \
        --llm-ask "Analyze this project structure" \
        --dry-run
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-json">{
  "tree": {
    "nodes": [...],
    "summary": {...}
  },
  "llm": {
    "dry_run": true,
    "request": {...},
    "question": "Analyze this project structure"
  }
}
</code></pre>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="documentation-generation"><a class="header" href="#documentation-generation">Documentation Generation</a></h3>
<pre><code class="language-bash"># Clean Markdown for documentation
rustree docs/ --output-format markdown \
       --no-summary-report \
       --depth 3 &gt; docs-structure.md

# HTML for web documentation
rustree --output-format html \
        --html-base-href https://docs.example.com \
        --html-intro-file ./templates/docs-header.html \
        --depth 2 &gt; docs-index.html
</code></pre>
<h3 id="data-processing"><a class="header" href="#data-processing">Data Processing</a></h3>
<pre><code class="language-bash"># Generate data for analysis
rustree --output-format json \
        --show-size-bytes \
        --calculate-lines &gt; project-data.json

# Process with jq
cat project-data.json | jq '.nodes[] | select(.lines &gt; 100)'
</code></pre>
<h3 id="web-publishing"><a class="header" href="#web-publishing">Web Publishing</a></h3>
<pre><code class="language-bash"># Complete web page with navigation
rustree src/ --output-format html \
       --html-base-href https://github.com/user/repo/tree/main/src \
       --html-intro-file ./web/header.html \
       --html-outro-file ./web/footer.html \
       --show-size-bytes --human-friendly &gt; src-browser.html
</code></pre>
<h3 id="archival-and-reporting"><a class="header" href="#archival-and-reporting">Archival and Reporting</a></h3>
<pre><code class="language-bash"># Comprehensive project snapshot
rustree --output-format json \
        --show-size-bytes \
        --show-last-modified \
        --calculate-lines \
        --calculate-words &gt; "snapshot-$(date +%Y%m%d).json"

# Human-readable report
rustree --output-format markdown \
        --show-size-bytes --human-friendly \
        --calculate-lines \
        --sort-by size -r &gt; project-report.md
</code></pre>
<h2 id="format-compatibility"><a class="header" href="#format-compatibility">Format Compatibility</a></h2>
<h3 id="cross-format-workflows"><a class="header" href="#cross-format-workflows">Cross-Format Workflows</a></h3>
<pre><code class="language-bash"># Generate in multiple formats
rustree --output-format json &gt; data.json
rustree --output-format markdown &gt; structure.md  
rustree --output-format html &gt; browser.html

# Convert between formats using external tools
rustree --output-format json | jq -r '.nodes[].path' &gt; file-list.txt
</code></pre>
<h3 id="integration-with-external-tools"><a class="header" href="#integration-with-external-tools">Integration with External Tools</a></h3>
<pre><code class="language-bash"># Feed to other analysis tools
rustree --output-format json | python analyze-structure.py

# Generate reports
rustree --output-format markdown | pandoc -o report.pdf

# Create web assets
rustree --output-format html --html-no-links | \
  sed 's/&lt;pre&gt;/&lt;pre class="tree-view"&gt;/' &gt; styled-tree.html
</code></pre>
<h2 id="quick-reference-6"><a class="header" href="#quick-reference-6">Quick Reference</a></h2>
<h3 id="format-options"><a class="header" href="#format-options">Format Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--output-format text</code></td><td>Default tree-like text output</td></tr>
<tr><td><code>--output-format markdown</code></td><td>Markdown list format</td></tr>
<tr><td><code>--output-format json</code></td><td>Structured JSON data</td></tr>
<tr><td><code>--output-format html</code></td><td>Web-ready HTML</td></tr>
</tbody></table>
</div>
<h3 id="summary-control"><a class="header" href="#summary-control">Summary Control</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--no-summary-report</code></td><td>Omit the summary line from output</td></tr>
</tbody></table>
</div>
<h3 id="html-specific-options"><a class="header" href="#html-specific-options">HTML-Specific Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--html-base-href &lt;URL&gt;</code></td><td>Base URL for generated hyperlinks</td></tr>
<tr><td><code>--html-strip-first-component</code></td><td>Remove first path component from links</td></tr>
<tr><td><code>--html-no-links</code></td><td>Disable hyperlink generation</td></tr>
<tr><td><code>--html-intro-file &lt;FILE&gt;</code></td><td>Custom HTML header template</td></tr>
<tr><td><code>--html-outro-file &lt;FILE&gt;</code></td><td>Custom HTML footer template</td></tr>
</tbody></table>
</div>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<p>See the <a href="cli_usage/./examples.html">Examples</a> page for more detailed output format scenarios and integration examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="llm-integration"><a class="header" href="#llm-integration">LLM Integration</a></h1>
<p>RusTree includes powerful AI integration capabilities, allowing you to analyze project structures using Large Language Models (LLMs). You can either export formatted queries for external tools or directly interact with LLM services.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<h3 id="basic-llm-query"><a class="header" href="#basic-llm-query">Basic LLM Query</a></h3>
<p>Ask a question directly to an LLM service:</p>
<pre><code class="language-bash"># Basic analysis with OpenAI (default provider)
rustree --llm-ask "What's the architecture of this project?"

# With environment variable for API key
export OPENAI_API_KEY="your-api-key"
rustree --llm-ask "Analyze the code organization"
</code></pre>
<h3 id="generate-api-key-template"><a class="header" href="#generate-api-key-template">Generate API Key Template</a></h3>
<p>Set up your environment variables:</p>
<pre><code class="language-bash"># Generate .env template
rustree --llm-generate-env &gt; .env

# Edit the .env file to add your API keys
# Then source it: source .env
</code></pre>
<h2 id="llm-providers"><a class="header" href="#llm-providers">LLM Providers</a></h2>
<h3 id="openai-default"><a class="header" href="#openai-default">OpenAI (Default)</a></h3>
<pre><code class="language-bash"># Default OpenAI usage
rustree --llm-ask "Describe this project structure"

# Specify model explicitly
rustree --llm-ask "Code review analysis" --llm-model gpt-4

# Use GPT-3.5 for faster/cheaper analysis
rustree --llm-ask "Quick overview" --llm-model gpt-3.5-turbo
</code></pre>
<p><strong>Environment variable:</strong> <code>OPENAI_API_KEY</code></p>
<h3 id="anthropic-claude"><a class="header" href="#anthropic-claude">Anthropic (Claude)</a></h3>
<pre><code class="language-bash"># Use Claude for analysis
rustree --llm-ask "What patterns do you see?" --llm-provider anthropic

# Specify Claude model
rustree --llm-ask "Security review" \
        --llm-provider anthropic \
        --llm-model claude-3-sonnet-20240229
</code></pre>
<p><strong>Environment variable:</strong> <code>ANTHROPIC_API_KEY</code></p>
<h3 id="cohere"><a class="header" href="#cohere">Cohere</a></h3>
<pre><code class="language-bash"># Use Cohere for analysis
rustree --llm-ask "Summarize the codebase" --llm-provider cohere

# Specify Cohere model
rustree --llm-ask "Architecture analysis" \
        --llm-provider cohere \
        --llm-model command-r
</code></pre>
<p><strong>Environment variable:</strong> <code>COHERE_API_KEY</code></p>
<h3 id="openrouter-multi-provider"><a class="header" href="#openrouter-multi-provider">OpenRouter (Multi-Provider)</a></h3>
<pre><code class="language-bash"># Use OpenRouter for access to multiple models
rustree --llm-ask "Compare this with best practices" \
        --llm-provider openrouter

# Use specific model through OpenRouter
rustree --llm-ask "Performance analysis" \
        --llm-provider openrouter \
        --llm-model anthropic/claude-3-haiku
</code></pre>
<p><strong>Environment variable:</strong> <code>OPENROUTER_API_KEY</code></p>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<h3 id="api-key-management"><a class="header" href="#api-key-management">API Key Management</a></h3>
<p>Multiple ways to provide API keys:</p>
<pre><code class="language-bash"># Command line (not recommended for security)
rustree --llm-ask "Question" --llm-api-key "your-key"

# Environment variable (recommended)
export OPENAI_API_KEY="your-key"
rustree --llm-ask "Question"

# .env file (recommended for development)
echo 'OPENAI_API_KEY=your-key' &gt;&gt; .env
rustree --llm-ask "Question"
</code></pre>
<h3 id="response-control"><a class="header" href="#response-control">Response Control</a></h3>
<h4 id="temperature"><a class="header" href="#temperature">Temperature</a></h4>
<p>Control response randomness (0.0 = deterministic, 2.0 = very random):</p>
<pre><code class="language-bash"># Precise, deterministic analysis
rustree --llm-ask "Security audit" --llm-temperature 0.1

# Balanced analysis (default: 0.7)
rustree --llm-ask "Code review"

# Creative, varied analysis  
rustree --llm-ask "Suggest improvements" --llm-temperature 1.2
</code></pre>
<h4 id="response-length"><a class="header" href="#response-length">Response Length</a></h4>
<p>Control maximum response length:</p>
<pre><code class="language-bash"># Brief response
rustree --llm-ask "Quick summary" --llm-max-tokens 200

# Standard response (default: 1000)
rustree --llm-ask "Analyze architecture"

# Detailed analysis
rustree --llm-ask "Comprehensive review" --llm-max-tokens 3000
</code></pre>
<h3 id="custom-endpoints"><a class="header" href="#custom-endpoints">Custom Endpoints</a></h3>
<p>Use custom or self-hosted endpoints:</p>
<pre><code class="language-bash"># Custom OpenAI-compatible endpoint
rustree --llm-ask "Analysis" \
        --llm-endpoint "https://api.custom.com/v1"

# Local AI service
rustree --llm-ask "Local analysis" \
        --llm-endpoint "http://localhost:8080/v1"
</code></pre>
<h2 id="export-for-external-tools"><a class="header" href="#export-for-external-tools">Export for External Tools</a></h2>
<h3 id="generate-formatted-queries"><a class="header" href="#generate-formatted-queries">Generate Formatted Queries</a></h3>
<p>Create formatted queries for external LLM tools:</p>
<pre><code class="language-bash"># Export for external tools
rustree --llm-export "What are the main components?"

# Pipe to external LLM tools
rustree --llm-export "Code quality assessment" | claude-cli
rustree --llm-export "Security review" | ollama run mistral
rustree --llm-export "Performance analysis" &gt; analysis-prompt.txt
</code></pre>
<h3 id="export-vs-direct-query"><a class="header" href="#export-vs-direct-query">Export vs Direct Query</a></h3>
<ul>
<li><strong><code>--llm-export</code></strong>: Formats output for external tools, preserves original behavior</li>
<li><strong><code>--llm-ask</code></strong>: Direct integration with LLM services</li>
</ul>
<h2 id="request-preview-and-debugging"><a class="header" href="#request-preview-and-debugging">Request Preview and Debugging</a></h2>
<h3 id="dry-run-mode"><a class="header" href="#dry-run-mode">Dry Run Mode</a></h3>
<p>Preview requests without making API calls:</p>
<pre><code class="language-bash"># Preview what would be sent (no cost)
rustree --llm-ask "Analyze architecture" --dry-run

# Human-readable preview format
rustree --llm-ask "Security review" --dry-run --human-friendly

# Preview with specific settings
rustree --llm-ask "Performance analysis" \
        --llm-provider anthropic \
        --llm-model claude-3-haiku \
        --llm-temperature 0.3 \
        --dry-run --human-friendly
</code></pre>
<h3 id="token-estimation"><a class="header" href="#token-estimation">Token Estimation</a></h3>
<p>Dry run mode provides rough token estimates:</p>
<pre><code class="language-bash">rustree --llm-ask "Detailed analysis" \
        --llm-max-tokens 2000 \
        --dry-run
</code></pre>
<p><strong>Note:</strong> Token estimates use a 4:1 character-to-token ratio and are approximate. Actual usage may vary significantly.</p>
<h2 id="combining-with-tree-features"><a class="header" href="#combining-with-tree-features">Combining with Tree Features</a></h2>
<h3 id="filtered-analysis"><a class="header" href="#filtered-analysis">Filtered Analysis</a></h3>
<p>Analyze specific parts of your project:</p>
<pre><code class="language-bash"># Analyze only source code
rustree --llm-ask "Review the code quality" \
        --filter-include "*.rs" \
        --filter-exclude "**/target/**"

# Focus on documentation
rustree --llm-ask "How well documented is this?" \
        --filter-include "*.md" "README*"

# Analyze configuration
rustree --llm-ask "Review configuration setup" \
        --filter-include "*.toml" "*.yml" "*.json"
</code></pre>
<h3 id="depth-limited-analysis"><a class="header" href="#depth-limited-analysis">Depth-Limited Analysis</a></h3>
<p>Control scope for large projects:</p>
<pre><code class="language-bash"># High-level architecture analysis
rustree --llm-ask "What's the overall structure?" \
        --depth 2 --directory-only

# Detailed module analysis
rustree --llm-ask "Analyze module organization" \
        --depth 4 --filter-include "src/**"
</code></pre>
<h3 id="metadata-enhanced-analysis"><a class="header" href="#metadata-enhanced-analysis">Metadata-Enhanced Analysis</a></h3>
<p>Include file metadata in analysis:</p>
<pre><code class="language-bash"># Size-aware analysis
rustree --llm-ask "Which files seem overly large?" \
        --show-size-bytes --human-friendly \
        --sort-by size --reverse-sort

# Complexity analysis
rustree --llm-ask "Identify complex modules" \
        --calculate-lines --calculate-words \
        --sort-by lines --reverse-sort

# Recent changes analysis
rustree --llm-ask "What was recently modified?" \
        --show-last-modified \
        --sort-by mtime --reverse-sort
</code></pre>
<h2 id="advanced-use-cases"><a class="header" href="#advanced-use-cases">Advanced Use Cases</a></h2>
<h3 id="multi-step-analysis"><a class="header" href="#multi-step-analysis">Multi-Step Analysis</a></h3>
<pre><code class="language-bash"># Step 1: Preview and refine
rustree --llm-ask "Initial assessment" --dry-run --human-friendly

# Step 2: Export for review
rustree --llm-export "Refined question" &gt; prompt-for-review.txt

# Step 3: Direct analysis
rustree --llm-ask "Focused analysis based on preview" \
        --llm-temperature 0.3 \
        --llm-max-tokens 1500

# Step 4: Compare with external tools
rustree --llm-export "Cross-check analysis" | external-llm-tool
</code></pre>
<h3 id="different-providers-for-different-tasks"><a class="header" href="#different-providers-for-different-tasks">Different Providers for Different Tasks</a></h3>
<pre><code class="language-bash"># Quick overview with fast model
rustree --llm-ask "Project overview" \
        --llm-provider openai \
        --llm-model gpt-3.5-turbo

# Detailed security analysis with advanced model
rustree --llm-ask "Comprehensive security review" \
        --llm-provider anthropic \
        --llm-model claude-3-sonnet \
        --llm-temperature 0.2

# Creative improvement suggestions
rustree --llm-ask "How would you reorganize this?" \
        --llm-provider cohere \
        --llm-temperature 1.0
</code></pre>
<h3 id="json-output-with-llm"><a class="header" href="#json-output-with-llm">JSON Output with LLM</a></h3>
<p>Combine structured data with AI analysis:</p>
<pre><code class="language-bash"># Get both tree data and analysis in JSON
rustree --output-format json \
        --llm-ask "Analyze the structure" \
        --dry-run | jq '.'

# Process tree data, then analyze
rustree --output-format json --show-size-bytes &gt; data.json
rustree --llm-ask "Based on this data, what optimization opportunities exist?" \
        --from-tree-file data.json
</code></pre>
<h2 id="workflow-examples"><a class="header" href="#workflow-examples">Workflow Examples</a></h2>
<h3 id="code-review-workflow"><a class="header" href="#code-review-workflow">Code Review Workflow</a></h3>
<pre><code class="language-bash"># 1. Get overview
rustree --llm-ask "What type of project is this?" --depth 2

# 2. Analyze structure
rustree --llm-ask "How is the code organized?" \
        --filter-include "src/**" --depth 3

# 3. Check for issues
rustree --llm-ask "Are there any potential problems?" \
        --show-size-bytes --calculate-lines \
        --sort-by size --reverse-sort

# 4. Get suggestions
rustree --llm-ask "What improvements would you suggest?" \
        --llm-temperature 0.8 --llm-max-tokens 2000
</code></pre>
<h3 id="documentation-analysis"><a class="header" href="#documentation-analysis">Documentation Analysis</a></h3>
<pre><code class="language-bash"># Analyze documentation coverage
rustree --llm-ask "How well documented is this project?" \
        --filter-include "*.md" "*.txt" "README*" \
        --calculate-words

# Compare docs to code
rustree --llm-ask "Does the documentation match the code structure?" \
        --filter-include "*.md" "*.rs" \
        --depth 3
</code></pre>
<h3 id="performance-analysis"><a class="header" href="#performance-analysis">Performance Analysis</a></h3>
<pre><code class="language-bash"># Find potential performance issues
rustree --llm-ask "What might cause performance problems?" \
        --show-size-bytes --human-friendly \
        --calculate-lines \
        --min-file-size 10K

# Analyze module complexity
rustree --llm-ask "Which modules are most complex?" \
        --apply-function dir-stats \
        --directory-only \
        --sort-by custom --reverse-sort
</code></pre>
<h2 id="error-handling-and-troubleshooting"><a class="header" href="#error-handling-and-troubleshooting">Error Handling and Troubleshooting</a></h2>
<h3 id="api-key-issues"><a class="header" href="#api-key-issues">API Key Issues</a></h3>
<pre><code class="language-bash"># Check if API key is configured
rustree --llm-ask "test" --dry-run

# Generate template for missing keys
rustree --llm-generate-env
</code></pre>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<p>If you hit rate limits:</p>
<ul>
<li>Use <code>--dry-run</code> to test without API calls</li>
<li>Reduce <code>--llm-max-tokens</code> for smaller requests</li>
<li>Use filtering to reduce tree size</li>
<li>Switch to different provider/model</li>
</ul>
<h3 id="network-issues"><a class="header" href="#network-issues">Network Issues</a></h3>
<pre><code class="language-bash"># Test connectivity with dry run
rustree --llm-ask "test connection" --dry-run

# Use custom endpoint if needed
rustree --llm-ask "test" --llm-endpoint "https://alternative-endpoint.com"
</code></pre>
<h2 id="quick-reference-7"><a class="header" href="#quick-reference-7">Quick Reference</a></h2>
<h3 id="core-options"><a class="header" href="#core-options">Core Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--llm-ask &lt;QUESTION&gt;</code></td><td>Ask question directly to LLM service</td></tr>
<tr><td><code>--llm-export &lt;QUESTION&gt;</code></td><td>Export formatted query for external tools</td></tr>
<tr><td><code>--llm-provider &lt;PROVIDER&gt;</code></td><td>Choose provider (openai, anthropic, cohere, openrouter)</td></tr>
<tr><td><code>--llm-model &lt;MODEL&gt;</code></td><td>Specify model name</td></tr>
<tr><td><code>--llm-api-key &lt;KEY&gt;</code></td><td>Provide API key via command line</td></tr>
</tbody></table>
</div>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--llm-endpoint &lt;URL&gt;</code></td><td>Custom endpoint URL</td></tr>
<tr><td><code>--llm-temperature &lt;FLOAT&gt;</code></td><td>Response randomness (0.0-2.0, default: 0.7)</td></tr>
<tr><td><code>--llm-max-tokens &lt;INT&gt;</code></td><td>Maximum response tokens (default: 1000)</td></tr>
<tr><td><code>--llm-generate-env</code></td><td>Generate .env template</td></tr>
</tbody></table>
</div>
<h3 id="debugging"><a class="header" href="#debugging">Debugging</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--dry-run</code></td><td>Preview request without sending it</td></tr>
<tr><td><code>--human-friendly</code></td><td>Format dry-run output in readable markdown</td></tr>
</tbody></table>
</div>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Provider</th></tr></thead><tbody>
<tr><td><code>OPENAI_API_KEY</code></td><td>OpenAI</td></tr>
<tr><td><code>ANTHROPIC_API_KEY</code></td><td>Anthropic (Claude)</td></tr>
<tr><td><code>COHERE_API_KEY</code></td><td>Cohere</td></tr>
<tr><td><code>OPENROUTER_API_KEY</code></td><td>OpenRouter</td></tr>
</tbody></table>
</div>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<p>See the <a href="cli_usage/./examples.html">Examples</a> page for more detailed LLM integration scenarios and real-world use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diff-and-comparison"><a class="header" href="#diff-and-comparison">Diff and Comparison</a></h1>
<p>RusTree includes powerful directory comparison capabilities to track changes over time. The diff feature can detect additions, removals, modifications, moves/renames, and type changes between directory snapshots.</p>
<h2 id="basic-diff-operations"><a class="header" href="#basic-diff-operations">Basic Diff Operations</a></h2>
<h3 id="create-and-compare-snapshots"><a class="header" href="#create-and-compare-snapshots">Create and Compare Snapshots</a></h3>
<p>First, create a baseline snapshot in JSON format:</p>
<pre><code class="language-bash"># Save current state as baseline
rustree --output-format json &gt; baseline.json

# Later, after making changes, compare current state with baseline
rustree --diff baseline.json
</code></pre>
<h3 id="compare-two-snapshots"><a class="header" href="#compare-two-snapshots">Compare Two Snapshots</a></h3>
<p>Compare two saved snapshots without scanning the current directory:</p>
<pre><code class="language-bash"># Compare two specific snapshots
rustree --diff new_snapshot.json --from-tree-file old_snapshot.json
</code></pre>
<h3 id="input-sources"><a class="header" href="#input-sources">Input Sources</a></h3>
<p>The diff feature supports various input sources:</p>
<pre><code class="language-bash"># Compare with current directory (default)
rustree --diff baseline.json

# Compare two files
rustree --diff new.json --from-tree-file old.json

# Compare against different directory
rustree --diff baseline.json /path/to/other/directory
</code></pre>
<h2 id="change-types"><a class="header" href="#change-types">Change Types</a></h2>
<p>RusTree detects several types of changes:</p>
<ul>
<li><strong>Added</strong> <code>[+]</code> - New files or directories</li>
<li><strong>Removed</strong> <code>[-]</code> - Deleted files or directories</li>
<li><strong>Modified</strong> <code>[M]</code> - Files with changed content, size, or timestamps</li>
<li><strong>Moved</strong> <code>[→]</code> - Files or directories that were moved/renamed</li>
<li><strong>Type Changed</strong> <code>[T]</code> - Entries that changed type (file to directory, etc.)</li>
<li><strong>Unchanged</strong> <code>[=]</code> - No changes (shown only with <code>--show-unchanged</code>)</li>
</ul>
<h2 id="diff-output-formats"><a class="header" href="#diff-output-formats">Diff Output Formats</a></h2>
<h3 id="text-format-default-1"><a class="header" href="#text-format-default-1">Text Format (Default)</a></h3>
<p>Shows changes in a tree structure with change markers:</p>
<pre><code class="language-bash">rustree --diff baseline.json
</code></pre>
<p><strong>Example output:</strong></p>
<pre><code>project/
├── [+] new_file.rs
├── [M] README.md
├── [-] old_config.toml
├── [→] src/main.rs (moved from lib.rs)
└── src/
    └── [T] data (file → directory)

Changes: 2 added, 1 removed, 1 modified, 1 moved, 1 type changed
</code></pre>
<h3 id="markdown-format-1"><a class="header" href="#markdown-format-1">Markdown Format</a></h3>
<p>Generate markdown reports for documentation:</p>
<pre><code class="language-bash">rustree --diff baseline.json --output-format markdown &gt; changes.md
</code></pre>
<h3 id="json-format-1"><a class="header" href="#json-format-1">JSON Format</a></h3>
<p>Structured data for programmatic processing:</p>
<pre><code class="language-bash">rustree --diff baseline.json --output-format json &gt; diff_report.json
</code></pre>
<h3 id="html-format-1"><a class="header" href="#html-format-1">HTML Format</a></h3>
<p>Interactive viewing in web browsers:</p>
<pre><code class="language-bash">rustree --diff baseline.json --output-format html &gt; diff_report.html
</code></pre>
<h2 id="filtering-changes"><a class="header" href="#filtering-changes">Filtering Changes</a></h2>
<h3 id="show-specific-change-types"><a class="header" href="#show-specific-change-types">Show Specific Change Types</a></h3>
<p>Display only certain types of changes:</p>
<pre><code class="language-bash"># Show only additions and removals
rustree --diff baseline.json --show-only added,removed

# Show only modifications
rustree --diff baseline.json --show-only modified

# Show moves and type changes
rustree --diff baseline.json --show-only moved,type_changed
</code></pre>
<p>Available change types:</p>
<ul>
<li><code>added</code> - New files/directories</li>
<li><code>removed</code> - Deleted files/directories</li>
<li><code>modified</code> - Changed files</li>
<li><code>moved</code> - Moved/renamed files/directories</li>
<li><code>type_changed</code> - Type changes (file ↔ directory)</li>
</ul>
<h3 id="show-unchanged-files"><a class="header" href="#show-unchanged-files">Show Unchanged Files</a></h3>
<p>Include unchanged files in the output:</p>
<pre><code class="language-bash"># Show all files, including unchanged ones
rustree --diff baseline.json --show-unchanged
</code></pre>
<p>This provides a complete picture showing what changed and what didn't.</p>
<h3 id="statistics-only"><a class="header" href="#statistics-only">Statistics Only</a></h3>
<p>Show only summary statistics without the detailed tree:</p>
<pre><code class="language-bash"># Summary statistics only
rustree --diff baseline.json --stats-only
</code></pre>
<p><strong>Example output:</strong></p>
<pre><code>Changes Summary:
- 5 files added
- 2 files removed
- 3 files modified
- 1 file moved
- 0 type changes
Total: 11 changes detected
</code></pre>
<h2 id="move-detection"><a class="header" href="#move-detection">Move Detection</a></h2>
<h3 id="move-detection-settings"><a class="header" href="#move-detection-settings">Move Detection Settings</a></h3>
<p>Control how aggressively RusTree detects file moves:</p>
<pre><code class="language-bash"># Default move detection (80% similarity)
rustree --diff baseline.json

# Strict move detection (95% similarity)
rustree --diff baseline.json --move-threshold 0.95

# Loose move detection (50% similarity)
rustree --diff baseline.json --move-threshold 0.5

# Disable move detection entirely
rustree --diff baseline.json --ignore-moves
</code></pre>
<h3 id="how-move-detection-works"><a class="header" href="#how-move-detection-works">How Move Detection Works</a></h3>
<p>RusTree uses content similarity to detect moves:</p>
<ul>
<li>Compares file sizes and content hashes</li>
<li>Calculates similarity scores between files</li>
<li>Files above the threshold are considered moves</li>
<li>Without move detection, moves appear as separate add/remove operations</li>
</ul>
<h3 id="move-threshold-guidelines"><a class="header" href="#move-threshold-guidelines">Move Threshold Guidelines</a></h3>
<ul>
<li><strong>0.9-1.0</strong>: Very strict - only nearly identical files</li>
<li><strong>0.7-0.9</strong>: Balanced - good for most use cases (default: 0.8)</li>
<li><strong>0.5-0.7</strong>: Loose - catches more potential moves but may have false positives</li>
<li><strong>Below 0.5</strong>: Very loose - likely to produce incorrect move detection</li>
</ul>
<h2 id="change-thresholds"><a class="header" href="#change-thresholds">Change Thresholds</a></h2>
<h3 id="size-based-filtering-1"><a class="header" href="#size-based-filtering-1">Size-Based Filtering</a></h3>
<p>Only report changes above certain size thresholds:</p>
<pre><code class="language-bash"># Only report size changes of 1MB or more
rustree --diff baseline.json --size-threshold 1M

# Report changes above 100KB
rustree --diff baseline.json --size-threshold 100K

# Use with size units (K, M, G)
rustree --diff baseline.json --size-threshold 512K
</code></pre>
<h3 id="time-based-filtering"><a class="header" href="#time-based-filtering">Time-Based Filtering</a></h3>
<p>Only report changes above time thresholds:</p>
<pre><code class="language-bash"># Only show files changed more than 1 hour ago
rustree --diff baseline.json --time-threshold 3600

# Files changed more than 1 day ago
rustree --diff baseline.json --time-threshold 86400
</code></pre>
<p>Time threshold is in seconds since the timestamp difference.</p>
<h2 id="integration-with-other-features-4"><a class="header" href="#integration-with-other-features-4">Integration with Other Features</a></h2>
<h3 id="combining-with-filtering-1"><a class="header" href="#combining-with-filtering-1">Combining with Filtering</a></h3>
<p>Apply standard filtering to focus diff analysis:</p>
<pre><code class="language-bash"># Diff only source code changes
rustree --diff baseline.json \
        --filter-include "*.rs" "*.toml" \
        --filter-exclude "**/target/**"

# Track documentation changes
rustree --diff baseline.json \
        --filter-include "*.md" "README*" \
        --depth 3

# Use pattern files for complex filtering
rustree --diff baseline.json \
        --filter-include-from src-patterns.txt \
        --filter-exclude-from ignore-patterns.txt
</code></pre>
<h3 id="metadata-in-diff"><a class="header" href="#metadata-in-diff">Metadata in Diff</a></h3>
<p>Include metadata to understand change impact:</p>
<pre><code class="language-bash"># Show size changes
rustree --diff baseline.json \
        --show-size-bytes --human-friendly

# Include modification times
rustree --diff baseline.json \
        --show-last-modified

# Full metadata analysis
rustree --diff baseline.json \
        --show-size-bytes \
        --show-last-modified \
        --calculate-lines \
        --human-friendly
</code></pre>
<h3 id="sorting-diff-results"><a class="header" href="#sorting-diff-results">Sorting Diff Results</a></h3>
<p>Sort changes by various criteria:</p>
<pre><code class="language-bash"># Sort by size (largest changes first)
rustree --diff baseline.json \
        --show-size-bytes \
        --sort-by size --reverse-sort

# Sort by modification time (most recent first)
rustree --diff baseline.json \
        --show-last-modified \
        --sort-by mtime --reverse-sort

# Group directories first
rustree --diff baseline.json --dirs-first
</code></pre>
<h2 id="llm-analysis-of-changes"><a class="header" href="#llm-analysis-of-changes">LLM Analysis of Changes</a></h2>
<h3 id="ai-powered-change-analysis"><a class="header" href="#ai-powered-change-analysis">AI-Powered Change Analysis</a></h3>
<p>Combine diff with LLM analysis:</p>
<pre><code class="language-bash"># Analyze the impact of changes
rustree --diff baseline.json \
        --llm-ask "What are the most significant changes and their potential impact?"

# Security-focused change review
rustree --diff baseline.json \
        --filter-include "*.rs" "*.toml" \
        --llm-ask "Are there any security concerns in these changes?"

# Performance impact analysis
rustree --diff baseline.json \
        --show-size-bytes \
        --llm-ask "Could these changes affect performance?"
</code></pre>
<h2 id="practical-workflows"><a class="header" href="#practical-workflows">Practical Workflows</a></h2>
<h3 id="development-monitoring"><a class="header" href="#development-monitoring">Development Monitoring</a></h3>
<pre><code class="language-bash"># Save snapshot before starting feature
rustree --output-format json &gt; feature-start.json

# During development, check progress
rustree --diff feature-start.json --stats-only

# Before commit, review all changes
rustree --diff feature-start.json \
        --filter-include "src/**" "tests/**" \
        --show-size-bytes
</code></pre>
<h3 id="release-tracking"><a class="header" href="#release-tracking">Release Tracking</a></h3>
<pre><code class="language-bash"># Compare releases
rustree --diff v1.0-snapshot.json --from-tree-file v1.1-snapshot.json

# Track major changes between versions
rustree --diff v1.0-snapshot.json \
        --show-only added,removed \
        --filter-include "src/**"

# Generate release notes
rustree --diff v1.0-snapshot.json \
        --output-format markdown \
        --show-size-bytes &gt; release-changes.md
</code></pre>
<h3 id="build-monitoring"><a class="header" href="#build-monitoring">Build Monitoring</a></h3>
<pre><code class="language-bash"># Before build
rustree --output-format json &gt; pre-build.json

# After build - see generated artifacts
rustree --diff pre-build.json \
        --filter-include "target/**" "build/**" \
        --show-only added \
        --show-size-bytes --human-friendly
</code></pre>
<h3 id="system-administration"><a class="header" href="#system-administration">System Administration</a></h3>
<pre><code class="language-bash"># Daily system monitoring
DATE=$(date +%Y%m%d)
YESTERDAY=$(date -d yesterday +%Y%m%d)

# Monitor important directories
rustree --diff "system-$YESTERDAY.json" /etc \
        --filter-exclude "*.log" "*.tmp" \
        --show-last-modified

# Track configuration changes
rustree --diff baseline-config.json /etc/nginx \
        --show-only modified,added,removed
</code></pre>
<h2 id="automation-and-scripting"><a class="header" href="#automation-and-scripting">Automation and Scripting</a></h2>
<h3 id="automated-change-detection"><a class="header" href="#automated-change-detection">Automated Change Detection</a></h3>
<pre><code class="language-bash">#!/bin/bash
# Daily change monitoring script

PROJECT_DIR="/path/to/project"
DATE=$(date +%Y%m%d)
YESTERDAY=$(date -d yesterday +%Y%m%d)

# Generate today's snapshot
rustree --output-format json "$PROJECT_DIR" &gt; "snapshot-$DATE.json"

# Compare with yesterday if exists
if [ -f "snapshot-$YESTERDAY.json" ]; then
    echo "Changes since yesterday:"
    rustree --diff "snapshot-$YESTERDAY.json" "$PROJECT_DIR" \
            --filter-exclude "*.log" "*.tmp" \
            --show-size-bytes --stats-only

    # Alert on significant changes
    CHANGES=$(rustree --diff "snapshot-$YESTERDAY.json" "$PROJECT_DIR" --stats-only | grep -c "files added\|files removed")
    if [ "$CHANGES" -gt 5 ]; then
        echo "ALERT: Significant changes detected!"
    fi
fi
</code></pre>
<h3 id="cicd-integration"><a class="header" href="#cicd-integration">CI/CD Integration</a></h3>
<pre><code class="language-bash"># In CI pipeline
BUILD_ID=$(git rev-parse --short HEAD)
BASE_BRANCH="main"

# Create snapshot
rustree --output-format json &gt; "build-$BUILD_ID.json"

# Compare with main branch baseline
if [ -f "baseline-$BASE_BRANCH.json" ]; then
    # Generate change report for review
    rustree --diff "baseline-$BASE_BRANCH.json" \
            --output-format markdown \
            --filter-include "src/**" "tests/**" \
            --show-size-bytes &gt; "changes-$BUILD_ID.md"

    # Check for structural changes
    rustree --diff "baseline-$BASE_BRANCH.json" \
            --show-only added,removed \
            --stats-only
fi
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="large-directory-performance"><a class="header" href="#large-directory-performance">Large Directory Performance</a></h3>
<p>For large projects, optimize diff performance:</p>
<pre><code class="language-bash"># Use depth limits
rustree --diff baseline.json --depth 3

# Focus on specific areas
rustree --diff baseline.json src/ tests/

# Use filtering to reduce scope
rustree --diff baseline.json \
        --filter-include "*.rs" \
        --filter-exclude "**/target/**" \
        --prune-empty-directories
</code></pre>
<h3 id="debugging-issues"><a class="header" href="#debugging-issues">Debugging Issues</a></h3>
<pre><code class="language-bash"># Verify snapshot contents
rustree --output-format json . | jq '.nodes | length'

# Check path normalization issues
rustree --diff baseline.json --full-path

# Test move detection settings
rustree --diff baseline.json --move-threshold 0.1  # Very loose
rustree --diff baseline.json --ignore-moves        # Disable moves
</code></pre>
<h2 id="quick-reference-8"><a class="header" href="#quick-reference-8">Quick Reference</a></h2>
<h3 id="core-diff-options"><a class="header" href="#core-diff-options">Core Diff Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--diff &lt;FILE&gt;</code></td><td>Compare current directory with snapshot file</td></tr>
<tr><td><code>--from-tree-file &lt;FILE&gt;</code></td><td>Use file as source instead of current directory</td></tr>
<tr><td><code>--show-only &lt;TYPES&gt;</code></td><td>Show only specific change types</td></tr>
<tr><td><code>--show-unchanged</code></td><td>Include unchanged files in output</td></tr>
<tr><td><code>--stats-only</code></td><td>Show only summary statistics</td></tr>
</tbody></table>
</div>
<h3 id="move-detection-1"><a class="header" href="#move-detection-1">Move Detection</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--ignore-moves</code></td><td>Disable move/rename detection</td></tr>
<tr><td><code>--move-threshold &lt;FLOAT&gt;</code></td><td>Similarity threshold for moves (0.0-1.0, default: 0.8)</td></tr>
</tbody></table>
</div>
<h3 id="change-filtering"><a class="header" href="#change-filtering">Change Filtering</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--size-threshold &lt;BYTES&gt;</code></td><td>Only report size changes above threshold</td></tr>
<tr><td><code>--time-threshold &lt;SECONDS&gt;</code></td><td>Only report time changes above threshold</td></tr>
</tbody></table>
</div>
<h3 id="change-types-1"><a class="header" href="#change-types-1">Change Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Marker</th><th>Description</th></tr></thead><tbody>
<tr><td><code>added</code></td><td><code>[+]</code></td><td>New files or directories</td></tr>
<tr><td><code>removed</code></td><td><code>[-]</code></td><td>Deleted files or directories</td></tr>
<tr><td><code>modified</code></td><td><code>[M]</code></td><td>Changed files</td></tr>
<tr><td><code>moved</code></td><td><code>[→]</code></td><td>Moved or renamed files/directories</td></tr>
<tr><td><code>type_changed</code></td><td><code>[T]</code></td><td>Type change (file ↔ directory)</td></tr>
<tr><td><code>unchanged</code></td><td><code>[=]</code></td><td>No changes (with <code>--show-unchanged</code>)</td></tr>
</tbody></table>
</div>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<p>See the <a href="cli_usage/./examples.html">Examples</a> page for more detailed diff scenarios and real-world use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h1>
<p>RusTree supports configuration files to save your preferred settings and avoid repetitive command-line arguments. This page covers configuration file usage, utilities, and advanced options.</p>
<h2 id="configuration-files"><a class="header" href="#configuration-files">Configuration Files</a></h2>
<h3 id="automatic-discovery"><a class="header" href="#automatic-discovery">Automatic Discovery</a></h3>
<p>RusTree automatically looks for configuration files in several locations:</p>
<ol>
<li><strong>Project-specific</strong>: <code>.rustree/config.toml</code> in current directory and parent directories</li>
<li><strong>Global user config</strong>: <code>~/.config/rustree/config.toml</code> (Linux/macOS) or <code>%APPDATA%\rustree\config.toml</code> (Windows)</li>
<li><strong>Custom config files</strong>: Specified via <code>--config-file</code></li>
</ol>
<h3 id="configuration-file-format"><a class="header" href="#configuration-file-format">Configuration File Format</a></h3>
<p>Configuration files use TOML format with sections corresponding to CLI option groups:</p>
<pre><code class="language-toml"># Example .rustree/config.toml

[input_source]
root_display_name = "MyProject"

[listing]
max_depth = 3
show_hidden = true

[filtering]
ignore_patterns = ["target/", "node_modules/", "*.log"]
match_patterns = ["*.rs", "*.toml", "*.md"]
use_gitignore_rules = true
case_insensitive_filter = false

[metadata]
show_size_bytes = true
show_last_modified = true
calculate_lines = true

[sorting]
sort_by = "size"
reverse_sort = true
dirs_first = true

[misc]
output_format = "text"
no_summary_report = false
</code></pre>
<h2 id="generate-configuration-template"><a class="header" href="#generate-configuration-template">Generate Configuration Template</a></h2>
<h3 id="create-template-file"><a class="header" href="#create-template-file">Create Template File</a></h3>
<p>Generate a fully commented configuration template:</p>
<pre><code class="language-bash"># Generate template and save to file
rustree --generate-config &gt; .rustree/config.toml

# View template without saving
rustree --generate-config

# Generate in project directory
mkdir -p .rustree
rustree --generate-config &gt; .rustree/config.toml
</code></pre>
<p>The generated template includes all available options with comments explaining their purpose.</p>
<h2 id="custom-configuration-files"><a class="header" href="#custom-configuration-files">Custom Configuration Files</a></h2>
<h3 id="specify-configuration-files"><a class="header" href="#specify-configuration-files">Specify Configuration Files</a></h3>
<p>Load specific configuration files:</p>
<pre><code class="language-bash"># Load single custom config
rustree --config-file ./my-config.toml

# Load multiple configs (later ones override earlier ones)
rustree --config-file ./base-config.toml --config-file ./project-config.toml

# Combine with CLI options (CLI options override config)
rustree --config-file ./config.toml --depth 2 --show-size-bytes
</code></pre>
<h3 id="disable-configuration-discovery"><a class="header" href="#disable-configuration-discovery">Disable Configuration Discovery</a></h3>
<p>Skip automatic configuration file discovery:</p>
<pre><code class="language-bash"># Ignore all config files
rustree --no-config

# Use only CLI options and built-in defaults
rustree --no-config --show-size-bytes --depth 3
</code></pre>
<h2 id="configuration-precedence"><a class="header" href="#configuration-precedence">Configuration Precedence</a></h2>
<p>Settings are applied in this order (later overrides earlier):</p>
<ol>
<li><strong>Built-in defaults</strong></li>
<li><strong>Global user config</strong> (<code>~/.config/rustree/config.toml</code>)</li>
<li><strong>Project configs</strong> (<code>.rustree/config.toml</code>, searching up from current directory)</li>
<li><strong>Custom config files</strong> (via <code>--config-file</code>, in order specified)</li>
<li><strong>Command-line options</strong></li>
</ol>
<h3 id="example-precedence"><a class="header" href="#example-precedence">Example Precedence</a></h3>
<pre><code class="language-bash"># This command:
rustree --config-file custom.toml --depth 5

# Results in:
# 1. Built-in defaults
# 2. ~/.config/rustree/config.toml (if exists)
# 3. .rustree/config.toml (if found in current/parent dirs)
# 4. custom.toml
# 5. --depth 5 (overrides any depth setting from configs)
</code></pre>
<h2 id="configuration-sections"><a class="header" href="#configuration-sections">Configuration Sections</a></h2>
<h3 id="input-source-options"><a class="header" href="#input-source-options">Input Source Options</a></h3>
<pre><code class="language-toml">[input_source]
root_display_name = "MyProject"  # Custom name for root directory
root_is_directory = true         # Whether root should be treated as directory
</code></pre>
<h3 id="listing-options"><a class="header" href="#listing-options">Listing Options</a></h3>
<pre><code class="language-toml">[listing]
max_depth = 3                    # Maximum traversal depth
show_hidden = false              # Include hidden files/directories
</code></pre>
<h3 id="filtering-options"><a class="header" href="#filtering-options">Filtering Options</a></h3>
<pre><code class="language-toml">[filtering]
ignore_patterns = [              # Files/dirs to exclude
    "target/",
    "node_modules/", 
    "*.log",
    "*.tmp"
]
match_patterns = [               # Files/dirs to include (if specified)
    "*.rs",
    "*.toml", 
    "*.md"
]
use_gitignore_rules = true       # Respect .gitignore files
case_insensitive_filter = false  # Case-insensitive pattern matching
min_file_size = "1K"             # Minimum file size (with units)
max_file_size = "10M"            # Maximum file size (with units)
prune_empty_directories = true   # Remove empty directories
</code></pre>
<h3 id="metadata-options"><a class="header" href="#metadata-options">Metadata Options</a></h3>
<pre><code class="language-toml">[metadata]
show_size_bytes = true           # Display file sizes
show_last_modified = true        # Display modification times
calculate_lines = false          # Count lines in text files
calculate_words = false          # Count words in text files

# Apply function configuration
apply_function = "cat"           # Built-in function to apply
# apply_function_cmd = "wc -l"   # External command to apply
apply_include_patterns = ["*.rs"] # Apply function only to these patterns
apply_exclude_patterns = ["*test*"] # Don't apply function to these patterns
</code></pre>
<h3 id="sorting-options"><a class="header" href="#sorting-options">Sorting Options</a></h3>
<pre><code class="language-toml">[sorting]
sort_by = "name"                 # Sort key (name, size, mtime, etc.)
reverse_sort = false             # Reverse sort order
dirs_first = false               # Show directories before files
files_first = false              # Show files before directories
</code></pre>
<h3 id="miscellaneous-options"><a class="header" href="#miscellaneous-options">Miscellaneous Options</a></h3>
<pre><code class="language-toml">[misc]
output_format = "text"           # Output format (text, markdown, json, html)
no_summary_report = false        # Omit summary line
human_friendly = false           # Human-readable sizes
</code></pre>
<h2 id="verbose-configuration-display"><a class="header" href="#verbose-configuration-display">Verbose Configuration Display</a></h2>
<h3 id="view-merged-configuration"><a class="header" href="#view-merged-configuration">View Merged Configuration</a></h3>
<p>See exactly what configuration RusTree will use:</p>
<pre><code class="language-bash"># Show merged configuration before execution
rustree --verbose

# Combine with other options to see their effect
rustree --verbose --config-file custom.toml --depth 2
</code></pre>
<p>This displays:</p>
<ul>
<li>All configuration sources found</li>
<li>Final merged configuration values</li>
<li>Command-line overrides applied</li>
</ul>
<p><strong>Example output:</strong></p>
<pre><code>Configuration loaded from:
  - Built-in defaults
  - ~/.config/rustree/config.toml
  - ./.rustree/config.toml
  - Command line: --depth 2

Final configuration:
[listing]
max_depth = 2                    # from command line
show_hidden = true               # from ./.rustree/config.toml

[filtering] 
ignore_patterns = ["target/"]    # from ~/.config/rustree/config.toml
...

[Running rustree with above configuration]
</code></pre>
<h2 id="shell-completions"><a class="header" href="#shell-completions">Shell Completions</a></h2>
<h3 id="generate-completion-scripts"><a class="header" href="#generate-completion-scripts">Generate Completion Scripts</a></h3>
<p>RusTree can generate shell completion scripts:</p>
<pre><code class="language-bash"># Bash completions
rustree --generate-completions bash &gt; ~/.local/share/bash-completion/completions/rustree

# Zsh completions  
rustree --generate-completions zsh &gt; ~/.zfunc/_rustree

# Fish completions
rustree --generate-completions fish &gt; ~/.config/fish/completions/rustree.fish

# PowerShell completions
rustree --generate-completions powershell &gt; rustree_completions.ps1

# Elvish completions
rustree --generate-completions elvish &gt; rustree_completions.elv
</code></pre>
<h3 id="install-completions"><a class="header" href="#install-completions">Install Completions</a></h3>
<p>After generating completions, you may need to reload your shell or source the completion files.</p>
<h2 id="project-specific-configuration"><a class="header" href="#project-specific-configuration">Project-Specific Configuration</a></h2>
<h3 id="per-project-settings"><a class="header" href="#per-project-settings">Per-Project Settings</a></h3>
<p>Create project-specific configurations:</p>
<pre><code class="language-bash"># In your project root
mkdir -p .rustree

# Generate base config
rustree --generate-config &gt; .rustree/config.toml

# Edit for project needs
# For example, a Rust project might use:
</code></pre>
<pre><code class="language-toml">[filtering]
ignore_patterns = ["target/", "Cargo.lock"]
match_patterns = ["*.rs", "*.toml"]
use_gitignore_rules = true

[metadata]
show_size_bytes = true
calculate_lines = true

[sorting]
sort_by = "lines"
reverse_sort = true
</code></pre>
<h3 id="team-configuration"><a class="header" href="#team-configuration">Team Configuration</a></h3>
<p>Share configuration across team members:</p>
<pre><code class="language-bash"># Commit project config to version control
git add .rustree/config.toml
git commit -m "Add RusTree project configuration"

# Team members automatically get the config
git pull
rustree  # Uses project config automatically
</code></pre>
<h2 id="environment-specific-configurations"><a class="header" href="#environment-specific-configurations">Environment-Specific Configurations</a></h2>
<h3 id="development-vs-production"><a class="header" href="#development-vs-production">Development vs Production</a></h3>
<p>Use different configs for different environments:</p>
<pre><code class="language-bash"># Development config with detailed output
rustree --config-file .rustree/dev-config.toml

# Production config with minimal output
rustree --config-file .rustree/prod-config.toml

# CI/CD config for automated reporting
rustree --config-file .rustree/ci-config.toml --output-format json
</code></pre>
<h3 id="user-specific-overrides"><a class="header" href="#user-specific-overrides">User-Specific Overrides</a></h3>
<p>Combine global and project configs with user preferences:</p>
<pre><code class="language-bash"># User's global config provides defaults
# ~/.config/rustree/config.toml

# Project config provides project-specific settings  
# .rustree/config.toml

# User overrides with personal config for this project
rustree --config-file ~/.rustree-overrides.toml
</code></pre>
<h2 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h2>
<h3 id="source-code-analysis"><a class="header" href="#source-code-analysis">Source Code Analysis</a></h3>
<pre><code class="language-toml"># .rustree/source-analysis.toml
[filtering]
match_patterns = ["*.rs", "*.js", "*.py", "*.java", "*.cpp"]
ignore_patterns = ["**/target/**", "**/node_modules/**", "**/__pycache__/**"]
use_gitignore_rules = true

[metadata]
show_size_bytes = true
calculate_lines = true
calculate_words = true

[sorting]
sort_by = "lines" 
reverse_sort = true

[misc]
output_format = "markdown"
</code></pre>
<h3 id="documentation-review-1"><a class="header" href="#documentation-review-1">Documentation Review</a></h3>
<pre><code class="language-toml"># .rustree/docs-config.toml
[filtering]
match_patterns = ["*.md", "*.txt", "README*", "*.rst"]
ignore_patterns = ["**/target/**", "**/build/**"]

[metadata]
show_size_bytes = true
calculate_words = true

[sorting]
sort_by = "words"
reverse_sort = true

[misc]
output_format = "markdown"
no_summary_report = true
</code></pre>
<h3 id="quick-overview"><a class="header" href="#quick-overview">Quick Overview</a></h3>
<pre><code class="language-toml"># .rustree/quick.toml
[listing]
max_depth = 2

[filtering]
ignore_patterns = [".*", "**/target/**", "**/node_modules/**"]

[sorting]
dirs_first = true

[misc]
no_summary_report = true
</code></pre>
<h2 id="troubleshooting-configuration"><a class="header" href="#troubleshooting-configuration">Troubleshooting Configuration</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>Config not loading:</strong></p>
<pre><code class="language-bash"># Check what configs are found
rustree --verbose

# Verify config file syntax
rustree --config-file problematic-config.toml --verbose
</code></pre>
<p><strong>Option conflicts:</strong></p>
<pre><code class="language-bash"># See final merged configuration
rustree --verbose

# Test with no config to isolate CLI options
rustree --no-config --your-options-here
</code></pre>
<p><strong>Path issues:</strong></p>
<pre><code class="language-bash"># Check current directory for .rustree/config.toml
ls -la .rustree/

# Check global config location
ls -la ~/.config/rustree/
</code></pre>
<h2 id="quick-reference-9"><a class="header" href="#quick-reference-9">Quick Reference</a></h2>
<h3 id="configuration-management-1"><a class="header" href="#configuration-management-1">Configuration Management</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--config-file &lt;FILE&gt;</code></td><td>Load specific configuration file</td></tr>
<tr><td><code>--no-config</code></td><td>Ignore all configuration files</td></tr>
<tr><td><code>--generate-config</code></td><td>Generate configuration template</td></tr>
<tr><td><code>--verbose</code></td><td>Show merged configuration before execution</td></tr>
</tbody></table>
</div>
<h3 id="shell-completions-1"><a class="header" href="#shell-completions-1">Shell Completions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--generate-completions &lt;SHELL&gt;</code></td><td>Generate completion script for shell</td></tr>
</tbody></table>
</div>
<h3 id="supported-shells"><a class="header" href="#supported-shells">Supported Shells</a></h3>
<ul>
<li><code>bash</code> - Bash shell completions</li>
<li><code>zsh</code> - Zsh shell completions</li>
<li><code>fish</code> - Fish shell completions</li>
<li><code>powershell</code> - PowerShell completions</li>
<li><code>elvish</code> - Elvish shell completions</li>
</ul>
<h3 id="configuration-file-locations"><a class="header" href="#configuration-file-locations">Configuration File Locations</a></h3>
<ol>
<li><strong>Project</strong>: <code>.rustree/config.toml</code> (current and parent directories)</li>
<li><strong>Global</strong>: <code>~/.config/rustree/config.toml</code> (Linux/macOS)</li>
<li><strong>Global</strong>: <code>%APPDATA%\rustree\config.toml</code> (Windows)</li>
<li><strong>Custom</strong>: Via <code>--config-file</code></li>
</ol>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<p>See the <a href="cli_usage/./examples.html">Examples</a> page for more configuration scenarios and real-world setups.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-options"><a class="header" href="#command-line-options">Command-Line Options</a></h1>
<p>This page details all available command-line options for <code>rustree</code>.</p>
<p>The basic syntax is:
<code>rustree [OPTIONS] [PATH]</code></p>
<p>If <code>PATH</code> is omitted, it defaults to the current directory (<code>.</code>).</p>
<h2 id="path-argument"><a class="header" href="#path-argument">Path Argument</a></h2>
<ul>
<li><code>[PATH]</code>
<ul>
<li>Description: The directory or file path to process. If omitted, defaults to the current directory (<code>.</code>).</li>
<li>Example: <code>rustree ./my_project</code>, <code>rustree /var/log/syslog</code></li>
</ul>
</li>
</ul>
<h2 id="listing-control"><a class="header" href="#listing-control">Listing Control</a></h2>
<ul>
<li>
<p><code>-a, --include-hidden</code></p>
<ul>
<li>Description: Include hidden files and directories (those starting with a <code>.</code>) in the listing. (Original <code>tree</code> flag: <code>-a</code>)</li>
<li>Example: <code>rustree -a</code></li>
</ul>
</li>
<li>
<p><code>-d, --directory-only</code></p>
<ul>
<li>Description: List directories only. Files will not be included in the output. (Original <code>tree</code> flag: <code>-d</code>)</li>
<li>Example: <code>rustree -d ./src</code></li>
</ul>
</li>
<li>
<p><code>-L, --depth &lt;LEVEL&gt;</code></p>
<ul>
<li>Description: Descend only <code>&lt;LEVEL&gt;</code> directory levels deep. <code>1</code> means the root and its direct children. (Original <code>tree</code> flag: <code>-L</code>)</li>
<li>Example: <code>rustree -L 2</code> (shows root and its direct children)</li>
</ul>
</li>
<li>
<p><code>-f, --full-path</code></p>
<ul>
<li>Description: Print the full path prefix for each file. (Original <code>tree</code> flag: <code>-f</code>)</li>
<li>Example: <code>rustree -f</code></li>
</ul>
</li>
</ul>
<h2 id="filtering-and-ignoring"><a class="header" href="#filtering-and-ignoring">Filtering and Ignoring</a></h2>
<ul>
<li>
<p><code>-P, --filter-include &lt;PATTERN&gt;</code></p>
<ul>
<li>Description: List only those files and directories that match the specified wildcard pattern. This option can be used multiple times to provide several patterns. If any pattern matches, the entry is listed. (Original <code>tree</code> flag: <code>-P</code>)</li>
<li>Wildcard patterns supported:
<ul>
<li><code>*</code>: any zero or more characters.</li>
<li><code>?</code>: any single character.</li>
<li><code>[...]</code>: any single character listed (e.g., <code>[abc]</code>, <code>[a-z]</code>).</li>
<li><code>[!...]</code>: any single character not listed.</li>
<li><code>|</code>: separates alternate patterns within a single pattern string (e.g., <code>*.txt|*.log</code>).</li>
</ul>
</li>
<li>A <code>/</code> at the end of a pattern (e.g., <code>mydir/</code>) specifically matches directories.</li>
<li>Note: To match hidden files (starting with <code>.</code>) with patterns like <code>*</code>, you must also use the <code>-a</code> or <code>--include-hidden</code> option. If <code>-a</code> is not used, <code>*</code> will not match hidden entries. Patterns explicitly starting with <code>.</code> (e.g., <code>.*</code>) will match hidden files regardless of <code>-a</code>.</li>
<li>This option is affected by <code>--case-insensitive-filter</code>.</li>
<li>Example: <code>rustree -P "*.rs"</code>, <code>rustree --filter-include "*.txt|*.md" --filter-include "docs/"</code></li>
</ul>
</li>
<li>
<p><code>-I, --filter-exclude &lt;PATTERN&gt;</code></p>
<ul>
<li>Description: Do not list those files or directories that match the specified wildcard pattern. This option can be used multiple times to provide several patterns. If any pattern matches, the entry is excluded. (Original <code>tree</code> flag: <code>-I</code>)</li>
<li>Uses the same wildcard pattern syntax as <code>-P, --filter-include</code>.</li>
<li>This option is affected by <code>--case-insensitive-filter</code>.</li>
<li>Example: <code>rustree -I "*.log"</code>, <code>rustree --filter-exclude "target/" --filter-exclude "*.tmp"</code></li>
</ul>
</li>
<li>
<p><code>--filter-include-from &lt;FILE&gt;</code></p>
<ul>
<li>Description: Read include patterns from a file. Each line in the file should contain one pattern. Lines starting with <code>#</code> and empty lines are ignored. This option can be used multiple times to read patterns from multiple files.</li>
<li>Uses the same wildcard pattern syntax as <code>-P, --filter-include</code>.</li>
<li>This option is affected by <code>--case-insensitive-filter</code>.</li>
<li>Example: <code>rustree --filter-include-from ./include-patterns.txt</code></li>
</ul>
</li>
<li>
<p><code>--filter-exclude-from &lt;FILE&gt;</code></p>
<ul>
<li>Description: Read exclude patterns from a file. Each line in the file should contain one pattern. Lines starting with <code>#</code> and empty lines are ignored. This option can be used multiple times to read patterns from multiple files.</li>
<li>Uses the same wildcard pattern syntax as <code>-I, --filter-exclude</code>.</li>
<li>This option is affected by <code>--case-insensitive-filter</code>.</li>
<li>Example: <code>rustree --filter-exclude-from ./exclude-patterns.txt</code></li>
</ul>
</li>
<li>
<p><code>--use-gitignore-rules</code>, <code>--gitignore</code> (deprecated alias)</p>
<ul>
<li>Description: Respects gitignore rules for filtering files and directories. This includes checking <code>.gitignore</code> files in the scanned directories and their parents, the global gitignore file (e.g., <code>~/.config/git/ignore</code>), and repository-specific exclude files (e.g., <code>$GIT_DIR/info/exclude</code>). The <code>--gitignore</code> flag is deprecated; use <code>--use-gitignore-rules</code> instead.</li>
<li>This option is affected by <code>--case-insensitive-filter</code>.</li>
<li>Example: <code>rustree --use-gitignore-rules</code></li>
</ul>
</li>
<li>
<p><code>--gitignore-file &lt;FILE&gt;</code></p>
<ul>
<li>Description: Use the specified file(s) as additional sources of gitignore patterns. Patterns in these files are matched as if the specified file was located at the root of the scan. This option can be specified multiple times.</li>
<li>This option is affected by <code>--case-insensitive-filter</code>.</li>
<li>Example: <code>rustree --gitignore-file ./.customignore --gitignore-file ./project.ignores</code></li>
</ul>
</li>
<li>
<p><code>--case-insensitive-filter</code></p>
<ul>
<li>Description: Perform case-insensitive matching for all patterns provided via <code>-P</code> (<code>--filter-include</code>), <code>-I</code> (<code>--filter-exclude</code>), <code>--use-gitignore-rules</code> (and its alias <code>--gitignore</code>), and <code>--gitignore-file</code>.</li>
<li>Example: <code>rustree -P "*.TXT" --case-insensitive-filter</code> (would match <code>file.txt</code>)</li>
</ul>
</li>
<li>
<p><code>--prune-empty-directories</code>, <code>--prune</code> (alias)</p>
<ul>
<li>Description: Remove empty directories from the output. An empty directory is one that contains no files and no non-empty subdirectories after all other filtering (e.g., <code>-P</code>, <code>-I</code>, gitignore rules) has been applied. This option is applied before sorting.</li>
<li>Example: <code>rustree --prune-empty-directories</code>, <code>rustree --prune ./my_project</code></li>
</ul>
</li>
</ul>
<h2 id="metadata-reporting"><a class="header" href="#metadata-reporting">Metadata Reporting</a></h2>
<ul>
<li>
<p><code>-s, --show-size-bytes</code></p>
<ul>
<li>Description: Report sizes of files and directories in bytes in the output. (Original <code>tree</code> flag: <code>-s</code>)</li>
<li>Example: <code>rustree -s</code> or <code>rustree --show-size-bytes</code></li>
</ul>
</li>
<li>
<p><code>-D, --show-last-modified</code></p>
<ul>
<li>Description: Report dates for files and directories. By default, this shows the last modification time (mtime). If sorting by change time (<code>-c</code> or <code>--sort-by ctime</code>), this flag will instead display the last status change time (ctime). (Original <code>tree</code> flag: <code>-D</code>)</li>
<li>Example: <code>rustree -D</code> or <code>rustree --show-last-modified</code></li>
</ul>
</li>
</ul>
<h2 id="content-analysis-1"><a class="header" href="#content-analysis-1">Content Analysis</a></h2>
<ul>
<li>
<p><code>--calculate-lines</code></p>
<ul>
<li>Description: Calculate and display line counts for files.</li>
<li>Example: <code>rustree --calculate-lines</code></li>
</ul>
</li>
<li>
<p><code>--calculate-words</code></p>
<ul>
<li>Description: Calculate and display word counts for files.</li>
<li>Example: <code>rustree --calculate-words</code></li>
</ul>
</li>
<li>
<p><code>--apply-function &lt;FUNCTION_NAME&gt;</code></p>
<ul>
<li>Description: Apply a built-in function to file or directory contents and display the result. When using the <code>cat</code> function, the tree structure is displayed first, followed by the contents of each file.</li>
<li>Available functions:
<ul>
<li><strong>File functions</strong> (work with file content):
<ul>
<li><code>count-pluses</code>: Counts '+' characters in each file and displays the count in metadata</li>
<li><code>cat</code>: Displays the full content of each file after the tree structure</li>
</ul>
</li>
<li><strong>Directory functions</strong> (work with directory children):
<ul>
<li><code>count-files</code>: Counts the number of files in each directory</li>
<li><code>count-dirs</code>: Counts the number of subdirectories in each directory</li>
<li><code>size-total</code>: Calculates the total size of all files in each directory</li>
<li><code>dir-stats</code>: Shows combined statistics (files, directories, total size) for each directory</li>
</ul>
</li>
</ul>
</li>
<li>Example: <code>rustree --apply-function cat</code>, <code>rustree --apply-function count-pluses</code>, <code>rustree --apply-function dir-stats</code></li>
</ul>
</li>
<li>
<p><code>--apply-include &lt;PATTERN&gt;</code></p>
<ul>
<li>Description: Apply the function only to files/directories matching the specified pattern. Can be used multiple times. Uses the same wildcard syntax as <code>--filter-include</code>.</li>
<li>Example: <code>rustree --apply-function count-pluses --apply-include "*.rs"</code></li>
</ul>
</li>
<li>
<p><code>--apply-exclude &lt;PATTERN&gt;</code></p>
<ul>
<li>Description: Do not apply the function to files/directories matching the specified pattern. Can be used multiple times. Uses the same wildcard syntax as <code>--filter-exclude</code>.</li>
<li>Example: <code>rustree --apply-function dir-stats --apply-exclude "target/*"</code></li>
</ul>
</li>
<li>
<p><code>--apply-include-from &lt;FILE_PATH&gt;</code></p>
<ul>
<li>Description: Read include patterns for apply-function from the specified file. One pattern per line. Lines starting with <code>#</code> and empty lines are ignored.</li>
<li>Example: <code>rustree --apply-function cat --apply-include-from ./include-patterns.txt</code></li>
</ul>
</li>
<li>
<p><code>--apply-exclude-from &lt;FILE_PATH&gt;</code></p>
<ul>
<li>Description: Read exclude patterns for apply-function from the specified file. One pattern per line. Lines starting with <code>#</code> and empty lines are ignored.</li>
<li>Example: <code>rustree --apply-function dir-stats --apply-exclude-from ./exclude-patterns.txt</code></li>
</ul>
</li>
</ul>
<h3 id="size-based-filtering-new"><a class="header" href="#size-based-filtering-new">Size-based Filtering (new)</a></h3>
<ul>
<li>
<p><code>--min-file-size &lt;SIZE&gt;</code></p>
<ul>
<li>Description: Include only files <strong>at least</strong> <code>&lt;SIZE&gt;</code> bytes. Directories are never filtered by size; only their child files are tested. Accepts optional suffixes <code>K</code>, <code>M</code>, <code>G</code> (base-1024) for kibibytes, mebibytes, and gibibytes. Examples: <code>10K</code>, <code>2M</code>, <code>1G</code>.</li>
<li>Example: <code>rustree --min-file-size 100K</code> (shows files ≥ 100 KiB)</li>
</ul>
</li>
<li>
<p><code>--max-file-size &lt;SIZE&gt;</code></p>
<ul>
<li>Description: Include only files <strong>no larger than</strong> <code>&lt;SIZE&gt;</code> bytes. Same suffix rules as above.</li>
<li>Example: <code>rustree --max-file-size 2M</code> (shows files ≤ 2 MiB)</li>
</ul>
</li>
</ul>
<p>These flags can be combined to specify a size range, e.g. <code>--min-file-size 10K --max-file-size 1M</code>.</p>
<h2 id="utility--configuration"><a class="header" href="#utility--configuration">Utility &amp; Configuration</a></h2>
<ul>
<li>
<p><code>--config-file &lt;FILE&gt;</code> – Merge a specific TOML file into the active
configuration. May be used multiple times; later files override earlier ones.</p>
</li>
<li>
<p><code>--no-config</code> – Skip automatic discovery of project/global config files.</p>
</li>
<li>
<p><code>--generate-config</code> – Print a fully-commented config template and exit.</p>
</li>
<li>
<p><code>--verbose</code> – Print the fully merged configuration (and LLM config, if
applicable) before running so you can see exactly what options RusTree will
use.</p>
</li>
</ul>
<h2 id="sorting"><a class="header" href="#sorting">Sorting</a></h2>
<ul>
<li>
<p><code>-U, --unsorted</code></p>
<ul>
<li>Description: Do not sort the output. List entries in directory order. Overrides other sort options. Equivalent to <code>--sort-by none</code>. (Original <code>tree</code> flag: <code>-U</code>)</li>
<li>Example: <code>rustree -U</code></li>
</ul>
</li>
<li>
<p><code>-t</code></p>
<ul>
<li>Description: Sort the output by last modification time (mtime) instead of alphabetically. Oldest first. Equivalent to <code>--sort-by mtime</code>. (Original <code>tree</code> flag: <code>-t</code>)</li>
<li>Example: <code>rustree -t</code></li>
</ul>
</li>
<li>
<p><code>-c</code></p>
<ul>
<li>Description: Sort the output by last status change time (ctime) instead of alphabetically. Oldest first. Equivalent to <code>--sort-by ctime</code>. (Original <code>tree</code> flag: <code>-c</code>)</li>
<li>Example: <code>rustree -c</code></li>
</ul>
</li>
<li>
<p><code>-v</code></p>
<ul>
<li>Description: Sort the output by version strings embedded in file names. (Original <code>tree</code> flag: <code>-v</code>)</li>
<li>Example: <code>rustree -v</code></li>
</ul>
</li>
<li>
<p><code>--sort-by &lt;KEY&gt;</code></p>
<ul>
<li>Description: Sort the output by the given key.</li>
<li>Possible keys:
<ul>
<li><code>name</code> (default): Alphabetical sort.</li>
<li><code>size</code>: Sort by file/directory size. Default is largest first.</li>
<li><code>mtime</code>: Sort by modification time (oldest first).</li>
<li><code>ctime</code>: Sort by status change time (oldest first).</li>
<li><code>crtime</code>: Sort by creation time (oldest first). (May not be available on all systems/files.)</li>
<li><code>version</code>: Sort by version strings in names.</li>
<li><code>lines</code>: Sort by line count (requires <code>--calculate-lines</code>). Default is most lines first.</li>
<li><code>words</code>: Sort by word count (requires <code>--calculate-words</code>). Default is most words first.</li>
<li><code>custom</code>: Sort by the output of <code>--apply-function</code>.</li>
<li><code>none</code>: No sorting (directory order).</li>
</ul>
</li>
<li>Example: <code>rustree --sort-by size</code>, <code>rustree --sort-by mtime</code></li>
</ul>
</li>
<li>
<p><code>-r, --reverse-sort</code></p>
<ul>
<li>Description: Reverse the order of the sort.</li>
<li>Example: <code>rustree -t -r</code> (newest mtime first), <code>rustree --sort-by size -r</code> (smallest size first)</li>
</ul>
</li>
<li>
<p><code>--dirs-first</code></p>
<ul>
<li>Description: List directories before files. More readable. This applies to all sorting modes and overrides the default mixing behavior. Conflicts with <code>--files-first</code>.</li>
<li>Example: <code>rustree --dirs-first</code>, <code>rustree --sort-by size --dirs-first</code></li>
</ul>
</li>
<li>
<p><code>--files-first</code></p>
<ul>
<li>Description: List files before directories. More readable. This applies to all sorting modes and overrides the default mixing behavior. Conflicts with <code>--dirs-first</code>.</li>
<li>Example: <code>rustree --files-first</code>, <code>rustree --sort-by mtime --files-first</code></li>
</ul>
</li>
</ul>
<h2 id="output-formatting-1"><a class="header" href="#output-formatting-1">Output Formatting</a></h2>
<ul>
<li><code>--output-format &lt;FORMAT&gt;</code>
<ul>
<li>Description: Specifies the output format.</li>
<li>Possible values: <code>text</code> (default), <code>markdown</code>, <code>json</code>, <code>html</code>.</li>
<li>Example: <code>rustree --output-format json | jq '.'</code></li>
</ul>
</li>
</ul>
<h3 id="html-specific-flags-when---output-format-html-is-selected"><a class="header" href="#html-specific-flags-when---output-format-html-is-selected">HTML-specific flags (when <code>--output-format html</code> is selected)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Flag</th><th>Explanation</th><th>GNU tree analogue</th></tr></thead><tbody>
<tr><td><code>--html-base-href &lt;URL&gt;</code></td><td>Prepend <code>&lt;URL&gt;/</code> to every generated hyperlink.  If the URL already ends with a <code>/</code>, it is not duplicated.</td><td><code>-H &lt;URL&gt;</code></td></tr>
<tr><td><code>--html-strip-first-component</code></td><td>Strip the first path component of every link <em>after</em> the base-href. Useful when you scan a sub-directory but want links rooted at the parent.</td><td><code>-H -&lt;URL&gt;</code></td></tr>
<tr><td><code>--html-no-links</code></td><td>Disable generation of <code>&lt;a href&gt;</code> tags – the tree is plain text inside the <code>&lt;pre&gt;</code> block.</td><td><code>--nolinks</code></td></tr>
<tr><td><code>--html-intro-file &lt;FILE&gt;</code></td><td>Use the contents of <code>FILE</code> instead of the built-in HTML header (everything before the <code>&lt;pre&gt;</code>).  Specify <code>/dev/null</code> or an empty file to suppress the header entirely.</td><td><code>--hintro=&lt;file&gt;</code></td></tr>
<tr><td><code>--html-outro-file &lt;FILE&gt;</code></td><td>Use the contents of <code>FILE</code> instead of the default footer (everything after <code>&lt;/pre&gt;</code>).  Pass <code>/dev/null</code> to omit.</td><td><code>--houtro=&lt;file&gt;</code></td></tr>
</tbody></table>
</div>
<h4 id="quick-examples"><a class="header" href="#quick-examples">Quick examples</a></h4>
<p>• Embed a browseable tree of your <code>src/</code> folder on a website:</p>
<pre><code class="language-bash">rustree src/ \
        --output-format html \
        --html-base-href https://www.example.com/src \
        &gt; src_index.html
</code></pre>
<p>• Same as above, but you ran the command in the repo-root and want to drop the leading <code>src/</code> component:</p>
<pre><code class="language-bash">rustree --output-format html \
        --html-base-href https://www.example.com \
        --html-strip-first-component \
        src/ &gt; index.html
</code></pre>
<p>• Plain HTML (no links), custom header/footer:</p>
<pre><code class="language-bash">rustree --output-format html \
        --html-no-links \
        --html-intro-file ./templates/intro.html \
        --html-outro-file ./templates/outro.html \
        &gt; tree.html
</code></pre>
<ul>
<li>
<p>When combined with LLM flags (<code>--llm-ask</code>, <code>--llm-export</code>, or <code>--dry-run</code>) the program emits a single JSON object that bundles both the tree and the LLM section.  This makes it trivial to post-process or archive the entire interaction.  Example:</p>
<pre><code class="language-bash">rustree -L 1 \
        --output-format json \
        --llm-ask "Summarise this repo" --dry-run | jq .
</code></pre>
<p>yields</p>
<pre><code class="language-json">{
  "tree": [ { "type": "directory", "name": ".", "contents": [ … ] } ],
  "llm": {
    "dry_run": true,
    "request": { "provider": "openai", "model": "gpt-4", ... },
    "question": "Summarise this repo"
  }
}
</code></pre>
</li>
<li>
<p><code>--no-summary-report</code></p>
<ul>
<li>Description: Omits printing of the file and directory report at the end of the tree listing. By default, <code>rustree</code> displays a summary line like "4 directories, 6 files" at the end of the output. This flag removes that summary line entirely.</li>
<li>Example: <code>rustree --no-summary-report</code>, <code>rustree --output-format markdown --no-summary-report</code></li>
</ul>
</li>
<li>
<p><code>--no-indent</code></p>
<ul>
<li>Description: Turn off file/directory indentation. (Original <code>tree</code> flag: <code>-i</code>)</li>
<li>Example: <code>rustree --no-indent</code></li>
</ul>
</li>
</ul>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<ul>
<li>
<p><code>-V, --version</code></p>
<ul>
<li>Description: Print version information and exit.</li>
<li>Example: <code>rustree -V</code></li>
</ul>
</li>
<li>
<p><code>-h, --help</code></p>
<ul>
<li>Description: Print help information and exit.</li>
<li>Example: <code>rustree --help</code></li>
</ul>
</li>
</ul>
<h2 id="llm-integration-1"><a class="header" href="#llm-integration-1">LLM Integration</a></h2>
<ul>
<li>
<p><code>--llm-export &lt;QUESTION&gt;</code></p>
<ul>
<li>Description: Export a formatted query for external LLM tools. This preserves the original behavior of outputting specially formatted text for piping to external LLM command-line tools.</li>
<li>Example: <code>rustree --llm-export "Analyze this project structure" | claude-cli</code></li>
</ul>
</li>
<li>
<p><code>--llm-ask &lt;QUESTION&gt;</code></p>
<ul>
<li>Description: Ask a question directly to an LLM service. Requires API key configuration.</li>
<li>Example: <code>rustree --llm-ask "What's the architecture of this project?"</code></li>
</ul>
</li>
<li>
<p><code>--llm-provider &lt;PROVIDER&gt;</code></p>
<ul>
<li>Description: Choose the LLM provider for direct queries. Supported providers: <code>openai</code>, <code>anthropic</code>, <code>cohere</code>, <code>openrouter</code>.</li>
<li>Default: <code>openai</code></li>
<li>Example: <code>rustree --llm-ask "Analyze this" --llm-provider anthropic</code></li>
</ul>
</li>
<li>
<p><code>--llm-model &lt;MODEL&gt;</code></p>
<ul>
<li>Description: Specify the model to use with the chosen provider.</li>
<li>Default models: OpenAI (<code>gpt-4</code>), Anthropic (<code>claude-3-sonnet-20240229</code>), Cohere (<code>command-r</code>), OpenRouter (<code>openai/gpt-4</code>)</li>
<li>Example: <code>rustree --llm-ask "Review this" --llm-model gpt-3.5-turbo</code></li>
</ul>
</li>
<li>
<p><code>--llm-api-key &lt;KEY&gt;</code></p>
<ul>
<li>Description: Provide API key via command line. Can also be set via environment variables or <code>.env</code> file.</li>
<li>Environment variables: <code>OPENAI_API_KEY</code>, <code>ANTHROPIC_API_KEY</code>, <code>COHERE_API_KEY</code>, <code>OPENROUTER_API_KEY</code></li>
<li>Example: <code>rustree --llm-ask "Question" --llm-api-key "your-api-key"</code></li>
</ul>
</li>
<li>
<p><code>--llm-endpoint &lt;URL&gt;</code></p>
<ul>
<li>Description: Custom endpoint URL for self-hosted or proxy services.</li>
<li>Example: <code>rustree --llm-ask "Question" --llm-endpoint "https://api.custom.com/v1"</code></li>
</ul>
</li>
<li>
<p><code>--llm-temperature &lt;FLOAT&gt;</code></p>
<ul>
<li>Description: Control response randomness. Range: 0.0 (deterministic) to 2.0 (very random).</li>
<li>Default: <code>0.7</code></li>
<li>Example: <code>rustree --llm-ask "Precise analysis" --llm-temperature 0.1</code></li>
</ul>
</li>
<li>
<p><code>--llm-max-tokens &lt;INT&gt;</code></p>
<ul>
<li>Description: Maximum number of tokens in the LLM response. Range: 1 to 32000.</li>
<li>Default: <code>1000</code></li>
<li>Example: <code>rustree --llm-ask "Brief summary" --llm-max-tokens 200</code></li>
</ul>
</li>
<li>
<p><code>--llm-generate-env</code></p>
<ul>
<li>Description: Generate a sample <code>.env</code> file template with all supported API key variables.</li>
<li>Example: <code>rustree --llm-generate-env &gt; .env</code></li>
</ul>
</li>
<li>
<p><code>--dry-run</code></p>
<ul>
<li>Description: Preview the LLM request without actually sending it. When used with <code>--llm-ask</code>, RusTree builds the full HTTP request that would be sent to the provider, displays it, and exits without making the API call. This is useful for debugging, cost estimation, and verifying the request structure before sending.</li>
<li><strong>Token Estimation</strong>: Shows approximate token counts using a 4:1 character-to-token ratio for prompts and max_tokens setting for completion. These are rough estimates for planning purposes only - actual token usage may vary significantly based on content type and provider tokenization.</li>
<li>Example: <code>rustree --llm-ask "What is this project?" --dry-run</code></li>
</ul>
</li>
<li>
<p><code>--human-friendly</code></p>
<ul>
<li>Description: Format dry-run output in a human-friendly markdown format instead of the default plain text. This option requires <code>--dry-run</code> to be enabled. The markdown format provides better structure with organized sections for configuration, headers, messages, and JSON body.</li>
<li>Example: <code>rustree --llm-ask "Analyze this project" --dry-run --human-friendly</code></li>
</ul>
<p><strong>Additional effect:</strong> When combined with <code>--size</code> / <code>-s</code>, tree listings will display file sizes in a readable form (e.g. <code>1.2 MB</code> instead of <code>1234567B</code>).</p>
</li>
</ul>
<h2 id="diff-functionality"><a class="header" href="#diff-functionality">Diff Functionality</a></h2>
<ul>
<li>
<p><code>--diff &lt;FILE&gt;</code></p>
<ul>
<li>Description: Compare the current directory tree with a previously saved snapshot file (JSON format). This feature detects additions, removals, modifications, moves/renames, and type changes.</li>
<li>Example: <code>rustree --diff baseline.json</code></li>
</ul>
</li>
<li>
<p><code>--from-tree-file &lt;FILE&gt;</code></p>
<ul>
<li>Description: When using <code>--diff</code>, use this file as the source tree instead of scanning the current directory. Enables comparison between two snapshots.</li>
<li>Example: <code>rustree --diff new.json --from-tree-file old.json</code></li>
</ul>
</li>
<li>
<p><code>--show-only &lt;TYPES&gt;</code></p>
<ul>
<li>Description: Filter diff output to show only specific types of changes. Comma-separated list.</li>
<li>Available types: <code>added</code>, <code>removed</code>, <code>modified</code>, <code>moved</code>, <code>type_changed</code></li>
<li>Example: <code>rustree --diff old.json --show-only added,removed</code></li>
</ul>
</li>
<li>
<p><code>--ignore-moves</code></p>
<ul>
<li>Description: Disable move detection in diff output. Moved files will be shown as separate add and remove operations.</li>
<li>Example: <code>rustree --diff old.json --ignore-moves</code></li>
</ul>
</li>
<li>
<p><code>--move-threshold &lt;FLOAT&gt;</code></p>
<ul>
<li>Description: Set the similarity threshold for move detection. Range: 0.0 to 1.0.</li>
<li>Default: <code>0.8</code></li>
<li>Example: <code>rustree --diff old.json --move-threshold 0.9</code></li>
</ul>
</li>
<li>
<p><code>--show-unchanged</code></p>
<ul>
<li>Description: Include unchanged files in the diff output (marked with <code>[=]</code>).</li>
<li>Example: <code>rustree --diff old.json --show-unchanged</code></li>
</ul>
</li>
<li>
<p><code>--stats-only</code></p>
<ul>
<li>Description: Show only the summary statistics without the detailed tree output.</li>
<li>Example: <code>rustree --diff old.json --stats-only</code></li>
</ul>
</li>
<li>
<p><code>--size-threshold &lt;BYTES&gt;</code></p>
<ul>
<li>Description: Only report file changes where the size difference exceeds this threshold. Accepts suffixes K, M, G.</li>
<li>Example: <code>rustree --diff old.json --size-threshold 1M</code></li>
</ul>
</li>
<li>
<p><code>--time-threshold &lt;SECONDS&gt;</code></p>
<ul>
<li>Description: Only report file changes where the modification time difference exceeds this threshold.</li>
<li>Example: <code>rustree --diff old.json --time-threshold 3600</code></li>
</ul>
</li>
</ul>
<h3 id="diff-examples"><a class="header" href="#diff-examples">Diff Examples</a></h3>
<pre><code class="language-bash"># Basic comparison with current directory
rustree --diff baseline.json

# Compare two snapshots
rustree --diff new.json --from-tree-file old.json

# Track source code changes only
rustree --diff release.json --filter-include "src/**" --show-only added,removed,modified

# Monitor with size information
rustree --diff yesterday.json --show-size-bytes --human-friendly

# Generate markdown report
rustree --diff old.json --output-format markdown &gt; changes.md

# Combine with LLM analysis
rustree --diff baseline.json --llm-ask "What are the most significant changes?"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="examples-9"><a class="header" href="#examples-9">Examples</a></h2>
<p>Here are some practical examples of how to use <code>rustree</code> from the command line.</p>
<ol>
<li>
<p><strong>Basic tree of the current directory:</strong></p>
<pre><code class="language-bash">rustree
</code></pre>
</li>
<li>
<p><strong>Tree of a specific directory, showing hidden files and up to depth 2:</strong></p>
<pre><code class="language-bash">rustree --include-hidden --depth 2 /var/log
# or using short flags
rustree -a -L 2 /var/log
</code></pre>
</li>
<li>
<p><strong>List files in <code>~/Documents</code>, showing sizes and modification times, sorted by modification time (newest first using <code>-t</code> and <code>-r</code>):</strong></p>
<pre><code class="language-bash">rustree -s -D -t -r ~/Documents
# or using long flags
rustree --show-size-bytes --show-last-modified -t --reverse-sort ~/Documents
# or using --sort-by
rustree --show-size-bytes --show-last-modified --sort-by mtime --reverse-sort ~/Documents
</code></pre>
</li>
<li>
<p><strong>Analyze a source code project, showing line counts and word counts, sorted by line count (largest first):</strong></p>
<pre><code class="language-bash">rustree --calculate-lines --calculate-words --sort-by lines -r ./my_project_src
</code></pre>
<p><strong>Enhanced Summary Report</strong>: The output now includes aggregated totals in the summary:</p>
<pre><code>src/
├── [L:  364] [W:1498] lib.rs
├── [L:   63] [W: 243] main.rs
└── core/
    ├── [L:  119] [W: 264] mod.rs
    └── [L:  200] [W: 450] util.rs

2 directories, 4 files, 746 total lines, 2,455 total words
</code></pre>
</li>
<li>
<p><strong>List directories only in the current path:</strong></p>
<pre><code class="language-bash">rustree --directory-only
# or using short flag
rustree -d
</code></pre>
</li>
<li>
<p><strong>List directories only in <code>./src</code>, showing sizes, up to depth 1:</strong></p>
<pre><code class="language-bash">rustree --directory-only --show-size-bytes --depth 1 ./src
# or using short flags
rustree -d -s -L 1 ./src
</code></pre>
</li>
<li>
<p><strong>Output the tree structure as Markdown:</strong></p>
<pre><code class="language-bash">rustree --output-format markdown &gt; project_structure.md
</code></pre>
</li>
<li>
<p><strong>Output tree without the summary report at the end:</strong></p>
<pre><code class="language-bash">rustree --no-summary-report ./my_project
</code></pre>
<p>This will display the tree structure without the summary line that normally shows directory/file counts and metadata totals like "4 directories, 6 files, 1,234 total lines".</p>
</li>
<li>
<p><strong>Generate clean markdown output without summary for documentation:</strong></p>
<pre><code class="language-bash">rustree --output-format markdown --no-summary-report ./src &gt; code_structure.md
</code></pre>
<p>Perfect for including in documentation where you want just the tree structure without file counts.</p>
</li>
<li>
<p><strong>Sort by modification time (oldest first using <code>-t</code>):</strong></p>
</li>
</ol>
<pre><code class="language-bash">rustree -t ./my_project
# or using --sort-by
rustree --sort-by mtime ./my_project
</code></pre>
<ol start="11">
<li><strong>List files in directory order (unsorted using <code>-U</code>):</strong></li>
</ol>
<pre><code class="language-bash">rustree -U ./my_project
# or using long flag
rustree --unsorted ./my_project
# or using --sort-by
rustree --sort-by none ./my_project
</code></pre>
<p>11b. <strong>Show full paths for all files (similar to tree -f):</strong></p>
<pre><code class="language-bash">rustree --full-path ./my_project
# or using short flag
rustree -f ./my_project
</code></pre>
<p><strong>Example output:</strong></p>
<pre><code>my_project/
├── README.md
├── src/
│   ├── src/main.rs
│   ├── src/lib.rs
│   └── src/utils/
│       └── src/utils/helper.rs
└── tests/
    └── tests/integration_test.rs

3 directories, 5 files
</code></pre>
<p>Notice how nested files show their full relative path from the scan root (e.g., <code>src/main.rs</code> instead of just <code>main.rs</code>).</p>
<p>11c. <strong>Combine full-path with other metadata for detailed analysis:</strong></p>
<pre><code class="language-bash">rustree -f -s --calculate-lines ./my_project
</code></pre>
<p><strong>Example output:</strong></p>
<pre><code>my_project/
├── [   1024B] [L:  50] README.md
├── src/
│   ├── [   2048B] [L: 150] src/main.rs
│   ├── [   1536B] [L: 100] src/lib.rs
│   └── src/utils/
│       └── [    512B] [L:  25] src/utils/helper.rs
└── tests/
    └── [   1280B] [L:  75] tests/integration_test.rs

3 directories, 4 files, 400 total lines, 6.25 KB total
</code></pre>
<p>This combines full paths with size and line count information, making it easy to identify specific files and their characteristics.</p>
<p>11d. <strong>Full-path output in Markdown format:</strong></p>
<pre><code class="language-bash">rustree -f --output-format markdown ./docs &gt; file_structure.md
</code></pre>
<p><strong>Generated Markdown:</strong></p>
<pre><code class="language-markdown"># docs

* README.md
* guides/
  * guides/installation.md
  * guides/usage.md
  * guides/advanced/
    * guides/advanced/configuration.md
* api/
  * api/reference.md

__3 directories, 5 files total__
</code></pre>
<p>Perfect for documentation where you want to show the complete file paths in a structured format.</p>
<ol start="12">
<li>
<p><strong>Apply the <code>count-pluses</code> function to files and sort by its custom output:</strong></p>
<pre><code class="language-bash">rustree --apply-function count-pluses --sort-by custom ./config_files
</code></pre>
<p><em>(This counts '+' characters in each file and displays the count in metadata).</em></p>
</li>
<li>
<p><strong>Display file contents after the tree structure using the <code>cat</code> function:</strong></p>
<pre><code class="language-bash">rustree --apply-function cat ./small_project
</code></pre>
<p>This will first display the directory tree, then show the full contents of each file in the project. Useful for getting a complete view of small projects or configuration directories.</p>
</li>
<li>
<p><strong>Combine <code>cat</code> function with filtering to show contents of specific files:</strong></p>
<pre><code class="language-bash">rustree --apply-function cat --filter-include "*.md|*.txt" ./docs
</code></pre>
<p>Shows the tree structure and then displays the contents of only Markdown and text files.</p>
</li>
<li>
<p><strong>Export formatted query for external LLM tools:</strong></p>
<pre><code class="language-bash">rustree --llm-export "What are the main components in this project?" ./src
</code></pre>
<p>This outputs a specially formatted query that can be piped to external LLM tools:</p>
<pre><code class="language-bash">rustree --llm-export "Analyze the architecture" | claude-cli
rustree --llm-export "Security review" | ollama run mistral
rustree --llm-export "Code quality assessment" &gt; analysis-prompt.txt
</code></pre>
</li>
<li>
<p><strong>Direct LLM integration (requires API keys):</strong></p>
<pre><code class="language-bash"># Basic LLM query with OpenAI (default provider)
rustree --llm-ask "What's the architecture of this project?"

# With specific provider and model
rustree --llm-ask "Analyze this codebase structure" \
  --llm-provider anthropic \
  --llm-model claude-3-sonnet

# With custom settings for focused analysis
rustree --llm-ask "Brief security review" \
  --llm-temperature 0.3 \
  --llm-max-tokens 500
</code></pre>
</li>
<li>
<p><strong>LLM analysis with tree filtering:</strong></p>
<pre><code class="language-bash"># Analyze only source code structure
rustree --llm-ask "What patterns do you see?" \
  --include "*.rs" --exclude "**/target/**" \
  --depth 3

# Focus on documentation structure
rustree --llm-ask "How is documentation organized?" \
  --include "*.md" --dirs-only

# Analyze project architecture at high level
rustree --llm-ask "Describe the overall architecture" \
  --depth 2 --dirs-only --size
</code></pre>
</li>
<li>
<p><strong>LLM setup and configuration:</strong></p>
<pre><code class="language-bash"># Generate .env template for API keys
rustree --llm-generate-env &gt; .env
# Then edit .env file to add your API keys

# Use with environment variables
export OPENAI_API_KEY="your-key-here"
rustree --llm-ask "Analyze this project"

# Override with CLI argument
rustree --llm-ask "Quick analysis" --llm-api-key "your-key"

# Use different providers
rustree --llm-ask "Code review" --llm-provider anthropic
rustree --llm-ask "Performance analysis" --llm-provider cohere
rustree --llm-ask "Multi-model analysis" --llm-provider openrouter
</code></pre>
</li>
<li>
<p><strong>Advanced LLM analysis examples:</strong></p>
<pre><code class="language-bash"># Architecture analysis with context
rustree --llm-ask "What architectural patterns do you see? Suggest improvements." \
  --depth 4 --dirs-only --size --llm-temperature 0.2

# Security-focused analysis
rustree --llm-ask "Are there any potential security concerns in this structure?" \
  --include "*.rs" --include "*.toml" --include "*.yml" \
  --llm-provider anthropic --llm-model claude-3-sonnet

# Performance optimization suggestions
rustree --llm-ask "What could be optimized for better performance?" \
  --size --file-stats --calculate-lines \
  --llm-max-tokens 1000

# Code organization review
rustree --llm-ask "How would you reorganize this codebase?" \
  --include "*.rs" --depth 3 \
  --llm-temperature 0.7 --llm-max-tokens 1500
</code></pre>
</li>
<li>
<p><strong>Combining LLM with metadata analysis:</strong></p>
<pre><code class="language-bash"># Analyze large files and complexity
rustree --llm-ask "Which files seem overly complex based on size and line count?" \
  --size --calculate-lines --sort-by size --reverse-sort

# Module organization analysis
rustree --llm-ask "How well are the modules organized?" \
  --apply-function dir-stats --dirs-only --depth 2

# Documentation coverage analysis
rustree --llm-ask "What documentation is missing?" \
  --include "*.md" --include "*.rs" --calculate-words
</code></pre>
</li>
<li>
<p><strong>LLM request preview and debugging:</strong></p>
<pre><code class="language-bash"># Preview what would be sent to the LLM (no API call, no cost)
rustree --llm-ask "What's the architecture of this project?" --dry-run

# Human-readable markdown format for better readability
rustree --llm-ask "Analyze the code organization" \
  --dry-run --human-friendly

# Cost estimation for complex queries
rustree --llm-ask "Detailed security analysis with recommendations" \
  --llm-max-tokens 3000 --dry-run

# Debug prompt structure before sending
rustree --llm-ask "Custom analysis question" \
  --include "*.rs" --depth 3 --size --dry-run --human-friendly

# Verify API configuration without making requests
rustree --llm-ask "Test question" --llm-provider anthropic \
  --llm-model claude-3-haiku --dry-run
</code></pre>
</li>
<li>
<p><strong>LLM workflow examples:</strong></p>
<pre><code class="language-bash"># Step 1: Preview and refine your question
rustree --llm-ask "Initial analysis" --dry-run --human-friendly

# Step 2: Export for review
rustree --llm-export "Refined analysis question" &gt; project-analysis.txt

# Step 3: Direct analysis with verified prompt
rustree --llm-ask "Focus on error handling patterns" \
  --include "*.rs" --llm-temperature 0.3

# Step 4: Compare with external tool
rustree --llm-export "Compare with previous analysis" | your-llm-tool
</code></pre>
</li>
<li>
<p><strong>List only Rust source files (<code>*.rs</code>):</strong></p>
<pre><code class="language-bash">rustree --filter-include "*.rs" ./my_project
# or using short flag
rustree -P "*.rs" ./my_project
</code></pre>
</li>
<li>
<p><strong>List only Markdown (<code>*.md</code>) or text (<code>*.txt</code>) files:</strong></p>
<pre><code class="language-bash">rustree --filter-include "*.md|*.txt" ./notes
# or equivalently
rustree -P "*.md" -P "*.txt" ./notes
</code></pre>
</li>
<li>
<p><strong>List only directories named <code>build</code> or <code>target</code>:</strong>
(Note: <code>-P</code> or <code>--filter-include</code> matches files and directories. A trailing <code>/</code> makes it specific to directories.)</p>
<pre><code class="language-bash">rustree --filter-include "build/|target/" ./my_project
# or using short flag
rustree -P "build/|target/" ./my_project
</code></pre>
</li>
<li>
<p><strong>List all Markdown files, including hidden ones (e.g., in <code>.github/</code>):</strong></p>
<pre><code class="language-bash">rustree --include-hidden --filter-include "*.md"
# or using short flags
rustree -a -P "*.md"
</code></pre>
</li>
<li>
<p><strong>List files starting with <code>test_</code> followed by any single character and then <code>.py</code>:</strong></p>
<pre><code class="language-bash">rustree --filter-include "test_?.py" ./tests
# or using short flag
rustree -P "test_?.py" ./tests
</code></pre>
</li>
<li>
<p><strong>List all files within any subdirectory named <code>docs</code>:</strong></p>
<pre><code class="language-bash">rustree --filter-include "docs/**" ./project_root
# or using short flag
rustree -P "docs/**" ./project_root
</code></pre>
</li>
<li>
<p><strong>Ignore all <code>.log</code> files:</strong></p>
<pre><code class="language-bash">rustree --filter-exclude "*.log" ./my_project
# or using short flag
rustree -I "*.log" ./my_project
</code></pre>
</li>
<li>
<p><strong>Ignore the <code>target/</code> directory and all <code>*.tmp</code> files:</strong></p>
<pre><code class="language-bash">rustree --filter-exclude "target/" --filter-exclude "*.tmp" ./my_project
# or using short flags
rustree -I "target/" -I "*.tmp" ./my_project
</code></pre>
</li>
<li>
<p><strong>Use <code>.gitignore</code> files to filter the output:</strong></p>
<pre><code class="language-bash">rustree --use-gitignore-rules ./my_git_repo
# or using the deprecated alias: rustree --gitignore ./my_git_repo
</code></pre>
</li>
<li>
<p><strong>Use a custom ignore file in addition to (or instead of) <code>.gitignore</code>:</strong></p>
<pre><code class="language-bash">rustree --gitignore-file ./.my_custom_ignores ./my_project
</code></pre>
<p>If you also want standard <code>.gitignore</code> behavior, add <code>--use-gitignore-rules</code> (or its alias <code>--gitignore</code>):</p>
<pre><code class="language-bash">rustree --use-gitignore-rules --gitignore-file ./.my_custom_ignores ./my_project
</code></pre>
</li>
<li>
<p><strong>List only <code>.TXT</code> files, case-insensitively (matching <code>file.txt</code>, <code>FILE.TXT</code>, etc.):</strong></p>
<pre><code class="language-bash">rustree --filter-include "*.TXT" --case-insensitive-filter ./my_project
# or using short flag
rustree -P "*.TXT" --case-insensitive-filter ./my_project
</code></pre>
</li>
<li>
<p><strong>Ignore all files ending with <code>.bak</code>, case-insensitively, using <code>-I</code>:</strong></p>
<pre><code class="language-bash">rustree --filter-exclude "*.bak" --case-insensitive-filter ./my_project
# or using short flag
rustree -I "*.bak" --case-insensitive-filter ./my_project
</code></pre>
</li>
<li>
<p><strong>Sort files by version (e.g., <code>file-1.0.0</code>, <code>file-1.2.0</code>, <code>file-2.0.0</code>):</strong></p>
<pre><code class="language-bash">rustree -v ./my_scripts
# or using --sort-by
rustree --sort-by version ./my_scripts
</code></pre>
</li>
<li>
<p><strong>Sort files by change time (ctime) and display change times:</strong></p>
<pre><code class="language-bash">rustree -c -D ./my_project
# or using --sort-by
rustree --sort-by ctime --show-last-modified ./my_project
</code></pre>
<p>This will sort by ctime (oldest first). The <code>-D</code> (or <code>--show-last-modified</code>) flag, when combined with <code>-c</code> (or <code>--sort-by ctime</code>), will display these ctimes.</p>
</li>
<li>
<p><strong>Sort files by creation time (crtime/btime), newest first:</strong>
(Note: Creation time might not be available on all filesystems or OS versions.)</p>
<pre><code class="language-bash">rustree --sort-by crtime -r ./my_photos
</code></pre>
</li>
<li>
<p><strong>Prune empty directories from the output:</strong>
Imagine a project with many empty <code>build/</code> or <code>log/</code> subdirectories.</p>
<pre><code class="language-bash">rustree --prune-empty-directories ./my_project
# or using the alias
rustree --prune ./my_project
</code></pre>
<p>This will list <code>my_project</code>, but any directories within it (or nested deeper) that become empty after other filters (like <code>-P</code>, <code>-I</code>, or gitignore) are applied will not be shown.</p>
</li>
<li>
<p><strong>Prune empty directories while listing only <code>.rs</code> files:</strong></p>
<pre><code class="language-bash">rustree -P "*.rs" --prune ./my_rust_project
</code></pre>
<p>In this case, if a directory <code>src/utils/</code> contains only <code>helper.txt</code> and <code>mod.rs</code>, after <code>-P "*.rs"</code> is applied, <code>helper.txt</code> is filtered out. If <code>src/utils/</code> now only effectively contains <code>mod.rs</code>, it's not empty. However, if <code>src/empty_module/</code> contained only <code>old_code.txt</code>, it would first be filtered by <code>-P</code>, then <code>src/empty_module/</code> would become empty and subsequently pruned by <code>--prune</code>.</p>
</li>
<li>
<p><strong>List directories before files for better readability:</strong></p>
<pre><code class="language-bash">rustree --dirs-first ./my_project
</code></pre>
<p>This will show all directories before any files at each level, making the structure more readable by grouping similar types together.</p>
</li>
<li>
<p><strong>List files before directories:</strong></p>
<pre><code class="language-bash">rustree --files-first ./my_project
</code></pre>
<p>This will show all files before any directories at each level.</p>
</li>
<li>
<p><strong>Combine directory ordering with different sort modes:</strong></p>
<pre><code class="language-bash"># Directories first, sorted by modification time
rustree --dirs-first --sort-by mtime ./my_project

# Files first, sorted by size (largest first)
rustree --files-first --sort-by size -r ./my_project

# Directories first with version sorting
rustree --dirs-first -v ./releases
</code></pre>
</li>
<li>
<p><strong>Directory ordering with metadata and filtering:</strong></p>
<pre><code class="language-bash"># Show directories first with sizes and modification times, only for .rs files and directories
rustree --dirs-first -s -D -P "*.rs|*/" ./src

# Files first, showing line counts for text files
rustree --files-first --calculate-lines -P "*.txt|*.md|*/" ./docs
</code></pre>
</li>
</ol>
<h2 id="apply-function-examples"><a class="header" href="#apply-function-examples">Apply Function Examples</a></h2>
<ol start="43">
<li>
<p><strong>Get directory statistics showing file count, directory count, and total size:</strong></p>
<pre><code class="language-bash">rustree --apply-function dir-stats --show-size-bytes ./my_project
</code></pre>
<p>This shows statistics like <code>[F: "5f,2d,1024B"]</code> for each directory, indicating 5 files, 2 subdirectories, and 1024 bytes total.</p>
</li>
<li>
<p><strong>Count files in each directory:</strong></p>
<pre><code class="language-bash">rustree --apply-function count-files ./project
</code></pre>
<p>Shows <code>[F: "3"]</code> for directories containing 3 files.</p>
</li>
<li>
<p><strong>Calculate total size of files in each directory:</strong></p>
<pre><code class="language-bash">rustree --apply-function size-total --show-size-bytes ./downloads
</code></pre>
<p>Note: <code>--show-size-bytes</code> must be enabled for size-total to work properly.</p>
</li>
<li>
<p><strong>Apply function only to specific directories using patterns:</strong></p>
<pre><code class="language-bash"># Only apply dir-stats to src directories
rustree --apply-function dir-stats --apply-include "src*" ./workspace

# Apply count-files to all directories except target and build
rustree --apply-function count-files --apply-exclude "target/*" --apply-exclude "build/*" ./project
</code></pre>
</li>
<li>
<p><strong>Use pattern files for complex filtering:</strong></p>
<p>Create a file <code>include-patterns.txt</code>:</p>
<pre><code># Include source directories
src/*
lib/*
# Include documentation
docs/*
</code></pre>
<p>Create a file <code>exclude-patterns.txt</code>:</p>
<pre><code># Exclude build artifacts
*target*
*build*
# Exclude temporary files
*.tmp
</code></pre>
<p>Then use:</p>
<pre><code class="language-bash">rustree --apply-function dir-stats \
        --apply-include-from ./include-patterns.txt \
        --apply-exclude-from ./exclude-patterns.txt ./project
</code></pre>
</li>
<li>
<p><strong>Combine cat function with selective application:</strong></p>
<pre><code class="language-bash"># Show contents of only configuration files
rustree --apply-function cat --apply-include "*.toml" --apply-include "*.yml" ./config

# Show contents excluding sensitive files
rustree --apply-function cat --apply-exclude "*secret*" --apply-exclude "*key*" ./scripts
</code></pre>
</li>
</ol>
<h2 id="file-based-pattern-filtering-examples"><a class="header" href="#file-based-pattern-filtering-examples">File-based Pattern Filtering Examples</a></h2>
<p>The <code>--filter-include-from</code> and <code>--filter-exclude-from</code> options allow you to maintain pattern lists in separate files, which is especially useful for complex projects or when sharing filter configurations across teams.</p>
<ol start="56">
<li>
<p><strong>Use file-based include patterns:</strong></p>
<p>Create a file <code>include-patterns.txt</code>:</p>
<pre><code># Include only source code files
*.rs
*.go
*.js
*.ts

# Include configuration files
*.toml
*.yml
*.yaml

# Include documentation
*.md
README*
</code></pre>
<p>Then use:</p>
<pre><code class="language-bash">rustree --filter-include-from ./include-patterns.txt ./project
</code></pre>
</li>
<li>
<p><strong>Use file-based exclude patterns:</strong></p>
<p>Create a file <code>exclude-patterns.txt</code>:</p>
<pre><code># Build artifacts
target/
build/
dist/

# Dependencies
node_modules/
vendor/

# Temporary files
*.tmp
*.log
*.swp
.DS_Store
</code></pre>
<p>Then use:</p>
<pre><code class="language-bash">rustree --filter-exclude-from ./exclude-patterns.txt ./project
</code></pre>
</li>
<li>
<p><strong>Combine file-based and command-line patterns:</strong></p>
<pre><code class="language-bash"># Use patterns from file and add additional CLI patterns
rustree --filter-include-from ./src-patterns.txt \
        --filter-include "*.md" \
        --filter-exclude "*.test.js" ./project
</code></pre>
</li>
<li>
<p><strong>Multiple pattern files:</strong></p>
<pre><code class="language-bash"># Load patterns from multiple files
rustree --filter-include-from ./core-patterns.txt \
        --filter-include-from ./docs-patterns.txt \
        --filter-exclude-from ./ignore-patterns.txt ./workspace
</code></pre>
</li>
<li>
<p><strong>Project-specific filtering setup:</strong></p>
<p>Create a <code>.rustree</code> directory in your project with pattern files:</p>
<pre><code class="language-bash">mkdir .rustree
echo "*.rs" &gt; .rustree/rust-files.txt
echo "*.md" &gt; .rustree/docs.txt
echo "target/" &gt; .rustree/ignore.txt
</code></pre>
<p>Then use consistently across the team:</p>
<pre><code class="language-bash"># Show only Rust files
rustree --filter-include-from .rustree/rust-files.txt ./

# Show documentation structure
rustree --filter-include-from .rustree/docs.txt --dirs-first ./

# Full tree excluding build artifacts
rustree --filter-exclude-from .rustree/ignore.txt ./
</code></pre>
</li>
<li>
<p><strong>Combine with gitignore patterns:</strong></p>
<pre><code class="language-bash"># Use gitignore AND custom exclude patterns
rustree --use-gitignore-rules \
        --filter-exclude-from ./additional-ignores.txt ./project

# Override gitignore with specific includes
rustree --use-gitignore-rules \
        --filter-include-from ./force-include.txt ./project
</code></pre>
</li>
<li>
<p><strong>Pattern file with comments for documentation:</strong></p>
<p>Create a well-documented <code>analysis-patterns.txt</code>:</p>
<pre><code># Code Analysis Patterns
# =====================

# Core source files
src/**/*.rs
lib/**/*.rs

# Test files (for separate analysis)
tests/**/*.rs
benches/**/*.rs

# Configuration that affects behavior
Cargo.toml
.cargo/config.toml
rust-toolchain.toml

# Exclude examples and docs from analysis
# (uncomment if needed)
# !examples/
# !docs/
</code></pre>
<p>Use for consistent code analysis:</p>
<pre><code class="language-bash">rustree --filter-include-from ./analysis-patterns.txt \
        --calculate-lines --sort-by size -r ./
</code></pre>
</li>
<li>
<p><strong>Directory analysis for large projects:</strong></p>
<pre><code class="language-bash"># Get overview of all subdirectories with statistics
rustree -d --apply-function dir-stats --show-size-bytes --sort-by custom -r ./large_project
</code></pre>
<p>This shows only directories (<code>-d</code>), applies statistics function, enables size collection, and sorts by the statistics output in reverse order (largest/most complex directories first).</p>
</li>
<li>
<p><strong>Analyze code organization:</strong></p>
<pre><code class="language-bash"># Count Rust files in each module directory
rustree --apply-function count-files --apply-include "*.rs" -d ./src

# Get comprehensive statistics for source directories only
rustree --apply-function dir-stats --apply-include "src*" --apply-include "lib*" ./workspace
</code></pre>
</li>
</ol>
<h2 id="metadata-aggregation-examples"><a class="header" href="#metadata-aggregation-examples">Metadata Aggregation Examples</a></h2>
<p>The summary report now automatically aggregates metadata values, providing totals for lines, words, sizes, and apply function outputs.</p>
<ol start="51">
<li>
<p><strong>Get comprehensive project statistics:</strong></p>
<pre><code class="language-bash">rustree --calculate-lines --calculate-words --show-size-bytes ./my_project
</code></pre>
<p>Output includes totals in the summary:</p>
<pre><code>my_project/
├── [   1024B] [L:  50] [W: 250] README.md
├── [   2048B] [L: 100] [W: 500] main.rs
└── src/
    ├── [   3072B] [L: 150] [W: 750] lib.rs
    └── [   1536B] [L:  75] [W: 375] util.rs

2 directories, 4 files, 375 total lines, 1,875 total words, 7.7 KB total
</code></pre>
</li>
<li>
<p><strong>Analyze large codebases with human-readable totals:</strong></p>
<pre><code class="language-bash">rustree --calculate-lines --depth 2 ./large_project
</code></pre>
<p>Automatically formats large numbers with thousand separators:</p>
<pre><code>large_project/
├── [L:12345] frontend/
├── [L: 8765] backend/
└── [L: 4321] docs/

4 directories, 156 files, 125,431 total lines
</code></pre>
</li>
<li>
<p><strong>Combine size analysis with directory statistics:</strong></p>
<pre><code class="language-bash">rustree --show-size-bytes --apply-function dir-stats ./project
</code></pre>
<p>Shows both individual file sizes and aggregated directory statistics:</p>
<pre><code>project/
├── [   512B] config.toml
├── [F: "3f,0d,1536B"] src/
│   ├── [  1024B] main.rs
│   └── [   512B] lib.rs
└── [F: "2f,0d,256B"] tests/
    ├── [  128B] test1.rs
    └── [  128B] test2.rs

3 directories, 5 files, 2.3 KB total, 1.8 KB total (from function)
</code></pre>
</li>
<li>
<p><strong>Quick project overview with multiple metadata types:</strong></p>
<pre><code class="language-bash">rustree --depth 1 --calculate-lines --calculate-words --show-size-bytes ./workspace
</code></pre>
<p>Perfect for getting a high-level overview of project complexity:</p>
<pre><code>workspace/
├── [  45.2 KB] [L:1200] [W:6000] frontend/
├── [  32.1 KB] [L: 900] [W:4500] backend/
├── [  12.8 KB] [L: 400] [W:2000] shared/
└── [   5.5 KB] [L: 150] [W: 750] docs/

5 directories, 87 files, 2,650 total lines, 13,250 total words, 95.6 KB total
</code></pre>
</li>
<li>
<p><strong>Compare module sizes in a Rust project:</strong></p>
<pre><code class="language-bash">rustree --depth 2 --show-size-bytes --filter-include "*.rs|*/" --sort-by size -r ./src
</code></pre>
<p>Shows Rust modules sorted by size with total calculations:</p>
<pre><code>src/
├── [  15.2 KB] core/
├── [  12.8 KB] utils/
├── [   8.4 KB] cli/
├── [   3.2 KB] main.rs
└── [   1.1 KB] lib.rs

4 directories, 45 files, 40.7 KB total
</code></pre>
</li>
<li>
<p><strong>Markdown output with metadata aggregation for documentation:</strong></p>
<pre><code class="language-bash">rustree --output-format markdown --calculate-lines --depth 2 ./api &gt; api_overview.md
</code></pre>
<p>Generates markdown with totals:</p>
<pre><code class="language-markdown"># ./api

* handlers/ 1250L
* models/ 800L
* routes/ 600L
* main.rs 150L

__2 directories, 25 files, 2,800 total lines total__
</code></pre>
</li>
</ol>
<p>Note: The enhanced summary report automatically detects which metadata types are being displayed and includes appropriate totals. No additional flags are needed - the aggregation happens automatically when metadata options like <code>--calculate-lines</code>, <code>--calculate-words</code>, or <code>--show-size-bytes</code> are used.</p>
<h2 id="tree-diff-examples"><a class="header" href="#tree-diff-examples">Tree Diff Examples</a></h2>
<p>RusTree includes powerful directory comparison capabilities to track changes over time. These examples show how to use the diff feature for various workflows.</p>
<h3 id="basic-diff-operations-1"><a class="header" href="#basic-diff-operations-1">Basic Diff Operations</a></h3>
<ol start="57">
<li>
<p><strong>Create a baseline snapshot and compare current state:</strong></p>
<pre><code class="language-bash"># Save current state as baseline
rustree --output-format json &gt; baseline.json

# Later, after making changes, compare with baseline
rustree --diff baseline.json
</code></pre>
</li>
<li>
<p><strong>Compare two specific snapshots:</strong></p>
<pre><code class="language-bash"># Compare two saved snapshots
rustree --diff new_snapshot.json --from-tree-file old_snapshot.json
</code></pre>
</li>
<li>
<p><strong>Diff with output formatting:</strong></p>
<pre><code class="language-bash"># Text output (default) - shows tree structure with change markers
rustree --diff baseline.json

# Markdown format for documentation
rustree --diff baseline.json --output-format markdown &gt; changes.md

# JSON format for programmatic processing
rustree --diff baseline.json --output-format json &gt; diff_report.json

# HTML format for interactive viewing
rustree --diff baseline.json --output-format html &gt; diff_report.html
</code></pre>
</li>
</ol>
<h3 id="development-workflow-monitoring"><a class="header" href="#development-workflow-monitoring">Development Workflow Monitoring</a></h3>
<ol start="60">
<li>
<p><strong>Track changes during feature development:</strong></p>
<pre><code class="language-bash"># Save snapshot before starting feature
rustree --output-format json &gt; feature-start.json

# After development, see what changed
rustree --diff feature-start.json --filter-include "src/**" "tests/**"

# Focus on specific file types
rustree --diff feature-start.json --filter-include "*.rs" --show-size-bytes
</code></pre>
</li>
<li>
<p><strong>Monitor build artifact generation:</strong></p>
<pre><code class="language-bash"># Snapshot before build
rustree --output-format json &gt; pre-build.json

# Compare after build to see what was generated
rustree --diff pre-build.json --filter-include "target/**" --show-size-bytes --human-friendly
</code></pre>
</li>
<li>
<p><strong>Track refactoring changes:</strong></p>
<pre><code class="language-bash"># Before refactoring
rustree --filter-include "src/**" --output-format json &gt; before-refactor.json

# After refactoring - understand structural changes
rustree --diff before-refactor.json src/ --show-moves-only --move-threshold 0.9
</code></pre>
</li>
</ol>
<h3 id="code-review-and-analysis"><a class="header" href="#code-review-and-analysis">Code Review and Analysis</a></h3>
<ol start="63">
<li>
<p><strong>Diff with LLM analysis for code review:</strong></p>
<pre><code class="language-bash"># Analyze structural changes with AI
rustree --diff feature-branch.json \
  --llm-ask "Summarize the structural changes and their impact" \
  --llm-provider anthropic

# Focus on specific concerns
rustree --diff baseline.json \
  --filter-include "*.rs" \
  --llm-ask "Are there any potential security or performance concerns in these changes?"
</code></pre>
</li>
<li>
<p><strong>Generate change reports for team review:</strong></p>
<pre><code class="language-bash"># Comprehensive markdown report
rustree --diff sprint-start.json \
  --output-format markdown \
  --show-size-bytes \
  --show-last-modified &gt; sprint-changes.md

# Export for external analysis tools
rustree --diff baseline.json \
  --llm-export "Analyze code quality impact of these changes" &gt; review-prompt.txt
</code></pre>
</li>
</ol>
<h3 id="move-detection-and-rename-tracking"><a class="header" href="#move-detection-and-rename-tracking">Move Detection and Rename Tracking</a></h3>
<ol start="65">
<li>
<p><strong>Track file moves and renames:</strong></p>
<pre><code class="language-bash"># Default move detection (80% similarity threshold)
rustree --diff old-structure.json

# Strict move detection - only very similar files
rustree --diff old-structure.json --move-threshold 0.95

# Loose move detection - catch more potential moves
rustree --diff old-structure.json --move-threshold 0.5

# Disable move detection - treat moves as separate add/remove
rustree --diff old-structure.json --ignore-moves
</code></pre>
</li>
<li>
<p><strong>Focus on move analysis:</strong></p>
<pre><code class="language-bash"># Show only moved/renamed files
rustree --diff restructure-before.json --show-only moved

# Show moves with detailed similarity scores
rustree --diff restructure-before.json --output-format json | jq '.changes[] | select(.change_type == "moved")'
</code></pre>
</li>
</ol>
<h3 id="system-administration-and-monitoring"><a class="header" href="#system-administration-and-monitoring">System Administration and Monitoring</a></h3>
<ol start="67">
<li>
<p><strong>Monitor configuration directories:</strong></p>
<pre><code class="language-bash"># Daily configuration monitoring
rustree --output-format json /etc &gt; daily-etc-$(date +%Y%m%d).json

# Compare with previous day
rustree --diff daily-etc-$(date -d yesterday +%Y%m%d).json /etc \
  --show-last-modified \
  --sort-by mtime
</code></pre>
</li>
<li>
<p><strong>Track system changes over time:</strong></p>
<pre><code class="language-bash"># Monitor important system directories
rustree --diff system-baseline.json /etc /opt /usr/local \
  --filter-exclude "*.log" "*.tmp" \
  --show-size-bytes

# Focus on recently changed files
rustree --diff yesterday.json \
  --sort-by mtime \
  --show-last-modified \
  --dirs-first
</code></pre>
</li>
</ol>
<h3 id="advanced-diff-filtering"><a class="header" href="#advanced-diff-filtering">Advanced Diff Filtering</a></h3>
<ol start="69">
<li>
<p><strong>Diff with complex filtering:</strong></p>
<pre><code class="language-bash"># Compare only source code changes
rustree --diff baseline.json \
  --filter-include "*.rs" "*.toml" "*.md" \
  --filter-exclude "**/target/**" \
  --depth 5

# Use pattern files for consistent filtering
echo "*.rs" &gt; src-patterns.txt
echo "*.md" &gt;&gt; src-patterns.txt
echo "target/" &gt; ignore-patterns.txt

rustree --diff baseline.json \
  --filter-include-from src-patterns.txt \
  --filter-exclude-from ignore-patterns.txt
</code></pre>
</li>
<li>
<p><strong>Size-based change analysis:</strong></p>
<pre><code class="language-bash"># Focus on size changes
rustree --diff baseline.json \
  --show-size-bytes \
  --human-friendly \
  --sort-by size \
  --reverse-sort

# Track large file additions
rustree --diff baseline.json \
  --show-only added \
  --show-size-bytes \
  --sort-by size \
  --reverse-sort
</code></pre>
</li>
</ol>
<h3 id="diff-output-customization"><a class="header" href="#diff-output-customization">Diff Output Customization</a></h3>
<ol start="71">
<li>
<p><strong>Customize diff display:</strong></p>
<pre><code class="language-bash"># Show unchanged files for complete picture
rustree --diff baseline.json --show-unchanged

# Statistics only - no detailed tree
rustree --diff baseline.json --stats-only

# Specific change types only
rustree --diff baseline.json --show-only added,removed
rustree --diff baseline.json --show-only modified,type_changed
</code></pre>
</li>
<li>
<p><strong>Combine diff with existing features:</strong></p>
<pre><code class="language-bash"># Diff with line count analysis
rustree --diff baseline.json \
  --calculate-lines \
  --filter-include "*.rs" \
  --sort-by lines \
  --reverse-sort

# Diff with full metadata
rustree --diff baseline.json \
  --show-size-bytes \
  --show-last-modified \
  --calculate-lines \
  --human-friendly \
  --full-path
</code></pre>
</li>
</ol>
<h3 id="automation-and-scripting-1"><a class="header" href="#automation-and-scripting-1">Automation and Scripting</a></h3>
<ol start="73">
<li>
<p><strong>Automated change detection scripts:</strong></p>
<pre><code class="language-bash">#!/bin/bash
# Daily change monitoring script

DATE=$(date +%Y%m%d)
YESTERDAY=$(date -d yesterday +%Y%m%d)
PROJECT_DIR="/path/to/project"

# Generate today's snapshot
rustree --output-format json "$PROJECT_DIR" &gt; "snapshot-$DATE.json"

# Compare with yesterday if exists
if [ -f "snapshot-$YESTERDAY.json" ]; then
    echo "Changes since yesterday:"
    rustree --diff "snapshot-$YESTERDAY.json" "$PROJECT_DIR" \
      --filter-exclude "*.log" "*.tmp" \
      --show-size-bytes
fi
</code></pre>
</li>
<li>
<p><strong>CI/CD integration example:</strong></p>
<pre><code class="language-bash"># In CI pipeline - detect structural changes
rustree --output-format json &gt; "build-$BUILD_NUMBER.json"

if [ -f "baseline.json" ]; then
    # Generate change report
    rustree --diff baseline.json \
      --output-format markdown \
      --filter-include "src/**" "tests/**" &gt; changes.md
    
    # Check for significant changes
    CHANGES=$(rustree --diff baseline.json --stats-only | grep "files added\|files removed" | wc -l)
    if [ "$CHANGES" -gt 0 ]; then
        echo "Structural changes detected - review required"
    fi
fi
</code></pre>
</li>
</ol>
<h3 id="troubleshooting-and-edge-cases"><a class="header" href="#troubleshooting-and-edge-cases">Troubleshooting and Edge Cases</a></h3>
<ol start="75">
<li>
<p><strong>Handle large directories efficiently:</strong></p>
<pre><code class="language-bash"># Use depth limits for large projects
rustree --diff baseline.json --depth 3

# Focus on specific subdirectories
rustree --diff baseline.json src/ tests/

# Use filtering to reduce scope
rustree --diff baseline.json \
  --filter-include "*.rs" \
  --filter-exclude "**/target/**" \
  --prune-empty-directories
</code></pre>
</li>
<li>
<p><strong>Debug diff issues:</strong></p>
<pre><code class="language-bash"># Verify snapshot contents
rustree --output-format json . | jq '.nodes | length'

# Check path normalization
rustree --diff baseline.json --full-path

# Test move detection settings
rustree --diff baseline.json --move-threshold 0.1  # Very loose
rustree --diff baseline.json --ignore-moves        # Disable completely
</code></pre>
</li>
</ol>
<p>These examples demonstrate the flexibility and power of RusTree's diff functionality for various use cases from development monitoring to system administration. The diff feature integrates seamlessly with all existing RusTree options for filtering, formatting, and analysis.</p>
<p>These examples cover common use cases. Combine options as needed to achieve your desired output! Remember to use <code>rustree --help</code> for a full list of options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="persistent-configuration-files"><a class="header" href="#persistent-configuration-files">Persistent Configuration Files</a></h1>
<p>RusTree can read default options from <strong>TOML</strong> files, so you don’t have to
repeat long command-lines every time.</p>
<h2 id="search-order"><a class="header" href="#search-order">Search order</a></h2>
<ol>
<li>Paths supplied via <code>--config-file &lt;FILE&gt;</code> (can be given multiple times; <em>last
one wins</em>).</li>
<li>Per-project file <code>./.rustree/config.toml</code> (looked-up from the working dir).</li>
<li>Global file <code>$XDG_CONFIG_HOME/rustree/config.toml</code> (or <code>~/.config/rustree/…</code>
on macOS / Linux).</li>
<li>Built-in defaults.</li>
</ol>
<p>Disable project/global discovery with <code>--no-config</code>.</p>
<h2 id="file-format"><a class="header" href="#file-format">File format</a></h2>
<p>TOML sections map 1-to-1 to option groups:</p>
<pre><code class="language-toml">[listing]
show_hidden = true
max_depth   = 2

[filtering]
match_patterns  = ["*.rs", "Cargo.*"]
ignore_patterns = ["target/*"]

[sorting]
sort_by = "size"
reverse = true      # largest files first

[metadata]
show_size_bytes    = true
calculate_line_count = true

[output]
format = "markdown"

[llm]
provider    = "openai"        # Supported: openai, anthropic, cohere, openrouter
model       = "gpt-4o"         # Optional - uses provider's default if not specified
api_key_env = "OPENAI_API_KEY" # Recommended – keeps secrets out of the file
# api_key     = "sk-..."       # Direct API key (not recommended in shared configs)
# endpoint    = "https://..."  # Custom endpoint for self-hosted or proxy services
# temperature = 0.7            # Model temperature (0.0-2.0)
# max_tokens  = 1000           # Maximum response tokens
</code></pre>
<p>Unknown keys are ignored but a warning is printed, so your config keeps working
after version upgrades.</p>
<h2 id="creating-a-template"><a class="header" href="#creating-a-template">Creating a template</a></h2>
<p>Run:</p>
<pre><code class="language-bash">rustree --generate-config &gt; .rustree/config.toml
</code></pre>
<p>Then open the file and uncomment / edit the options you want.</p>
<h2 id="security-notes"><a class="header" href="#security-notes">Security notes</a></h2>
<p>If you use <code>api_key_file</code>, make sure the file is <strong>not</strong> world-readable. RusTree
prints a warning when it detects permissive modes (<code>chmod 600 &lt;file&gt;</code> is a good
baseline).</p>
<h2 id="precedence-vs-cli"><a class="header" href="#precedence-vs-cli">Precedence vs CLI</a></h2>
<p>Values from configuration files are applied <em>before</em> parsing the CLI, therefore
<strong>command-line flags always override</strong> TOML settings.</p>
<hr />
<p>See the full option list in the next chapter or by running <code>rustree --help</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-usage-api"><a class="header" href="#library-usage-api">Library Usage (API)</a></h1>
<p>Beyond the command-line tool, <code>rustree</code> can be used as a library in your own Rust projects. This allows you to programmatically generate and process directory tree information.</p>
<h2 id="adding-rustree-as-a-dependency"><a class="header" href="#adding-rustree-as-a-dependency">Adding RusTree as a Dependency</a></h2>
<p>To use <code>rustree</code> in your project, add it to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rustree = "0.1.0" # Replace with the desired version
</code></pre>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<p>The library revolves around a few key components:</p>
<ul>
<li><a href="./library_usage/concepts.html#rustreelibconfig"><code>RustreeLibConfig</code></a>: A struct to configure the behavior of the tree generation (depth, hidden files, analysis options, sorting, etc.).</li>
<li><a href="./library_usage/concepts.html#nodeinfo"><code>NodeInfo</code></a>: A struct representing a single entry (file or directory) in the tree, containing its metadata and analysis results.</li>
<li><a href="./library_usage/concepts.html#get_tree_nodes"><code>get_tree_nodes()</code></a>: The main function to walk a directory, analyze entries, and return a <code>Vec&lt;NodeInfo&gt;</code>.</li>
<li><a href="./library_usage/concepts.html#format_nodes"><code>format_nodes()</code></a>: A function to format a <code>Vec&lt;NodeInfo&gt;</code> into a string representation (e.g., text tree, Markdown).</li>
<li>Enums for options like <a href="./library_usage/concepts.html#sortkey"><code>SortKey</code></a>, <a href="./library_usage/concepts.html#liboutputformat"><code>LibOutputFormat</code></a>, etc.</li>
</ul>
<h2 id="sub-sections"><a class="header" href="#sub-sections">Sub-sections:</a></h2>
<ul>
<li><a href="./library_usage/concepts.html">Core Concepts</a>: Detailed explanation of the main types and functions.</li>
<li><a href="./library_usage/examples.html">Examples</a>: Code examples demonstrating how to use the library.</li>
</ul>
<p>The API documentation generated by <code>cargo doc</code> (and available on <code>docs.rs</code> if published) provides the most detailed reference for all public items.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="core-library-concepts"><a class="header" href="#core-library-concepts">Core Library Concepts</a></h2>
<p>Understanding these core components will help you effectively use the <code>rustree</code> library.</p>
<h3 id="rustreelibconfig"><a class="header" href="#rustreelibconfig"><code>RustreeLibConfig</code></a></h3>
<p>This struct is central to controlling how <code>rustree</code> behaves. Following the recent refactoring (commit 333f1c7), all configuration types are now defined in <code>src/core/options/</code> but remain accessible through the <code>rustree</code> crate's public API. You create an instance of <code>RustreeLibConfig</code> and set fields within these sub-structs:</p>
<ul>
<li><strong><code>input_source: InputSourceOptions</code></strong>:
<ul>
<li><code>root_display_name</code>: How the root directory is named in the output.</li>
<li><code>root_node_size</code>: Optional size of the root node itself, used by formatters if <code>metadata.show_size_bytes</code> is true.</li>
<li><code>root_is_directory</code>: Indicates if the root path itself is a directory, used by formatters.</li>
</ul>
</li>
<li><strong><code>listing: ListingOptions</code></strong>:
<ul>
<li><code>max_depth</code>: The maximum depth of traversal.</li>
<li><code>show_hidden</code>: Whether to include hidden files/directories.</li>
<li><code>list_directories_only</code>: If <code>true</code>, only directories (including symlinks to directories) are included in the results.</li>
<li><code>show_full_path</code>: If <code>true</code>, formatters display the full relative path for each entry instead of just the filename. Equivalent to the CLI <code>-f</code>/<code>--full-path</code> flag.</li>
</ul>
</li>
<li><strong><code>filtering: FilteringOptions</code></strong>:
<ul>
<li><code>match_patterns</code>: <code>Option&lt;Vec&lt;String&gt;&gt;</code> containing patterns to filter entries. Only entries matching any pattern will be included. Corresponds to the CLI <code>-P</code>/<code>--filter-include</code> options.</li>
<li><code>ignore_patterns</code>: <code>Option&lt;Vec&lt;String&gt;&gt;</code> containing patterns to ignore entries. Entries matching any pattern will be excluded. Corresponds to the CLI <code>-I</code>/<code>--filter-exclude</code> options.</li>
<li><code>use_gitignore_rules</code>: If <code>true</code>, standard gitignore files (<code>.gitignore</code>, global gitignore, etc.) will be used for filtering.</li>
<li><code>gitignore_file</code>: <code>Option&lt;Vec&lt;PathBuf&gt;&gt;</code> specifying paths to custom files to be used as additional gitignore files.</li>
<li><code>case_insensitive_filter</code>: If <code>true</code>, all pattern matching (<code>match_patterns</code>, <code>ignore_patterns</code>, and gitignore processing) will be case-insensitive.</li>
<li><code>prune_empty_directories</code>: If <code>true</code>, empty directories are removed from the results after initial walking and filtering, but before sorting. An empty directory is one that contains no files and no non-empty subdirectories after other filters have been applied.</li>
</ul>
</li>
<li><strong><code>sorting: SortingOptions</code></strong>:
<ul>
<li><code>sort_by</code>: An optional <code>SortKey</code> to sort sibling entries.</li>
<li><code>reverse_sort</code>: Whether to reverse the sort order.</li>
<li><code>files_before_directories</code>: A <code>bool</code> (default <code>true</code>) that, when sorting by size, determines if files and symlinks are grouped before directories. If <code>false</code>, types are intermingled based purely on size.</li>
</ul>
</li>
<li><strong><code>metadata: MetadataOptions</code></strong>:
<ul>
<li><code>show_size_bytes</code>: Whether to collect and report file sizes in bytes. Applies to directories as well.</li>
<li><code>show_last_modified</code>: Whether to collect and report last modification times (mtime).</li>
<li><code>report_change_time</code>: Whether to collect and report last status change times (ctime).</li>
<li><code>report_creation_time</code>: Whether to collect and report creation times (btime/crtime).</li>
<li><code>calculate_line_count</code>, <code>calculate_word_count</code>: Whether to perform these analyses on files.</li>
<li><code>apply_function</code>: An optional <code>BuiltInFunction</code> to apply to file contents.</li>
<li><code>report_permissions</code>: (Currently not exposed via CLI, defaults to false).</li>
</ul>
</li>
<li><strong><code>misc: MiscOptions</code></strong>:
<ul>
<li><code>no_summary_report</code>: Whether to omit the summary report at the end.</li>
<li><code>human_friendly</code>: Whether to display sizes in human-readable format.</li>
<li><code>no_color</code>: Whether to disable colored output.</li>
<li><code>verbose</code>: Whether to show verbose output.</li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustree::{
    RustreeLibConfig, SortKey, BuiltInFunction,
    InputSourceOptions, ListingOptions, FilteringOptions, SortingOptions, MetadataOptions,
};
use std::path::PathBuf;

let config = RustreeLibConfig {
    input_source: InputSourceOptions {
        root_display_name: "MyProject".to_string(),
        root_node_size: None, // Typically set by the CLI handler or by checking metadata
        root_is_directory: true, // Typically set by the CLI handler or by checking metadata
        ..Default::default()
    },
    listing: ListingOptions {
        max_depth: Some(3),
        show_hidden: false,
        list_directories_only: false,
        show_full_path: true, // Show full relative paths for files
        ..Default::default()
    },
    filtering: FilteringOptions {
        match_patterns: Some(vec!["*.rs".to_string(), "src/".to_string()]), // Example -P patterns
        ignore_patterns: Some(vec!["*.log".to_string(), "target/".to_string()]), // Example -I patterns
        use_gitignore_rules: true,
        gitignore_file: Some(vec![PathBuf::from(".customignore")]),
        case_insensitive_filter: false,
        ..Default::default()
    },
    sorting: SortingOptions {
        sort_by: Some(SortKey::Size),
        reverse_sort: false, // Size sort is descending by default, so false means largest first.
        files_before_directories: true, // Default behavior
        ..Default::default()
    },
    metadata: MetadataOptions {
        show_size_bytes: true,
        show_last_modified: true,
        report_change_time: false,
        report_creation_time: false,
        calculate_line_count: false, // Example: not calculating line count
        apply_function: Some(BuiltInFunction::Cat), // Example: applying cat function to display file contents
        ..Default::default()
    },
    ..Default::default() // Use defaults for misc and other fields if not specified
};
<span class="boring">}</span></code></pre></pre>
<h3 id="nodeinfo"><a class="header" href="#nodeinfo"><code>NodeInfo</code></a></h3>
<p>Each file or directory encountered during the scan is represented by a <code>NodeInfo</code> struct (defined in <code>src/core/tree/node.rs</code>). It contains:</p>
<ul>
<li><code>path</code>: The full <code>PathBuf</code> to the entry.</li>
<li><code>name</code>: The file or directory name as a <code>String</code>.</li>
<li><code>node_type</code>: A <code>NodeType</code> enum (<code>File</code>, <code>Directory</code>, <code>Symlink</code>). When <code>listing.list_directories_only</code> is active, symlinks pointing to directories will have <code>NodeType::Directory</code>.</li>
<li><code>depth</code>: The entry's depth in the tree.</li>
<li><code>size</code>: <code>Option&lt;u64&gt;</code> for file or directory size (if <code>metadata.report_sizes</code> is enabled).</li>
<li><code>mtime</code>: <code>Option&lt;SystemTime&gt;</code> for last modification time.</li>
<li><code>change_time</code>: <code>Option&lt;SystemTime&gt;</code> for last status change time (ctime).</li>
<li><code>create_time</code>: <code>Option&lt;SystemTime&gt;</code> for creation time (btime/crtime).</li>
<li><code>line_count</code>, <code>word_count</code>: <code>Option&lt;usize&gt;</code> for analysis results (applicable to files only).</li>
<li><code>custom_function_output</code>: <code>Option&lt;Result&lt;String, ApplyFnError&gt;&gt;</code> for results of <code>metadata.apply_function</code>.</li>
</ul>
<p>You typically receive a <code>Vec&lt;NodeInfo&gt;</code> from <code>get_tree_nodes()</code>.</p>
<h3 id="get_tree_nodes"><a class="header" href="#get_tree_nodes"><code>get_tree_nodes()</code></a></h3>
<p>This is the primary function for generating the tree data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustree::{get_tree_nodes, RustreeLibConfig, NodeInfo, RustreeError};
use std::path::Path;

fn list_directory_contents(path_str: &amp;str, config: &amp;RustreeLibConfig) -&gt; Result&lt;Vec&lt;NodeInfo&gt;, RustreeError&gt; {
    let root_path = Path::new(path_str);
    get_tree_nodes(root_path, config)
}
<span class="boring">}</span></code></pre></pre>
<p>It takes the root path and a <code>RustreeLibConfig</code> and returns a <code>Result&lt;Vec&lt;NodeInfo&gt;, RustreeError&gt;</code>.
The processing order is:</p>
<ol>
<li>Walk the directory structure, applying initial filters (<code>match_patterns</code>, <code>ignore_patterns</code>, gitignore rules, etc.) and collecting metadata.</li>
<li>If <code>config.filtering.prune_empty_directories</code> is <code>true</code>, empty directories are pruned from the collected nodes.</li>
<li>If <code>config.listing.list_directories_only</code> is <code>true</code>, the node list is filtered to retain only directories. This happens <em>after</em> pruning, so pruning decisions are based on the full content before this filter.</li>
<li>If sorting is specified (<code>config.sorting.sort_by</code>), the remaining nodes are sorted.
The final <code>Vec&lt;NodeInfo&gt;</code> reflects these processing steps.</li>
</ol>
<h3 id="format_nodes"><a class="header" href="#format_nodes"><code>format_nodes()</code></a></h3>
<p>Once you have the <code>Vec&lt;NodeInfo&gt;</code>, you can format it into a string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustree::{format_nodes, NodeInfo, LibOutputFormat, RustreeLibConfig, RustreeError};

fn display_tree(nodes: &amp;[NodeInfo], format: LibOutputFormat, config: &amp;RustreeLibConfig) -&gt; Result&lt;String, RustreeError&gt; {
    format_nodes(nodes, format, config)
}
<span class="boring">}</span></code></pre></pre>
<p>This function takes the nodes, a <code>LibOutputFormat</code> enum (<code>Text</code>, <code>Markdown</code>, <code>Json</code>, or <code>Html</code>), and the <code>RustreeLibConfig</code> (as some config options affect formatting).</p>
<h3 id="key-enums"><a class="header" href="#key-enums">Key Enums</a></h3>
<ul>
<li><strong><code>SortKey</code></strong>: <code>Name</code>, <code>Version</code>, <code>Size</code>, <code>MTime</code>, <code>ChangeTime</code>, <code>CreateTime</code>, <code>Words</code>, <code>Lines</code>, <code>Custom</code>, <code>None</code>. Used in <code>RustreeLibConfig.sorting.sort_by</code>.</li>
<li><strong><code>DirectoryFileOrder</code></strong>: <code>Default</code>, <code>DirsFirst</code>, <code>FilesFirst</code>. Controls directory vs file ordering.</li>
<li><strong><code>LibOutputFormat</code></strong>: <code>Text</code>, <code>Markdown</code>, <code>Json</code>, <code>Html</code>. Used with <code>format_nodes()</code>.</li>
<li><strong><code>BuiltInFunction</code></strong>:
<ul>
<li>File functions: <code>CountPluses</code> (counts '+' characters), <code>Cat</code> (returns full file content)</li>
<li>Directory functions: <code>CountFiles</code>, <code>CountDirs</code>, <code>SizeTotal</code>, <code>DirStats</code></li>
<li>Used in <code>RustreeLibConfig.metadata.apply_function</code>. When using <code>Cat</code>, the <code>format_nodes()</code> function automatically displays file contents after the tree structure.</li>
</ul>
</li>
<li><strong><code>ApplyFnError</code></strong>: Error type for <code>BuiltInFunction</code> application.</li>
<li><strong><code>FunctionOutputKind</code></strong>: <code>Text</code>, <code>Number</code>, <code>Bytes</code>. Describes the type of output from apply functions.</li>
<li><strong><code>ExternalFunction</code></strong>: Configuration for external command-based functions.</li>
<li><strong><code>NodeType</code></strong>: <code>File</code>, <code>Directory</code>, <code>Symlink</code>. Found in <code>NodeInfo</code>.</li>
<li><strong><code>RustreeError</code></strong>: The error type returned by library functions. Includes variants like <code>Io</code>, <code>GlobPattern</code>, <code>IgnoreError</code>, and <code>TreeBuildError</code>.</li>
</ul>
<p>All these types are available through the <code>rustree</code> crate's public API, even though they are now defined in <code>src/core/options/</code>.</p>
<p>Refer to the API documentation (generated by <code>cargo doc</code>) for the full details of these types and their variants/fields.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apply-functions-1"><a class="header" href="#apply-functions-1">Apply Functions</a></h1>
<p>Apply functions are a powerful feature in rustree that allow you to execute custom operations on files during directory traversal. This guide provides comprehensive documentation on how to use each apply function type and their associated filtering patterns.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Apply functions work by processing file contents or executing external commands on selected files. The results are then displayed in a dedicated "File Contents" section of the output. You can control which files are processed using include and exclude patterns.</p>
<h3 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustree::{RustreeLibConfig, MetadataOptions, FilteringOptions, ApplyFunction, BuiltInFunction};

let config = RustreeLibConfig {
    metadata: MetadataOptions {
        apply_function: Some(ApplyFunction::BuiltIn(BuiltInFunction::Cat)),
        ..Default::default()
    },
    filtering: FilteringOptions {
        apply_include_patterns: Some(vec!["*.rs".to_string()]),
        ..Default::default()
    },
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="built-in-functions-2"><a class="header" href="#built-in-functions-2">Built-in Functions</a></h2>
<h3 id="cat-function-1"><a class="header" href="#cat-function-1">Cat Function</a></h3>
<p>The <code>Cat</code> function displays the complete contents of text files, similar to the Unix <code>cat</code> command.</p>
<h4 id="usage-example"><a class="header" href="#usage-example">Usage Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustree::config::metadata::ApplyFunction;
use rustree::{BuiltInFunction, MetadataOptions};

let metadata_opts = MetadataOptions {
    apply_function: Some(ApplyFunction::BuiltIn(BuiltInFunction::Cat)),
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h4 id="command-line-usage"><a class="header" href="#command-line-usage">Command Line Usage</a></h4>
<pre><code class="language-bash"># Display contents of all Rust files
rustree --apply-function cat --apply-include "*.rs"

# Display contents of files in src directory
rustree --apply-function cat --apply-include "src/**"

# Display contents of specific file
rustree --apply-function cat --apply-include "src/main.rs"
</code></pre>
<h4 id="output-format"><a class="header" href="#output-format">Output Format</a></h4>
<pre><code>├── src/
│   ├── main.rs
│   └── lib.rs

--- File Contents ---

=== src/main.rs ===
fn main() {
    println!("Hello, world!");
}

=== src/lib.rs ===
pub mod utils;
pub use utils::*;
</code></pre>
<h3 id="countpluses-function"><a class="header" href="#countpluses-function">CountPluses Function</a></h3>
<p>The <code>CountPluses</code> function counts the number of '+' characters in text files. This is useful for analyzing diffs or counting specific symbols.</p>
<h4 id="usage-example-1"><a class="header" href="#usage-example-1">Usage Example</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustree::config::metadata::ApplyFunction;
use rustree::{BuiltInFunction, MetadataOptions};

let metadata_opts = MetadataOptions {
    apply_function: Some(ApplyFunction::BuiltIn(BuiltInFunction::CountPluses)),
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h4 id="command-line-usage-1"><a class="header" href="#command-line-usage-1">Command Line Usage</a></h4>
<pre><code class="language-bash"># Count plus signs in all text files
rustree --apply-function count-pluses --apply-include "*.txt"

# Count plus signs in specific files
rustree --apply-function count-pluses --apply-include "diff.patch|*.diff"
</code></pre>
<h4 id="output-format-1"><a class="header" href="#output-format-1">Output Format</a></h4>
<pre><code>=== changes.diff ===
Plus count: 42
</code></pre>
<h2 id="external-functions"><a class="header" href="#external-functions">External Functions</a></h2>
<p>External functions allow you to execute custom shell commands on files and capture their output.</p>
<h3 id="usage-example-2"><a class="header" href="#usage-example-2">Usage Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustree::config::metadata::ApplyFunction;
use rustree::{ExternalFunction, MetadataOptions};

let external_fn = ExternalFunction {
    command: "wc".to_string(),
    args: vec!["-l".to_string()], // Count lines
};

let metadata_opts = MetadataOptions {
    apply_function: Some(ApplyFunction::External(external_fn)),
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="command-line-usage-2"><a class="header" href="#command-line-usage-2">Command Line Usage</a></h3>
<pre><code class="language-bash"># Count lines in all source files using wc -l
rustree --apply-function "wc -l" --apply-include "src/**/*.rs"

# Get file info using the file command
rustree --apply-function "file" --apply-include "**/*"

# Custom analysis with grep
rustree --apply-function "grep -c TODO" --apply-include "**/*.rs"
</code></pre>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<ul>
<li>External functions execute shell commands with the permissions of the current user</li>
<li>Always validate and sanitize external command inputs</li>
<li>Be cautious when processing untrusted files or directories</li>
<li>Consider using built-in functions when possible for better security</li>
</ul>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>Apply functions use sophisticated pattern matching to determine which files to process. This system supports both include and exclude patterns with glob syntax.</p>
<h3 id="include-patterns-apply_include_patterns"><a class="header" href="#include-patterns-apply_include_patterns">Include Patterns (<code>apply_include_patterns</code>)</a></h3>
<p>Include patterns specify which files should have the apply function executed on them. If include patterns are specified, <strong>only</strong> files matching these patterns will be processed.</p>
<h4 id="examples-10"><a class="header" href="#examples-10">Examples</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Single pattern
apply_include_patterns: Some(vec!["*.rs".to_string()])

// Multiple patterns
apply_include_patterns: Some(vec![
    "src/**/*.rs".to_string(),
    "tests/**/*.rs".to_string(),
])

// Pattern with pipe separator (OR logic)
apply_include_patterns: Some(vec!["*.rs|*.toml|*.md".to_string()])
<span class="boring">}</span></code></pre></pre>
<h3 id="exclude-patterns-apply_exclude_patterns"><a class="header" href="#exclude-patterns-apply_exclude_patterns">Exclude Patterns (<code>apply_exclude_patterns</code>)</a></h3>
<p>Exclude patterns specify files that should be skipped, even if they match include patterns. Exclude patterns take precedence over include patterns.</p>
<h4 id="examples-11"><a class="header" href="#examples-11">Examples</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Exclude test files
apply_exclude_patterns: Some(vec!["**/test*.rs".to_string()])

// Exclude multiple file types
apply_exclude_patterns: Some(vec![
    "**/*.tmp".to_string(),
    "**/*.bak".to_string(),
])

// Complex exclusion with pipe separator
apply_exclude_patterns: Some(vec!["*.tmp|*.bak|**/target/**".to_string()])
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-evaluation-order"><a class="header" href="#pattern-evaluation-order">Pattern Evaluation Order</a></h3>
<ol>
<li><strong>Include Check</strong>: If include patterns are specified, the file must match at least one include pattern</li>
<li><strong>Exclude Check</strong>: If the file matches any exclude pattern, it is skipped</li>
<li><strong>Apply Function</strong>: If both checks pass, the apply function is executed on the file</li>
</ol>
<h3 id="pattern-types"><a class="header" href="#pattern-types">Pattern Types</a></h3>
<h4 id="exact-match"><a class="header" href="#exact-match">Exact Match</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Matches exactly "src/main.rs"
"src/main.rs"
<span class="boring">}</span></code></pre></pre>
<h4 id="wildcard-patterns"><a class="header" href="#wildcard-patterns">Wildcard Patterns</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Matches all .rs files in src directory
"src/*.rs"

// Matches all files with any extension in src
"src/*.*"
<span class="boring">}</span></code></pre></pre>
<h4 id="recursive-patterns"><a class="header" href="#recursive-patterns">Recursive Patterns</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Matches all .rs files anywhere under src (recursive)
"src/**/*.rs"

// Matches all files anywhere in the tree
"**/*"
<span class="boring">}</span></code></pre></pre>
<h4 id="directory-patterns"><a class="header" href="#directory-patterns">Directory Patterns</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Matches files directly in cli directory
"src/cli/*"

// Matches all files recursively under cli
"src/cli/**"
<span class="boring">}</span></code></pre></pre>
<h4 id="basename-patterns"><a class="header" href="#basename-patterns">Basename Patterns</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Matches any file named "Cargo.toml" anywhere
"Cargo.toml"

// Matches any .md file anywhere
"*.md"
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-pattern-examples"><a class="header" href="#advanced-pattern-examples">Advanced Pattern Examples</a></h3>
<h4 id="complex-project-structure"><a class="header" href="#complex-project-structure">Complex Project Structure</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = RustreeLibConfig {
    metadata: MetadataOptions {
        apply_function: Some(ApplyFunction::BuiltIn(BuiltInFunction::Cat)),
        ..Default::default()
    },
    filtering: FilteringOptions {
        // Include all source files
        apply_include_patterns: Some(vec![
            "src/**/*.rs".to_string(),
            "tests/**/*.rs".to_string(),
            "examples/**/*.rs".to_string(),
        ]),
        // Exclude generated and temporary files
        apply_exclude_patterns: Some(vec![
            "**/target/**".to_string(),
            "**/*.tmp".to_string(),
            "**/.*".to_string(), // Hidden files
        ]),
        ..Default::default()
    },
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h4 id="conditional-processing"><a class="header" href="#conditional-processing">Conditional Processing</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Process only CLI-related files
FilteringOptions {
    apply_include_patterns: Some(vec!["src/cli/**/*.rs".to_string()]),
    ..Default::default()
}

// Process all files except tests and documentation
FilteringOptions {
    apply_include_patterns: Some(vec!["src/**/*.rs".to_string()]),
    apply_exclude_patterns: Some(vec![
        "**/test*.rs".to_string(),
        "**/*_test.rs".to_string(),
        "**/tests/**".to_string(),
    ]),
    ..Default::default()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="case-sensitivity-1"><a class="header" href="#case-sensitivity-1">Case Sensitivity</a></h3>
<p>Pattern matching respects the <code>case_insensitive_filter</code> option:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FilteringOptions {
    apply_include_patterns: Some(vec!["SRC/**/*.RS".to_string()]),
    case_insensitive_filter: true, // Will match "src/**/*.rs"
    ..Default::default()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-directory-considerations"><a class="header" href="#working-directory-considerations">Working Directory Considerations</a></h3>
<p>Pattern matching is always relative to the walk root directory, not the current working directory. This ensures consistent behavior regardless of where the command is executed from.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// When scanning /home/user/project, these patterns are equivalent:
// Pattern: "src/*.rs"
// Matches: /home/user/project/src/main.rs, /home/user/project/src/lib.rs

// Absolute patterns are also supported:
// Pattern: "/home/user/project/src/*.rs"
// Matches: /home/user/project/src/main.rs, /home/user/project/src/lib.rs
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>Apply functions handle various error conditions gracefully:</p>
<h3 id="file-access-errors"><a class="header" href="#file-access-errors">File Access Errors</a></h3>
<ul>
<li><strong>Unreadable files</strong>: Skipped with a note in the output</li>
<li><strong>Permission denied</strong>: Logged as an error, processing continues</li>
<li><strong>Binary files</strong>: Built-in functions skip binary files automatically</li>
</ul>
<h3 id="external-command-errors"><a class="header" href="#external-command-errors">External Command Errors</a></h3>
<ul>
<li><strong>Command not found</strong>: Error message displayed in output</li>
<li><strong>Command failure</strong>: Exit code and stderr captured and displayed</li>
<li><strong>Timeout</strong>: Commands that run too long are terminated</li>
</ul>
<h3 id="pattern-errors"><a class="header" href="#pattern-errors">Pattern Errors</a></h3>
<ul>
<li><strong>Invalid glob patterns</strong>: Configuration error returned immediately</li>
<li><strong>Empty pattern lists</strong>: Treated as "match nothing" for includes, "exclude nothing" for excludes</li>
</ul>
<h2 id="performance-considerations-3"><a class="header" href="#performance-considerations-3">Performance Considerations</a></h2>
<h3 id="pattern-optimization"><a class="header" href="#pattern-optimization">Pattern Optimization</a></h3>
<ul>
<li>Use specific patterns rather than overly broad ones</li>
<li>Prefer directory-specific patterns over global recursive patterns when possible</li>
<li>Consider using exclude patterns to filter out large directories early</li>
</ul>
<h3 id="built-in-vs-external-functions"><a class="header" href="#built-in-vs-external-functions">Built-in vs External Functions</a></h3>
<ul>
<li><strong>Built-in functions</strong> are faster and more secure</li>
<li><strong>External functions</strong> provide more flexibility but have higher overhead</li>
<li>For simple operations, prefer built-in functions</li>
</ul>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<ul>
<li>Large files are processed one at a time to minimize memory usage</li>
<li>External command output is captured and buffered</li>
<li>Binary files are automatically skipped to prevent memory issues</li>
</ul>
<h2 id="complete-examples"><a class="header" href="#complete-examples">Complete Examples</a></h2>
<h3 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Show all source code for code review
let review_config = RustreeLibConfig {
    metadata: MetadataOptions {
        apply_function: Some(ApplyFunction::BuiltIn(BuiltInFunction::Cat)),
        ..Default::default()
    },
    filtering: FilteringOptions {
        apply_include_patterns: Some(vec![
            "src/**/*.rs".to_string(),
            "*.toml".to_string(),
            "*.md".to_string(),
        ]),
        apply_exclude_patterns: Some(vec![
            "**/target/**".to_string(),
            "**/*.lock".to_string(),
        ]),
        ..Default::default()
    },
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="documentation-generation-1"><a class="header" href="#documentation-generation-1">Documentation Generation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Extract all TODO comments
let todo_config = RustreeLibConfig {
    metadata: MetadataOptions {
        apply_function: Some(ApplyFunction::External(ExternalFunction {
            command: "grep".to_string(),
            args: vec!["-n".to_string(), "TODO".to_string()],
        })),
        ..Default::default()
    },
    filtering: FilteringOptions {
        apply_include_patterns: Some(vec!["**/*.rs".to_string()]),
        apply_exclude_patterns: Some(vec!["**/target/**".to_string()]),
        ..Default::default()
    },
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="quality-analysis"><a class="header" href="#quality-analysis">Quality Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Count lines of code
let loc_config = RustreeLibConfig {
    metadata: MetadataOptions {
        apply_function: Some(ApplyFunction::External(ExternalFunction {
            command: "wc".to_string(),
            args: vec!["-l".to_string()],
        })),
        ..Default::default()
    },
    filtering: FilteringOptions {
        apply_include_patterns: Some(vec![
            "src/**/*.rs".to_string(),
            "tests/**/*.rs".to_string(),
        ]),
        ..Default::default()
    },
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h2>
<h3 id="core-types"><a class="header" href="#core-types">Core Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Apply function types
pub enum ApplyFunction {
    BuiltIn(BuiltInFunction),
    External(ExternalFunction),
}

// Built-in function types
pub enum BuiltInFunction {
    Cat,
    CountPluses,
}

// External function configuration
pub struct ExternalFunction {
    pub command: String,
    pub args: Vec&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="configuration-options-1"><a class="header" href="#configuration-options-1">Configuration Options</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Metadata options for apply functions
pub struct MetadataOptions {
    pub apply_function: Option&lt;ApplyFunction&gt;,
    // ... other metadata options
}

// Filtering options for pattern matching
pub struct FilteringOptions {
    pub apply_include_patterns: Option&lt;Vec&lt;String&gt;&gt;,
    pub apply_exclude_patterns: Option&lt;Vec&lt;String&gt;&gt;,
    pub case_insensitive_filter: bool,
    // ... other filtering options
}
<span class="boring">}</span></code></pre></pre>
<p>This comprehensive guide covers all aspects of using apply functions in rustree. For more advanced usage and integration examples, see the <a href="library_usage/examples.html">Examples</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="library-usage-examples"><a class="header" href="#library-usage-examples">Library Usage Examples</a></h2>
<p>Here are some examples of how to use <code>rustree</code> as a library in your Rust code.
Make sure to add <code>rustree</code> to your <code>Cargo.toml</code> dependencies.
All key types like <code>RustreeLibConfig</code>, <code>NodeInfo</code>, <code>SortKey</code>, <code>LibOutputFormat</code>, <code>RustreeError</code> are re-exported by <code>rustree</code>'s <code>lib.rs</code>.</p>
<h3 id="example-1-basic-tree-listing"><a class="header" href="#example-1-basic-tree-listing">Example 1: Basic Tree Listing</a></h3>
<p>This example shows how to get a simple text tree of a directory.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, RustreeError,
    InputSourceOptions, ListingOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "."; // Current directory
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: path_obj.file_name().unwrap_or_default().to_string_lossy().into_owned(),
            root_is_directory: path_obj.is_dir(), // Set based on actual path
            ..Default::default()
        },
        listing: ListingOptions {
            max_depth: Some(2), // Limit depth to 2 levels
            ..Default::default()
        },
        ..Default::default()
    };

    // 1. Get the tree nodes
    let nodes = get_tree_nodes(path_obj, &amp;config)?;

    // 2. Format the nodes into a string
    let output_string = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;

    // 3. Print the output
    println!("{}", output_string);

    Ok(())
}</code></pre></pre>
<h3 id="example-1b-tree-listing-with-full-paths"><a class="header" href="#example-1b-tree-listing-with-full-paths">Example 1b: Tree Listing with Full Paths</a></h3>
<p>This example demonstrates using the <code>show_full_path</code> option to display complete relative paths.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, RustreeError,
    InputSourceOptions, ListingOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./src";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "src".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        listing: ListingOptions {
            max_depth: Some(3),
            show_full_path: true, // Enable full path display
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    let output_string = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    
    println!("{}", output_string);
    
    // Output will show:
    // src/
    // ├── src/main.rs
    // ├── src/lib.rs
    // └── src/utils/
    //     └── src/utils/helper.rs
    // 
    // Instead of just:
    // src/
    // ├── main.rs
    // ├── lib.rs
    // └── utils/
    //     └── helper.rs

    Ok(())
}</code></pre></pre>
<h3 id="example-2-reporting-sizes-and-sorting"><a class="header" href="#example-2-reporting-sizes-and-sorting">Example 2: Reporting Sizes and Sorting</a></h3>
<p>This example demonstrates reporting file sizes and sorting by size in descending order.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, SortKey, RustreeError,
    InputSourceOptions, MetadataOptions, SortingOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./src";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Source Files".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        metadata: MetadataOptions {
            show_size_bytes: true,
            show_last_modified: true, // To see mtime in output if sorting by size
            ..Default::default()
        },
        sorting: SortingOptions {
            sort_by: Some(SortKey::Size),
            reverse_sort: true, // Largest files first
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    let output_string = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    println!("{}", output_string);

    Ok(())
}
</code></pre></pre>
<h3 id="example-3-using-markdown-output-and-line-counts"><a class="header" href="#example-3-using-markdown-output-and-line-counts">Example 3: Using Markdown Output and Line Counts</a></h3>
<p>This example shows how to calculate line counts and output in Markdown format.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, SortKey, RustreeError,
    InputSourceOptions, MetadataOptions, SortingOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./src";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Project Source (Markdown)".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        metadata: MetadataOptions {
            calculate_line_count: true,
            ..Default::default()
        },
        sorting: SortingOptions {
            sort_by: Some(SortKey::Lines), // Sort by line count
            reverse_sort: true,            // Most lines first
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    
    // Output as Markdown
    let markdown_output = format_nodes(&amp;nodes, LibOutputFormat::Markdown, &amp;config)?;
    println!("\n--- Markdown Output ---");
    println!("{}", markdown_output);
    // You could write this string to a .md file

    Ok(())
}</code></pre></pre>
<h3 id="example-4-using-the-cat-function-to-display-file-contents"><a class="header" href="#example-4-using-the-cat-function-to-display-file-contents">Example 4: Using the Cat Function to Display File Contents</a></h3>
<p>This example demonstrates using the <code>Cat</code> built-in function to display file contents after the tree structure.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, BuiltInFunction, RustreeError,
    InputSourceOptions, MetadataOptions, FilteringOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./config"; // Directory with configuration files
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Configuration Files".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        metadata: MetadataOptions {
            apply_function: Some(BuiltInFunction::Cat), // Display file contents
            show_size_bytes: true, // Also show file sizes
            ..Default::default()
        },
        filtering: FilteringOptions {
            // Only show text-based config files
            match_patterns: Some(vec!["*.toml".to_string(), "*.json".to_string(), "*.yaml".to_string()]),
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    
    // format_nodes will automatically display the tree first, then file contents
    let output = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    println!("{}", output);
    
    // The output will show:
    // 1. Directory tree structure with file sizes
    // 2. "--- File Contents ---" section
    // 3. Each file's content with clear headers

    Ok(())
}</code></pre></pre>
<h3 id="example-5-combining-apply-functions-with-custom-sorting"><a class="header" href="#example-5-combining-apply-functions-with-custom-sorting">Example 5: Combining Apply Functions with Custom Sorting</a></h3>
<p>This example shows how to use built-in functions and sort by their results.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, BuiltInFunction, SortKey, RustreeError,
    InputSourceOptions, MetadataOptions, SortingOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./text_files";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Text Analysis".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        metadata: MetadataOptions {
            apply_function: Some(BuiltInFunction::CountPluses), // Count '+' characters
            calculate_line_count: true,
            calculate_word_count: true,
            ..Default::default()
        },
        sorting: SortingOptions {
            sort_by: Some(SortKey::Custom), // Sort by the apply_function result
            reverse_sort: true, // Files with most '+' characters first
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    let output = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    println!("{}", output);

    Ok(())
}</code></pre></pre>
<h3 id="example-6-directory-analysis-with-built-in-functions"><a class="header" href="#example-6-directory-analysis-with-built-in-functions">Example 6: Directory Analysis with Built-in Functions</a></h3>
<p>This example demonstrates using directory functions to analyze project structure.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, BuiltInFunction, SortKey, RustreeError,
    InputSourceOptions, MetadataOptions, SortingOptions, ListingOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./my_project";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Project Analysis".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        listing: ListingOptions {
            list_directories_only: true, // Only show directories
            ..Default::default()
        },
        metadata: MetadataOptions {
            apply_function: Some(BuiltInFunction::DirStats), // Get comprehensive directory stats
            show_size_bytes: true, // Required for size calculations
            ..Default::default()
        },
        sorting: SortingOptions {
            sort_by: Some(SortKey::Custom), // Sort by directory stats (complexity)
            reverse_sort: true, // Most complex directories first
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    let output = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    println!("{}", output);
    
    // Output will show directories with stats like [F: "15f,3d,52KB"]
    // meaning 15 files, 3 subdirectories, 52KB total size

    Ok(())
}</code></pre></pre>
<h3 id="example-7-selective-function-application-with-filtering"><a class="header" href="#example-7-selective-function-application-with-filtering">Example 7: Selective Function Application with Filtering</a></h3>
<p>This example shows how to apply functions only to specific files or directories using patterns.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, BuiltInFunction, RustreeError,
    InputSourceOptions, MetadataOptions, FilteringOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./workspace";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Workspace Analysis".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        metadata: MetadataOptions {
            apply_function: Some(BuiltInFunction::CountFiles), // Count files in directories
            show_size_bytes: true,
            ..Default::default()
        },
        filtering: FilteringOptions {
            // Apply function only to source directories, exclude build artifacts
            apply_include_patterns: Some(vec!["src*".to_string(), "lib*".to_string()]),
            apply_exclude_patterns: Some(vec!["*target*".to_string(), "*build*".to_string()]),
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    let output = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    println!("{}", output);

    Ok(())
}</code></pre></pre>
<h3 id="example-8-file-content-analysis-with-filtering"><a class="header" href="#example-8-file-content-analysis-with-filtering">Example 8: File Content Analysis with Filtering</a></h3>
<p>This example demonstrates using the cat function with selective application for code review.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, format_nodes, RustreeLibConfig, LibOutputFormat, BuiltInFunction, RustreeError,
    InputSourceOptions, MetadataOptions, FilteringOptions,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./src";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        input_source: InputSourceOptions {
            root_display_name: "Code Review".to_string(),
            root_is_directory: path_obj.is_dir(),
            ..Default::default()
        },
        metadata: MetadataOptions {
            apply_function: Some(BuiltInFunction::Cat), // Show file contents
            calculate_line_count: true,
            ..Default::default()
        },
        filtering: FilteringOptions {
            // Only show Rust files and exclude test files
            match_patterns: Some(vec!["*.rs".to_string()]),
            apply_exclude_patterns: Some(vec!["*test*".to_string(), "*tests*".to_string()]),
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;
    let output = format_nodes(&amp;nodes, LibOutputFormat::Text, &amp;config)?;
    println!("{}", output);
    
    // This will show:
    // 1. Tree structure of all .rs files
    // 2. File contents for non-test .rs files only

    Ok(())
}</code></pre></pre>
<h3 id="example-9-working-with-nodeinfo-directly"><a class="header" href="#example-9-working-with-nodeinfo-directly">Example 9: Working with NodeInfo Directly</a></h3>
<p>This example shows how to work with the raw <code>NodeInfo</code> data for custom processing.</p>
<pre><pre class="playground"><code class="language-rust">use rustree::{
    get_tree_nodes, RustreeLibConfig, BuiltInFunction, RustreeError,
    InputSourceOptions, MetadataOptions, NodeType,
};
use std::path::Path;

fn main() -&gt; Result&lt;(), RustreeError&gt; {
    let target_path = "./project";
    let path_obj = Path::new(target_path);

    let config = RustreeLibConfig {
        metadata: MetadataOptions {
            apply_function: Some(BuiltInFunction::CountFiles),
            show_size_bytes: true,
            calculate_line_count: true,
            ..Default::default()
        },
        ..Default::default()
    };

    let nodes = get_tree_nodes(path_obj, &amp;config)?;

    // Custom analysis of the nodes
    for node in &amp;nodes {
        match node.node_type {
            NodeType::Directory =&gt; {
                if let Some(Ok(file_count)) = &amp;node.custom_function_output {
                    println!("Directory '{}' contains {} files", node.name, file_count);
                }
            }
            NodeType::File =&gt; {
                if let Some(lines) = node.line_count {
                    println!("File '{}' has {} lines", node.name, lines);
                }
                if let Some(size) = node.size {
                    println!("File '{}' is {} bytes", node.name, size);
                }
            }
            _ =&gt; {}
        }
    }

    Ok(())
}</code></pre></pre>
<p>These examples should give you a good starting point for integrating <code>rustree</code> into your applications. Remember to handle the <code>Result</code> types appropriately in production code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This section provides an overview of RusTree's internal architecture.</p>
<p>Understanding the architecture can be helpful if you plan to contribute to RusTree or want a deeper understanding of how it works.</p>
<h2 id="sub-sections-1"><a class="header" href="#sub-sections-1">Sub-sections:</a></h2>
<ul>
<li><a href="./architecture/overview.html">Overview</a>: A high-level look at the components and data flow.</li>
<li><a href="./architecture/modules.html">Core Modules</a>: Details about the main modules within the <code>rustree</code> library.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="architectural-overview"><a class="header" href="#architectural-overview">Architectural Overview</a></h2>
<p>RusTree is designed with a modular approach, separating concerns into different components. The primary data flow for the library is as follows:</p>
<ol>
<li>
<p><strong>Configuration (<code>RustreeLibConfig</code> from <code>src/config/tree_options.rs</code>)</strong>: The process starts with a configuration object that dictates how the tree traversal, analysis, and formatting should occur. <code>RustreeLibConfig</code> is composed of sub-structs like <code>ListingOptions</code>, <code>FilteringOptions</code> (including <code>prune_empty_directories</code>), <code>MetadataOptions</code> (controlling reporting of mtime, ctime, crtime, etc.), and <code>SortingOptions</code> (specifying sort keys like <code>Name</code>, <code>Version</code>, <code>MTime</code>, <code>ChangeTime</code>, <code>CreateTime</code>, <code>None</code>, and behaviors like <code>files_before_directories</code>).</p>
</li>
<li>
<p><strong>Walking (<code>core::walker</code>)</strong>:</p>
<ul>
<li>The <code>walk_directory</code> function (in <code>core::walker::filesystem</code>) uses the <code>ignore</code> crate to traverse the file system.</li>
<li>It respects configuration settings from <code>RustreeLibConfig</code>:
<ul>
<li><code>config.listing.max_depth</code>, <code>config.listing.show_hidden</code>.</li>
<li><code>config.filtering.use_gitignore_rules</code> and <code>config.filtering.gitignore_file</code> for gitignore rules (handled by the <code>ignore</code> crate).</li>
<li><code>config.filtering.ignore_patterns</code> (CLI <code>-I</code>) are compiled by <code>core::filter::pattern</code> and used by the <code>ignore</code> crate's <code>WalkBuilder::filter_entry()</code> to prune the walk.</li>
<li><code>config.filtering.case_insensitive_filter</code> controls case sensitivity for all pattern matching.</li>
</ul>
</li>
<li>After the <code>ignore</code> crate yields an entry, further filtering is applied by the walker using <code>core::filter::pattern::entry_matches_glob_patterns</code>:
<ul>
<li><code>config.filtering.match_patterns</code> (CLI <code>-P</code>): Files and symlinks must match these patterns. Directories are generally kept if they might contain matching children.</li>
</ul>
</li>
<li>For each qualifying entry, it gathers initial metadata (mtime, ctime, crtime based on <code>config.metadata</code> and platform capabilities). Symlinks are resolved. The <code>list_directories_only</code> filter is NOT applied at this stage.</li>
</ul>
</li>
<li>
<p><strong>Metadata Collection &amp; Analysis (<code>core::metadata</code>)</strong>:</p>
<ul>
<li>As the walker processes entries, it invokes functions from <code>core::metadata</code> based on <code>config.metadata</code>.</li>
<li><code>core::metadata::size_calculator</code>: Calculates line counts and word counts for files.</li>
<li><code>core::metadata::file_info</code>: Applies built-in functions (from <code>config::metadata::BuiltInFunction</code>) to file content using <code>apply_builtin_to_file</code>.</li>
<li>The results are stored in <code>NodeInfo</code> objects (defined in <code>core::tree::node</code>). This step is skipped for directories for file-specific analyses.</li>
</ul>
</li>
<li>
<p><strong>Node Representation (<code>NodeInfo</code> from <code>core::tree::node</code>)</strong>:</p>
<ul>
<li>Each qualifying file system entry is represented by a <code>NodeInfo</code> struct. This struct holds its path, name, effective <code>node_type</code>, depth, metadata (size, mtime, change_time, create_time), and any analysis results.</li>
<li>The walker produces a <code>Vec&lt;NodeInfo&gt;</code>.</li>
</ul>
</li>
<li>
<p><strong>Pruning (<code>lib.rs</code>, using <code>core::tree::manipulator</code>)</strong>:</p>
<ul>
<li>If <code>config.filtering.prune_empty_directories</code> is <code>true</code>, the <code>Vec&lt;NodeInfo&gt;</code> is processed to remove empty directories.</li>
<li>This involves building a temporary tree, pruning nodes where a directory contains no files and no non-empty subdirectories, and then flattening the tree back.</li>
<li>This step occurs <em>after</em> all initial walking and filtering, but <em>before</em> the <code>list_directories_only</code> filter and sorting.</li>
</ul>
</li>
<li>
<p><strong><code>list_directories_only</code> Filtering (<code>lib.rs</code>)</strong>:</p>
<ul>
<li>If <code>config.listing.list_directories_only</code> is <code>true</code>, the <code>Vec&lt;NodeInfo&gt;</code> (potentially already pruned) is further filtered to retain only entries with <code>NodeType::Directory</code>.</li>
<li>This ensures that pruning decisions are made based on the full content of directories before they are potentially removed by this filter.</li>
</ul>
</li>
<li>
<p><strong>Sorting (<code>core::sorter</code>)</strong>:</p>
<ul>
<li>If <code>config.sorting.sort_by</code> specifies a <code>SortKey</code>, the <code>sort_nodes_with_options</code> function (in <code>core::sorter::strategies</code>) sorts the (potentially pruned and filtered) <code>Vec&lt;NodeInfo&gt;</code>.</li>
<li>Sorting involves building a temporary tree, sorting sibling nodes at each level using comparison logic from <code>core::sorter::comparators</code> (which respects <code>config.sorting.reverse_sort</code> and <code>config.sorting.files_before_directories</code>), and then flattening the tree back.</li>
<li>Default size sorting is now largest first, with files/symlinks grouped before directories. Version sorting is more intelligent. If <code>SortKey::None</code> is used, directory traversal order is preserved.</li>
</ul>
</li>
<li>
<p><strong>Formatting (<code>core::formatter</code>)</strong>:</p>
<ul>
<li>The processed (sorted or unsorted) <code>Vec&lt;NodeInfo&gt;</code> is passed to a formatter.</li>
<li>The <code>TreeFormatter</code> trait defines the interface. Formatters use <code>core::metadata::file_info::format_node_metadata</code> for consistent metadata display.</li>
<li><code>TextTreeFormatter</code>: Generates plain text, <code>tree</code>-like output.</li>
<li><code>MarkdownFormatter</code>: Generates a Markdown list.</li>
<li>The formatter produces the final string output, considering configuration like <code>config.input_source.root_display_name</code>. The choice of formatter is determined by <code>LibOutputFormat</code> (from <code>config::output_format</code>).</li>
</ul>
</li>
</ol>
<h3 id="cli-layer"><a class="header" href="#cli-layer">CLI Layer</a></h3>
<p>The command-line interface (<code>src/cli/</code>) acts as a wrapper around the core library:</p>
<ul>
<li><strong>Argument Parsing (<code>cli::args</code>)</strong>: Uses <code>clap</code> to parse arguments.</li>
<li><strong>Mapping (<code>cli::mapping</code>)</strong>: The <code>map_cli_to_lib_config</code> function translates <code>CliArgs</code> into <code>RustreeLibConfig</code> (e.g., setting <code>sorting.sort_by</code>, <code>sorting.files_before_directories</code>, <code>metadata.show_last_modified</code>).</li>
<li><strong>Orchestration (<code>main.rs</code>)</strong>:
<ol>
<li>Parses CLI args.</li>
<li>Maps CLI args to library config.</li>
<li>Calls <code>rustree::get_tree_nodes()</code>.</li>
<li>Calls <code>rustree::format_nodes()</code>.</li>
<li>Prints the output.</li>
</ol>
</li>
</ul>
<p>This separation allows the core library to be used independently.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="core-library-modules"><a class="header" href="#core-library-modules">Core Library Modules</a></h2>
<p>The <code>rustree</code> library is organized into several modules, each with a specific responsibility. The <code>src/core/</code> directory, in particular, has been significantly refactored into sub-modules for better organization and clarity.</p>
<h3 id="srcconfig---configuration-bridge-module"><a class="header" href="#srcconfig---configuration-bridge-module"><code>src/config/</code> - Configuration Bridge Module</a></h3>
<p>This module now serves as a bridge layer that re-exports configuration types from the core layer and provides helper functions for CLI integration. After the refactoring (commit 333f1c7), all configuration structs have been moved to <code>src/core/options/</code> for better modularity.</p>
<ul>
<li>
<p><strong>All configuration files now simply re-export from core</strong>:</p>
<ul>
<li><code>filtering.rs</code>: Re-exports <code>FilteringOptions</code> from <code>core::options::filtering</code></li>
<li><code>html.rs</code>: Re-exports <code>HtmlOptions</code> from <code>core::options::html</code></li>
<li><code>input_source.rs</code>: Re-exports <code>InputSourceOptions</code> from <code>core::options::input_source</code></li>
<li><code>listing.rs</code>: Re-exports <code>ListingOptions</code> from <code>core::options::listing</code></li>
<li><code>metadata.rs</code>: Re-exports all metadata types from <code>core::options::metadata</code></li>
<li><code>misc.rs</code>: Re-exports <code>MiscOptions</code> from <code>core::options::misc</code></li>
<li><code>output_format.rs</code>: Re-exports <code>OutputFormat</code> from <code>core::options::output_format</code></li>
<li><code>sorting.rs</code>: Re-exports all sorting types from <code>core::options::sorting</code></li>
<li><code>tree_options.rs</code>: Re-exports <code>RustreeLibConfig</code> from <code>core::options::tree_options</code></li>
</ul>
</li>
<li>
<p><strong><code>llm.rs</code></strong> (special case):</p>
<ul>
<li>Still contains CLI-specific helper functions (<code>from_cli_args</code>, <code>to_core_config</code>, <code>generate_sample_env_file</code>)</li>
<li>Re-exports core LLM types: <code>LlmConfigError</code>, <code>LlmOptions</code>, <code>LlmProvider</code></li>
<li>Provides the bridge between CLI arguments and core LLM configuration</li>
</ul>
</li>
</ul>
<h3 id="srccoreoptions---core-configuration-module"><a class="header" href="#srccoreoptions---core-configuration-module"><code>src/core/options/</code> - Core Configuration Module</a></h3>
<p>This new module (added in the refactoring) contains all the actual configuration struct definitions that were previously in <code>src/config/</code>. This change improves modularity by making the core layer self-contained.</p>
<ul>
<li>
<p><strong><code>tree_options.rs</code></strong>:</p>
<ul>
<li>Defines <code>RustreeLibConfig</code>, the main configuration struct</li>
<li>Composed of all the sub-configuration structs listed below</li>
</ul>
</li>
<li>
<p><strong><code>input_source.rs</code></strong>:</p>
<ul>
<li>Defines <code>InputSourceOptions</code> struct for root path display and initial metadata</li>
</ul>
</li>
<li>
<p><strong><code>listing.rs</code></strong>:</p>
<ul>
<li>Defines <code>ListingOptions</code> struct for directory traversal settings</li>
<li>Includes <code>show_full_path</code> option to control whether formatters display full relative paths or just filenames</li>
</ul>
</li>
<li>
<p><strong><code>filtering.rs</code></strong>:</p>
<ul>
<li>Defines <code>FilteringOptions</code> struct for inclusion/exclusion patterns, gitignore settings, and the <code>prune_empty_directories</code> flag</li>
</ul>
</li>
<li>
<p><strong><code>sorting.rs</code></strong>:</p>
<ul>
<li>Defines the <code>SortKey</code> enum (e.g., <code>Name</code>, <code>Size</code>, <code>MTime</code>, <code>Version</code>, <code>ChangeTime</code>, <code>CreateTime</code>, <code>None</code>)</li>
<li>Defines <code>DirectoryFileOrder</code> enum to control directory vs. file ordering (<code>Default</code>, <code>DirsFirst</code>, <code>FilesFirst</code>)</li>
<li>Defines <code>SortingOptions</code> struct for sorting criteria and preferences</li>
</ul>
</li>
<li>
<p><strong><code>metadata.rs</code></strong>:</p>
<ul>
<li>Defines <code>MetadataOptions</code> struct for metadata collection and content analysis flags</li>
<li>Defines <code>BuiltInFunction</code> enum for functions applicable to file content</li>
<li>Defines <code>ApplyFnError</code> for errors during custom function application</li>
<li>Defines <code>FunctionOutputKind</code> and <code>ExternalFunction</code> for external command support</li>
</ul>
</li>
<li>
<p><strong><code>output_format.rs</code></strong>:</p>
<ul>
<li>Defines the <code>OutputFormat</code> enum used to specify output format (Text, Markdown, Json, Html)</li>
</ul>
</li>
<li>
<p><strong><code>misc.rs</code></strong>:</p>
<ul>
<li>Defines <code>MiscOptions</code> struct for miscellaneous configuration options</li>
</ul>
</li>
<li>
<p><strong><code>html.rs</code></strong>:</p>
<ul>
<li>Defines <code>HtmlOptions</code> struct for HTML-specific output configuration</li>
</ul>
</li>
<li>
<p><strong><code>llm.rs</code></strong>:</p>
<ul>
<li>Defines core LLM types: <code>LlmProvider</code>, <code>LlmOptions</code>, <code>LlmConfigError</code></li>
<li>Contains provider-specific logic and validation</li>
</ul>
</li>
</ul>
<h3 id="srccore---core-logic-modules"><a class="header" href="#srccore---core-logic-modules"><code>src/core/</code> - Core Logic Modules</a></h3>
<p>The <code>src/core/</code> directory houses the main operational logic of <code>rustree</code>.</p>
<ul>
<li>
<p><strong><code>tree/</code></strong>: This sub-module manages the tree data structure itself.</p>
<ul>
<li><code>node.rs</code>: Defines <code>NodeInfo</code>, the struct representing a single file system entry (file, directory, symlink) and its collected data (including <code>path</code>, <code>name</code>, <code>node_type</code>, <code>depth</code>, <code>size</code>, <code>mtime</code>, <code>change_time</code>, <code>create_time</code>, analysis results). Defines <code>NodeType</code>, an enum for the type of file system entry.</li>
<li><code>builder.rs</code>: Contains logic for constructing a <code>Vec&lt;TempNode&gt;</code> (a temporary tree structure) from a flat <code>Vec&lt;NodeInfo&gt;</code> and for flattening it back. This is primarily used by the sorter.</li>
<li><code>manipulator.rs</code>: Provides utilities for modifying tree structures, such as pruning, filtering, and transforming nodes.</li>
<li><code>traversal.rs</code>: Implements various tree traversal algorithms (DFS pre-order, post-order, BFS) and a <code>TreeVisitor</code> trait for custom operations during traversal.</li>
</ul>
</li>
<li>
<p><strong><code>walker/</code></strong>: This sub-module is responsible for traversing the file system.</p>
<ul>
<li><code>filesystem.rs</code>: Contains the <code>walk_directory</code> function. It uses the <code>ignore</code> crate (<code>ignore::WalkBuilder</code>) for directory walking. It implements initial filtering logic based on <code>RustreeLibConfig</code> (hidden files, max depth, gitignore rules, ignore patterns). After the <code>ignore</code> crate yields an entry, it applies further filtering (match patterns). The <code>list_directories_only</code> filter is applied later in <code>lib.rs</code> after potential pruning. It handles symlink resolution and populates <code>NodeInfo</code> structs with basic metadata, triggering content analysis via the <code>metadata</code> module.</li>
<li><code>depth_control.rs</code>: (Placeholder for future depth-specific control logic).</li>
<li><code>input_source.rs</code>: (Placeholder for future advanced input source handling).</li>
<li><code>symlinks.rs</code>: (Placeholder for future advanced symlink resolution strategies).</li>
</ul>
</li>
<li>
<p><strong><code>filter/</code></strong>: This sub-module handles all filtering logic beyond what the <code>ignore</code> crate provides directly during its walk.</p>
<ul>
<li><code>pattern.rs</code>: Contains <code>compile_glob_patterns</code> to prepare glob patterns from <code>FilteringOptions</code> and <code>entry_matches_glob_patterns</code> to check if a <code>DirEntry</code> matches these compiled patterns. This is used by the <code>walker</code> after the <code>ignore</code> crate's initial pass.</li>
<li><code>gitignore.rs</code>: (Placeholder for future gitignore-specific filtering utilities, complementing the <code>ignore</code> crate's built-in support).</li>
<li><code>composite.rs</code>: (Placeholder for combining multiple filter criteria).</li>
<li><code>matcher.rs</code>: (Placeholder for generic matching logic).</li>
<li><code>size_filter.rs</code>: (Placeholder for size-based filtering).</li>
</ul>
</li>
<li>
<p><strong><code>metadata/</code></strong>: This sub-module handles metadata collection, calculation, and content analysis.</p>
<ul>
<li><code>file_info.rs</code>:
<ul>
<li>Defines <code>format_node_metadata</code> for consistently formatting metadata strings for display (used by formatters). For the <code>Cat</code> function, metadata display is suppressed since content is shown separately.</li>
<li>Contains <code>apply_builtin_to_file</code> and <code>apply_builtin_function</code> for applying <code>BuiltInFunction</code>s to file content, handling <code>ApplyFnError</code>. The <code>Cat</code> function simply returns the full file content.</li>
</ul>
</li>
<li><code>size_calculator.rs</code>: Provides functions like <code>count_lines_from_string</code> and <code>count_words_from_string</code>.</li>
<li><code>time_formatter.rs</code>: (Placeholder for advanced time formatting utilities).</li>
<li><code>extended_attrs.rs</code>: (Placeholder for reading extended file attributes).</li>
</ul>
</li>
<li>
<p><strong><code>sorter/</code></strong>: This sub-module is responsible for sorting nodes while preserving the tree hierarchy.</p>
<ul>
<li><code>strategies.rs</code>: Contains <code>sort_nodes_with_options</code> (and the older <code>sort_nodes</code>), which orchestrates tree building, sorting of sibling nodes, and tree flattening.</li>
<li><code>comparators.rs</code>: Defines <code>compare_siblings_with_options</code> which implements the comparison logic for various <code>SortKey</code>s, considering <code>SortingOptions</code> like <code>reverse_sort</code>, <code>files_before_directories</code> (legacy), and the new <code>directory_file_order</code> enum. It includes universal directory/file ordering that applies to all sort keys, improved version string comparison, and enhanced size sorting logic. The <code>apply_directory_file_ordering</code> function provides consistent directory vs. file ordering across all sorting modes.</li>
<li><code>composite.rs</code>: (Placeholder for defining and using composite sort keys).</li>
</ul>
</li>
<li>
<p><strong><code>formatter/</code></strong>: This sub-module is responsible for generating the final output string.</p>
<ul>
<li><code>base.rs</code>: Defines the <code>TreeFormatter</code> trait, which all specific formatters implement.</li>
<li><code>text_tree.rs</code>: Implements <code>TextTreeFormatter</code> for the classic <code>tree</code>-like text output. It uses <code>core::metadata::file_info::format_node_metadata</code> for consistent metadata display. Supports full path display when <code>config.listing.show_full_path</code> is enabled.</li>
<li><code>markdown.rs</code>: Implements <code>MarkdownFormatter</code> for generating Markdown lists. It also uses <code>core::metadata::file_info::format_node_metadata</code>. Supports full path display when <code>config.listing.show_full_path</code> is enabled.</li>
<li><code>mod.rs</code> (in <code>formatter</code>): Re-exports <code>OutputFormat</code> (as <code>LibOutputFormat</code>) from <code>src/config/output_format.rs</code>.</li>
</ul>
</li>
<li>
<p><strong><code>util.rs</code></strong>: Contains general utility functions like <code>is_hidden</code>, <code>format_size</code>, <code>truncate_string</code>.</p>
</li>
<li>
<p><strong><code>error.rs</code></strong>:</p>
<ul>
<li>Defines <code>RustreeError</code>, the common error type used throughout the library. This includes variants for I/O errors, glob pattern errors, errors from the <code>ignore</code> crate (<code>IgnoreError</code>), and <code>TreeBuildError</code> (for errors during internal tree construction for sorting or pruning).</li>
</ul>
</li>
</ul>
<h3 id="top-level-library-file-srclibrs"><a class="header" href="#top-level-library-file-srclibrs">Top-Level Library File (<code>src/lib.rs</code>)</a></h3>
<ul>
<li>
<p>Re-exports key public types to form the library's public API:</p>
<ul>
<li>From <code>config</code> module (which now re-exports from <code>core::options</code>):
<ul>
<li><code>RustreeLibConfig</code> and its constituent option structs: <code>InputSourceOptions</code>, <code>ListingOptions</code>, <code>FilteringOptions</code>, <code>SortingOptions</code>, <code>MetadataOptions</code>, <code>MiscOptions</code>, <code>HtmlOptions</code></li>
<li>Enums and related types: <code>SortKey</code>, <code>DirectoryFileOrder</code>, <code>BuiltInFunction</code>, <code>ApplyFnError</code>, <code>FunctionOutputKind</code>, <code>ExternalFunction</code></li>
<li><code>LibOutputFormat</code> (an alias for <code>OutputFormat</code>)</li>
<li>LLM types: <code>LlmProvider</code>, <code>LlmOptions</code>, <code>LlmConfigError</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Core types: <code>NodeInfo</code> (from <code>core::tree::node</code>), <code>NodeType</code>, and <code>RustreeError</code>.</p>
</li>
<li>
<p>The <code>cli</code> module, while part of the crate, is marked <code>#[doc(hidden)]</code> and is not part of the stable public API.</p>
</li>
<li>
<p>Provides the main entry-point functions:</p>
<ul>
<li><code>get_tree_nodes()</code>: Orchestrates the main logic:
<ol>
<li>Walking the file system (via <code>core::walker</code>), applying initial filters and collecting metadata.</li>
<li>If <code>config.filtering.prune_empty_directories</code> is true, prunes empty directories from the results (using <code>core::tree::manipulator</code> and <code>core::tree::builder</code>).</li>
<li>If <code>config.listing.list_directories_only</code> is true, filters the results to include only directories. This occurs <em>after</em> pruning.</li>
<li>If sorting is requested, sorts the nodes (via <code>core::sorter::strategies::sort_nodes_with_options</code>). Errors during sorting or tree building for pruning now map to <code>RustreeError::TreeBuildError</code>.</li>
</ol>
</li>
<li><code>format_nodes()</code>: Takes the processed nodes and applies the chosen formatter. For the <code>Cat</code> function, it first generates the normal tree output, then appends a "--- File Contents ---" section with the content of each file.</li>
</ul>
</li>
</ul>
<p>This modular structure aims to make the codebase maintainable and extensible.</p>
<h2 id="known-architectural-issues"><a class="header" href="#known-architectural-issues">Known Architectural Issues</a></h2>
<h3 id="incomplete-core-module-independence"><a class="header" href="#incomplete-core-module-independence">Incomplete Core Module Independence</a></h3>
<p>While the recent refactoring (commit 333f1c7) moved configuration structs from <code>src/config/</code> to <code>src/core/options/</code> to improve modularity, the core module is not yet fully independent. There are still some dependencies that need to be addressed:</p>
<ul>
<li>The core module has dependencies on the config layer through re-exports</li>
<li>Some types and functions still reference higher-level modules</li>
<li>Complete independence would require further refactoring of the module boundaries</li>
</ul>
<p>This is a known limitation that may be addressed in future versions. For now, the library functions correctly despite these architectural imperfections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-rustdoc"><a class="header" href="#api-reference-rustdoc">API Reference (rustdoc)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Contributions to RusTree are welcome! Whether it's bug reports, feature requests, documentation improvements, or code contributions, your help is appreciated.</p>
<h2 id="ways-to-contribute"><a class="header" href="#ways-to-contribute">Ways to Contribute</a></h2>
<ul>
<li><strong>Reporting Bugs:</strong> If you find a bug, please open an issue on the GitHub repository. Include steps to reproduce, expected behavior, and actual behavior.</li>
<li><strong>Suggesting Enhancements:</strong> Have an idea for a new feature or an improvement to an existing one? Open an issue to discuss it.</li>
<li><strong>Improving Documentation:</strong> If you find parts of the documentation unclear or missing, feel free to suggest changes or submit a pull request.</li>
<li><strong>Writing Code:</strong> If you'd like to contribute code, please follow the guidelines below.</li>
</ul>
<h2 id="code-contributions"><a class="header" href="#code-contributions">Code Contributions</a></h2>
<ol>
<li><strong>Fork the Repository:</strong> Start by forking the official RusTree repository on GitHub.</li>
<li><strong>Clone Your Fork:</strong> Clone your forked repository to your local machine.
<pre><code class="language-bash">git clone https://github.com/your-username/rustree.git
cd rustree
</code></pre>
</li>
<li><strong>Create a Branch:</strong> Create a new branch for your feature or bug fix.
<pre><code class="language-bash">git checkout -b my-new-feature
</code></pre>
</li>
<li><strong>Make Changes:</strong> Implement your changes.
<ul>
<li>Follow the existing code style. Consider using <code>rustfmt</code> to format your code (<code>cargo fmt</code>).</li>
<li>Add tests for any new functionality or bug fixes.</li>
<li>Ensure all tests pass (<code>cargo test</code>).</li>
<li>Update documentation (both <code>rustdoc</code> comments and <code>mdBook</code> if applicable).</li>
</ul>
</li>
<li><strong>Commit Your Changes:</strong> Commit your changes with a clear and descriptive commit message.
<pre><code class="language-bash">git commit -am "Add some feature"
</code></pre>
</li>
<li><strong>Push to Your Fork:</strong> Push your changes to your forked repository.
<pre><code class="language-bash">git push origin my-new-feature
</code></pre>
</li>
<li><strong>Submit a Pull Request:</strong> Open a pull request from your branch on your fork to the <code>main</code> branch of the official RusTree repository.
<ul>
<li>Provide a clear title and description for your pull request.</li>
<li>Reference any related issues.</li>
</ul>
</li>
</ol>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<ul>
<li>Ensure you have Rust installed (see <a href="https://rustup.rs/">rustup.rs</a>).</li>
<li>To build the project: <code>cargo build</code></li>
<li>To run tests: <code>cargo test</code></li>
<li>To format code: <code>cargo fmt</code></li>
<li>To run linters (clippy): <code>cargo clippy</code></li>
<li>To run benchmarks: <code>cargo bench</code></li>
<li>To build and view <code>rustdoc</code> API documentation: <code>cargo doc --open</code></li>
<li>To build and view <code>mdBook</code> documentation (from the project root):
<pre><code class="language-bash"># Install mdbook if you haven't already: cargo install mdbook
mdbook serve docs
</code></pre>
</li>
</ul>
<p>Thank you for considering contributing to RusTree!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions-faq"><a class="header" href="#frequently-asked-questions-faq">Frequently Asked Questions (FAQ)</a></h1>
<p><strong>Q: How do I ignore files and directories?</strong>
A: RusTree offers several ways:</p>
<ul>
<li><strong><code>-I &lt;PATTERN&gt;</code> or <code>--filter-exclude &lt;PATTERN&gt;</code></strong>: Exclude files/directories matching the glob pattern. This can be used multiple times.</li>
<li><strong><code>--use-gitignore-rules</code> (alias: <code>--gitignore</code>)</strong>: This flag tells RusTree to respect standard gitignore behavior. It will look for <code>.gitignore</code> files in the current directory and parent directories, as well as global gitignore configurations (e.g., <code>~/.config/git/ignore</code> or <code>$XDG_CONFIG_HOME/git/ignore</code>) and repository-specific exclude files (e.g., <code>.git/info/exclude</code>). Note: <code>--gitignore</code> is a deprecated alias.</li>
<li><strong><code>--gitignore-file &lt;FILE&gt;</code></strong>: This option lets you specify one or more custom files that contain gitignore-style patterns. These patterns are applied as if the file was located at the root of the scan.</li>
<li><strong><code>--case-insensitive-filter</code></strong>: This flag makes all pattern matching (from <code>-P</code>/<code>--filter-include</code>, <code>-I</code>/<code>--filter-exclude</code>, <code>--use-gitignore-rules</code>, and <code>--gitignore-file</code>) case-insensitive.</li>
</ul>
<p>These options can be combined. For example, you can use <code>--use-gitignore-rules</code> and also add specific <code>-I</code> patterns.</p>
<p><strong>Q: How does the <code>-P</code> (or <code>--filter-include</code>) pattern matching work?</strong>
A: The <code>-P &lt;PATTERN&gt;</code> or <code>--filter-include &lt;PATTERN&gt;</code> option allows you to specify wildcard patterns to list only matching files and directories.</p>
<ul>
<li>Wildcard patterns supported:
<ul>
<li><code>*</code>: any zero or more characters.</li>
<li><code>?</code>: any single character.</li>
<li><code>[...]</code>: any single character listed (e.g., <code>[abc]</code>, <code>[a-z]</code>).</li>
<li><code>[!...]</code>: any single character not listed.</li>
<li><code>|</code>: separates alternate patterns within a single pattern string (e.g., <code>*.txt|*.log</code>).</li>
</ul>
</li>
<li>A <code>/</code> at the end of a pattern (e.g., <code>mydir/</code>) specifically matches directories.</li>
<li>Note: To match hidden files (starting with <code>.</code>) with patterns like <code>*</code>, you must also use the <code>-a</code> or <code>--include-hidden</code> option. If <code>-a</code> is not used, <code>*</code> will not match hidden entries. Patterns explicitly starting with <code>.</code> (e.g., <code>.*</code>) will match hidden files regardless of <code>-a</code>.</li>
<li>The matching can be made case-insensitive using the <code>--case-insensitive-filter</code> flag.</li>
</ul>
<p><strong>Q: How does <code>--case-insensitive-filter</code> work?</strong>
A: The <code>--case-insensitive-filter</code> flag makes all pattern matching operations case-insensitive. This applies to:</p>
<ul>
<li>Patterns specified with <code>-P &lt;PATTERN&gt;</code> or <code>--filter-include &lt;PATTERN&gt;</code>.</li>
<li>Patterns specified with <code>-I &lt;PATTERN&gt;</code> or <code>--filter-exclude &lt;PATTERN&gt;</code>.</li>
<li>Patterns found in <code>.gitignore</code> files when <code>--use-gitignore-rules</code> (or its alias <code>--gitignore</code>) is active.</li>
<li>Patterns found in custom ignore files specified with <code>--gitignore-file</code>.</li>
</ul>
<p>For example, if <code>--case-insensitive-filter</code> is used, a pattern like <code>-P "*.JPG"</code> would match <code>image.jpg</code>, <code>image.JPG</code>, and <code>image.Jpg</code>. Similarly, an ignore pattern like <code>-I "README.MD"</code> would ignore <code>readme.md</code>.</p>
<p><strong>Q: If I use <code>-d</code> with <code>-s</code> (show size in bytes), will it show directory sizes?</strong>
A: Yes. When <code>-d</code> (or <code>--directory-only</code>) and <code>-s</code> (or <code>--show-size-bytes</code>) are used together, RusTree will report the sizes of the directories themselves (as reported by the operating system, which might vary in meaning, e.g., size of metadata vs. total content size on some systems).</p>
<p>Similarly, if <code>-D</code> (or <code>--show-last-modified</code>) is used with <code>-d</code>, it will show the relevant date (modification or change time, depending on whether <code>-c</code> is also active) for the directories.</p>
<p><strong>Q: How does the <code>-D</code> (or <code>--show-last-modified</code>) flag interact with <code>-c</code> (sort by change time)?</strong>
A:</p>
<ul>
<li>If you use <code>-D</code> (or <code>--show-last-modified</code>) alone, it displays the last modification time (mtime).</li>
<li>If you use <code>-c</code> alone, it sorts by change time (ctime), but <code>-D</code> (or <code>--show-last-modified</code>) is needed to <em>display</em> a time.</li>
<li>If you use both <code>-D</code> (or <code>--show-last-modified</code>) and <code>-c</code> (or <code>-D</code> and <code>--sort-by ctime</code>), then <code>-D</code> (or <code>--show-last-modified</code>) will display the last status change time (ctime) instead of the modification time. This allows you to see the ctime for entries when sorting by ctime.</li>
</ul>
<p><strong>Q: What are apply functions and how do they work?</strong>
A: Apply functions let you analyze and process file or directory contents. They come in two types:</p>
<ul>
<li><strong>File functions</strong> work on file content:
<ul>
<li><code>count-pluses</code>: Counts '+' characters in each file</li>
<li><code>cat</code>: Displays file contents after the tree structure</li>
</ul>
</li>
<li><strong>Directory functions</strong> work on directory children:
<ul>
<li><code>count-files</code>: Counts files in each directory</li>
<li><code>count-dirs</code>: Counts subdirectories in each directory</li>
<li><code>size-total</code>: Calculates total size of files in each directory</li>
<li><code>dir-stats</code>: Shows combined statistics (files, dirs, total size)</li>
</ul>
</li>
</ul>
<p>Use <code>--apply-function &lt;FUNCTION_NAME&gt;</code> to enable a function. The results appear in metadata like <code>[F: "5"]</code> or after the tree (for <code>cat</code>).</p>
<p><strong>Q: Can I apply functions only to specific files or directories?</strong>
A: Yes! Use apply-function filtering:</p>
<ul>
<li><code>--apply-include &lt;PATTERN&gt;</code>: Apply function only to matching files/directories</li>
<li><code>--apply-exclude &lt;PATTERN&gt;</code>: Don't apply function to matching files/directories</li>
<li><code>--apply-include-from &lt;FILE&gt;</code>: Read include patterns from a file</li>
<li><code>--apply-exclude-from &lt;FILE&gt;</code>: Read exclude patterns from a file</li>
</ul>
<p>These use the same wildcard syntax as <code>--filter-include</code> and can be combined. Pattern files support comments (lines starting with <code>#</code>) and ignore empty lines.</p>
<p><strong>Q: Why do I get <code>[F: "0"]</code> for all directories when using <code>size-total</code>?</strong>
A: The <code>size-total</code> function requires file size information to work. Make sure to use <code>--show-size-bytes</code> (or <code>-s</code>) along with <code>--apply-function size-total</code>. Without this flag, file sizes aren't collected and the total will always be 0.</p>
<p><strong>Q: How do apply functions work with sorting?</strong>
A: You can sort by apply function results using <code>--sort-by custom</code>. This sorts by the function output:</p>
<ul>
<li>Numeric results (like counts) are sorted numerically</li>
<li>String results are sorted lexicographically</li>
<li>Use <code>--reverse-sort</code> to reverse the order</li>
</ul>
<p>For example: <code>rustree --apply-function dir-stats --sort-by custom -r</code> sorts directories by complexity (most files/subdirs first).</p>
<p><strong>Q: What's the difference between <code>--dry-run</code> and normal LLM queries?</strong>
A: The <code>--dry-run</code> flag previews what would be sent to the LLM without actually making the API call:</p>
<ul>
<li>Shows exactly what request would be sent (headers, body, endpoint)</li>
<li>Displays token estimation for cost planning</li>
<li>No API key required and no network traffic</li>
<li>Perfect for debugging prompts and verifying configurations</li>
<li>Can be combined with <code>--human-friendly</code> for better readability</li>
</ul>
<p><strong>Q: When should I use <code>--human-friendly</code> with <code>--dry-run</code>?</strong>
A: Use <code>--human-friendly</code> when you want easier-to-read output:</p>
<ul>
<li>Organizes information into clear sections (Configuration, Headers, Messages, etc.)</li>
<li>Formats JSON in a more readable way</li>
<li>Shows key parameters prominently</li>
<li>Great for sharing dry-run outputs or documentation</li>
<li>Note: <code>--human-friendly</code> requires <code>--dry-run</code> to be enabled</li>
</ul>
<p><strong>Q: How do I estimate LLM costs before making requests?</strong>
A: Use <code>--dry-run</code> to see token estimates:</p>
<pre><code class="language-bash">rustree --llm-ask "Your question" --dry-run
# Shows: "Estimated tokens: 356 prompt + 1000 completion ≈ 1356 total"
</code></pre>
<p>Then calculate costs based on your provider's pricing (e.g., OpenAI charges per 1000 tokens).</p>
<p><strong>Q: How accurate are the token estimates shown in <code>--dry-run</code>?</strong>
A: The token estimates are <strong>rough approximations</strong> using simple heuristics:</p>
<p><strong>Estimation Method:</strong></p>
<ul>
<li><strong>Prompt tokens</strong>: Uses a 4:1 character-to-token ratio (<code>prompt_length / 4</code>)</li>
<li><strong>Completion tokens</strong>: Uses your <code>--llm-max-tokens</code> setting (assumes full usage)</li>
<li><strong>Total</strong>: Simple addition of prompt + completion estimates</li>
</ul>
<p><strong>Limitations &amp; Accuracy:</strong></p>
<ul>
<li>⚠️ <strong>This is a ballpark estimate, not precise billing calculation</strong></li>
<li>Character-to-token ratios vary significantly by content type:
<ul>
<li>Code/structured text: Often more tokens per character</li>
<li>Natural language: Closer to 4:1 ratio</li>
<li>Special characters/punctuation: Affects ratio</li>
</ul>
</li>
<li>Different providers use different tokenizers (OpenAI/tiktoken, Anthropic, Cohere)</li>
<li>Assumes maximum completion token usage (rarely happens in practice)</li>
<li>Doesn't account for JSON request overhead</li>
</ul>
<p><strong>Recommendations:</strong></p>
<ul>
<li>Use estimates for rough cost planning and comparing prompt sizes</li>
<li>For precise billing, use provider-specific tokenization tools:
<ul>
<li>OpenAI: <code>tiktoken</code> library</li>
<li>Anthropic: Claude API token counting</li>
<li>Check your provider's dashboard for actual usage</li>
</ul>
</li>
<li>Consider estimates as "worst-case" scenarios for budgeting</li>
</ul>
<p><strong>Q: How are the <code>&lt;tree_output&gt;</code> and <code>&lt;user_request&gt;</code> tags used?</strong>
A: These XML-style tags help the LLM understand the prompt structure:</p>
<ul>
<li><code>&lt;tree_output&gt;...&lt;/tree_output&gt;</code> contains the directory tree from the tree command</li>
<li><code>&lt;user_request&gt;...&lt;/user_request&gt;</code> contains your question/request</li>
<li>This clear separation helps LLMs provide more relevant and focused responses</li>
<li>The tags are automatically added to all LLM requests</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
