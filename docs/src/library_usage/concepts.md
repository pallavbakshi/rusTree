## Core Library Concepts

Understanding these core components will help you effectively use the `rustree` library.

### `RustreeLibConfig`

This struct is central to controlling how `rustree` behaves. You create an instance of `RustreeLibConfig` and set its fields to specify:

*   `root_display_name`: How the root directory is named in the output.
*   `max_depth`: The maximum depth of traversal.
*   `show_hidden`: Whether to include hidden files/directories.
*   `report_sizes`, `report_mtime`: Whether to collect and report file sizes and modification times.
*   `calculate_line_count`, `calculate_word_count`: Whether to perform these analyses on files.
*   `apply_function`: An optional `BuiltInFunction` to apply to file contents.
*   `sort_by`: An optional `SortKey` to sort sibling entries.
*   `reverse_sort`: Whether to reverse the sort order.

**Example:**

```rust
use rustree::{RustreeLibConfig, SortKey};

let config = RustreeLibConfig {
    root_display_name: "MyProject".to_string(),
    max_depth: Some(3),
    show_hidden: false,
    report_sizes: true,
    sort_by: Some(SortKey::Size),
    reverse_sort: true,
    ..Default::default() // Use defaults for other fields
};
```

### `NodeInfo`

Each file or directory encountered during the scan is represented by a `NodeInfo` struct. It contains:

*   `path`: The full `PathBuf` to the entry.
*   `name`: The file or directory name as a `String`.
*   `node_type`: A `NodeType` enum (`File`, `Directory`, `Symlink`).
*   `depth`: The entry's depth in the tree.
*   `size`: `Option<u64>` for file size.
*   `mtime`: `Option<SystemTime>` for modification time.
*   `line_count`, `word_count`: `Option<usize>` for analysis results.
*   `custom_function_output`: `Option<Result<String, ApplyFnError>>` for results of `apply_function`.

You typically receive a `Vec<NodeInfo>` from `get_tree_nodes()`.

### `get_tree_nodes()`

This is the primary function for generating the tree data.

```rust
use rustree::{get_tree_nodes, RustreeLibConfig, NodeInfo, RustreeError};
use std::path::Path;

fn list_directory_contents(path_str: &str, config: &RustreeLibConfig) -> Result<Vec<NodeInfo>, RustreeError> {
    let root_path = Path::new(path_str);
    get_tree_nodes(root_path, config)
}
```

It takes the root path and a `RustreeLibConfig` and returns a `Result<Vec<NodeInfo>, RustreeError>`.

### `format_nodes()`

Once you have the `Vec<NodeInfo>`, you can format it into a string.

```rust
use rustree::{format_nodes, NodeInfo, LibOutputFormat, RustreeLibConfig, RustreeError};

fn display_tree(nodes: &[NodeInfo], format: LibOutputFormat, config: &RustreeLibConfig) -> Result<String, RustreeError> {
    format_nodes(nodes, format, config)
}
```
This function takes the nodes, a `LibOutputFormat` enum (`Text` or `Markdown`), and the `RustreeLibConfig` (as some config options affect formatting).

### Key Enums

*   **`SortKey`**: `Name`, `Size`, `MTime`, `Words`, `Lines`, `Custom`. Used in `RustreeLibConfig` to specify sorting.
*   **`LibOutputFormat`**: `Text`, `Markdown`. Used with `format_nodes()`.
*   **`BuiltInFunction`**: e.g., `CountPluses`. Used in `RustreeLibConfig` for `apply_function`.
*   **`NodeType`**: `File`, `Directory`, `Symlink`. Found in `NodeInfo`.
*   **`RustreeError`**: The error type returned by library functions.

Refer to the API documentation (generated by `cargo doc`) for the full details of these types and their variants/fields.